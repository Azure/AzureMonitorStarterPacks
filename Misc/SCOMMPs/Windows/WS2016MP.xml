<ManagementPack ContentReadable="true" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Manifest>
    <Identity>
      <ID>Microsoft.Windows.Server.2016.Monitoring</ID>
      <Version>10.1.0.6</Version>
    </Identity>
    <Name>Microsoft Windows Server 2016 Monitoring MP</Name>
    <References>
      <Reference Alias="SCDW">
        <ID>Microsoft.SystemCenter.DataWarehouse.Library</ID>
        <Version>6.0.6278.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="ReportLibrary">
        <ID>Microsoft.SystemCenter.DataWarehouse.Report.Library</ID>
        <Version>6.0.6278.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>6.0.6278.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>6.0.6278.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SystemHealth">
        <ID>System.Health.Library</ID>
        <Version>6.0.6278.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>6.0.6278.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SystemPerf">
        <ID>System.Performance.Library</ID>
        <Version>6.0.6278.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="ServervNext">
        <ID>Microsoft.Windows.Server.2016.Discovery</ID>
        <Version>10.0.8.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="WindowsServer">
        <ID>Microsoft.Windows.Server.Library</ID>
        <Version>10.0.8.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <ModuleTypes>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.ModuleType" Accessibility="Public" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="PhysicalMemory" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Tolerance" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Frequency" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="MaximumSampleSeparation" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Tolerance" Selector="$Config/Tolerance$" ParameterType="int" />
          <OverrideableParameter ID="Frequency" Selector="$Config/Frequency$" ParameterType="int" />
          <OverrideableParameter ID="NumOfSamples" Selector="$Config/MaximumSampleSeparation$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="PerfDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
                <CounterName>Available MBytes</CounterName>
                <ObjectName>Memory</ObjectName>
                <InstanceName />
                <AllInstances>false</AllInstances>
                <Frequency>$Config/Frequency$</Frequency>
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>Absolute</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
              </DataSource>
              <ProbeAction ID="ScriptDS" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
                <ScriptName>Microsoft.Windows.Server.OperatingSystem.PercentMemoryUsed.ps1</ScriptName>
                <PSparam>param ($nAvailableMBytes, $nPhysicalMemoryKBytes)</PSparam>
                <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.

#*************************************************************************
# $ScriptName: "Microsoft.Windows.Server.OperatingSystem.PercentMemoryUsed"$
#
#
# $File: Microsoft.Windows.Server.OperatingSystem.PercentMemoryUsed.ps1$
#*************************************************************************

# Parameters that should be passed to this script
# 0 Available Physical memory MBytes.
# 1 Total amount of Physical Memory in KBytes.

$sCounterName = "PercentMemoryUsed"
$sObjectName  = "Memory"

Function Main()
{
    $sErrorDescription = "Invalid arguments are detected: " + $nAvailableMBytes + " " + $nPhysicalMemoryKBytes
    $dblAvailableMBytes = $nAvailableMBytes -as [double]
    $dblPhysicalMemoryKBytes = $nPhysicalMemoryKBytes -as [double]

    if (($dblAvailableMBytes -eq $null) -or ($dblPhysicalMemoryKBytes -eq $null))
    {
        ThrowScriptError $sErrorDescription $null
    }

    $dblPhysicalMemoryMBytes = $dblPhysicalMemoryKBytes / 1024

    if ($dblAvailableMBytes -gt 0)
    {
        if ($dblAvailableMBytes -ge $dblPhysicalMemoryMBytes)
        {
            ThrowScriptError $sErrorDescription $null
        }

        $oBag = $momAPI.CreateTypedPropertyBag(2)

        $nResult = [double](100 - ($dblAvailableMBytes/$dblPhysicalMemoryMBytes)*100)

        $oBag.AddValue("PerfCounter", $sCounterName)
        $oBag.AddValue("PerfValue", $nResult)

        $oBag
    }
}

Main
</ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>nAvailableMBytes</Name>
                    <Value>$Data/Value$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>nPhysicalMemoryKBytes</Name>
                    <Value>$Config/PhysicalMemory$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>300</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection ID="PerfMapper" TypeID="SystemPerf!System.Performance.DataGenericMapper">
                <ObjectName>Memory</ObjectName>
                <CounterName>$Data/Property[@Name='PerfCounter']$</CounterName>
                <InstanceName />
                <Value>$Data/Property[@Name='PerfValue']$</Value>
              </ConditionDetection>
              <ConditionDetection ID="IsNullCD" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">/DataItem/IsNull</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">false</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="PerfMapper">
                <Node ID="ScriptDS">
                  <Node ID="IsNullCD">
                    <Node ID="PerfDS" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ModuleType" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IsDiscoverDisabled" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IsUseMacAddress" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Interval" Selector="$Config/IntervalSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/IntervalSeconds$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
                <ScriptName>Microsoft.Windows.Server.NetworkAdapter.BandwidthUsed.ModuleType.ps1</ScriptName>
                <PSparam>param ($sTargetComputer, $IsUseMacAddress)</PSparam>
                <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 Computer name this rule is running against
# 1 Use MacAddress for discovery (true), otherwise NetConnectionID

$CN_PercentBandwidthUsedRead   = "PercentBandwidthUsedRead"
$CN_PercentBandwidthUsedWrite   = "PercentBandwidthUsedWrite"
$CN_PercentBandwidthUsedTotal   = "PercentBandwidthUsedTotal"
$WIN_SRV_VNEXT_OSVer = "6.3"

Function Main()
{   
	# Win32_NetworkAdapter is deprecated and not returning results on NanoServer
	# Need to use MSFT_NetAdapter
	    $bIsUseMacAddress = Convert-ToBoolean -sBool $IsUseMacAddress
		$bIsModuleLoaded = Load-Module -ModuleName "NetAdapter"
		$bHasItems = $false

        if ($false -eq $bIsModuleLoaded)
	    {
			$netAdapters = $null
		} 
	    else
	        { 
				# -Physical Corresponds to "ServiceName &lt;&gt; 'VMSMP'"
				$netAdapters = Get-NetAdapter -Physical | Where `
				 {($bIsUseMacAddress -eq $true -and $_.MacAddress -ne $null -and $false -eq [string]::IsNullOrEmpty($_.Name)) `
						-or ($bIsUseMacAddress -eq $false -and  $false -eq [string]::IsNullOrEmpty($_.Name))} 
			}

		foreach ($netAdapter in $netAdapters)
		{
			$bIsDisabled = $netAdapter.MediaConnectState -eq "2"
			$sPerfMonInstanceName = GetPerfmonInstance $netAdapter.InterfaceDescription
			$sQuery = "Win32_PerfFormattedData_Tcpip_NetworkAdapter Where Name ='" + $sPerfMonInstanceName + "'"

			$WMISet2 = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" $sQuery

			if ($null -ne $WMISet2 -and $null -eq $WMISet2.Count)
			{
			  $nCurrentBandwidth    = $WMISet2.CurrentBandwidth
			  $nBytesSentPersec     = $WMISet2.BytesSentPersec
			  $nBytesReceivedPersec = $WMISet2.BytesReceivedPersec
			  $nBytesTotalPersec    = $WMISet2.BytesTotalPersec

					if ($nCurrentBandwidth -ne $null -and $nBytesSentPersec -ne $null -and $nBytesReceivedPersec -ne $null -and $nBytesTotalPersec -ne $null)
					{
						$Counters = @{}
						$Counters[$CN_PercentBandwidthUsedRead] = CalculatePercent $nBytesReceivedPersec ($nCurrentBandwidth/8) # Divide CurrentBandwidth by 8 to convert it from bits to bytes.
						$Counters[$CN_PercentBandwidthUsedWrite] = CalculatePercent $nBytesSentPersec ($nCurrentBandwidth/8)
						$Counters[$CN_PercentBandwidthUsedTotal] = CalculatePercent $nBytesTotalPersec ($nCurrentBandwidth/8)
						$bHasItems = $true
						foreach ($oCounter in $Counters.Keys)
						{
							$oBag = $momAPI.CreateTypedPropertyBag(2)
							$oBag.AddValue("IsNotEmpty", $bHasItems)
							$oBag.AddValue("IsDisabled", $bIsDisabled)
							$oBag.AddValue("PerfInstance", $sPerfMonInstanceName)
							$oBag.AddValue("PerfCounter", $oCounter)
							$oBag.AddValue("PerfValue", $Counters.Item($oCounter))
							$oBag
						}
					}
		   }
			
		}

	    Add-EmptyBag -bHasItems $bHasItems 

}

Function Add-EmptyBag([bool]$bHasItems)
{
	if ($true -eq $bHasItems)
	{
		return
	}

	$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
	$error.Clear()

	$oEmptyBag = $momAPI.CreateTypedPropertyBag(2)

	$oEmptyBag.AddValue("IsNotEmpty", $bHasItems)
	$oEmptyBag.AddValue("PerfInstance", "")
	$oEmptyBag.AddValue("PerfCounter", "")
	$oEmptyBag.AddValue("PerfValue", "")
	$oEmptyBag
}

Function CalculatePercent($nDivident, $nDivider)
{
    $nResult = 0
    If (($nDivider -ne 0) -and ($nDivident -ne 0))
    {
        $nResult = $nDivident/$nDivider*100
    }
    return $nResult
}

Function GetPerfmonInstance($sName)
{
    $sName = $sName -replace("\(","[")
    $sName = $sName -replace("\)","]")
    $sName = $sName -replace("/","_")
    $sName = $sName -replace("#","_")
    return $sName
}



Main</ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>sTargetComputer</Name>
                    <Value>$Config/ComputerName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>IsUseMacAddress</Name>
                    <Value>$Config/IsUseMacAddress$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>300</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection ID="PerfMapper" TypeID="SystemPerf!System.Performance.DataGenericMapper">
                <ObjectName>Network Adapter</ObjectName>
                <CounterName>$Data/Property[@Name='PerfCounter']$</CounterName>
                <InstanceName>$Data/Property[@Name='PerfInstance']$</InstanceName>
                <Value>$Data/Property[@Name='PerfValue']$</Value>
              </ConditionDetection>
              <ConditionDetection ID="InstanceFilter" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='PerfInstance']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/InstanceName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='PerfCounter']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/CounterName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection ID="EmptyCondition" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='IsNotEmpty']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">true</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <Or>
                        <Expression>
                          <SimpleExpression>
                            <ValueExpression>
                              <Value Type="Boolean">$Config/IsDiscoverDisabled$</Value>
                            </ValueExpression>
                            <Operator>Equal</Operator>
                            <ValueExpression>
                              <Value Type="Boolean">true</Value>
                            </ValueExpression>
                          </SimpleExpression>
                        </Expression>
                        <Expression>
                          <And>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <Value Type="Boolean">$Config/IsDiscoverDisabled$</Value>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value Type="Boolean">false</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery Type="Boolean">Property[@Name='IsDisabled']</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value Type="Boolean">false</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                          </And>
                        </Expression>
                      </Or>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="PerfMapper">
                <Node ID="InstanceFilter">
                  <Node ID="EmptyCondition">
                    <Node ID="PA">
                      <Node ID="Scheduler" />
                    </Node>
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.CPUUtilization.ModuleType" Accessibility="Internal">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NumSamples" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AllInstances" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="SystemPerf!System.Performance.DataProvider" ID="DS1">
                <ComputerName>$Config/TargetComputerName$</ComputerName>
                <CounterName>$Config/CounterName$</CounterName>
                <ObjectName>$Config/ObjectName$</ObjectName>
                <InstanceName>$Config/InstanceName$</InstanceName>
                <AllInstances>$Config/AllInstances$</AllInstances>
                <Frequency>$Config/IntervalSeconds$</Frequency>
              </DataSource>
              <ConditionDetection TypeID="SystemPerf!System.Performance.AveragerCondition" ID="CDAverageThreshold">
                <NumSamples>$Config/NumSamples$</NumSamples>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="CDAverageThreshold">
                <Node ID="DS1" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DiskLabel" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveWarningMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveWarningPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveErrorMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveErrorPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveWarningMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveWarningPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveErrorMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveErrorPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Interval" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SystemDriveWarningMBytesThreshold" Selector="$Config/SystemDriveWarningMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveWarningPercentThreshold" Selector="$Config/SystemDriveWarningPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveErrorMBytesThreshold" Selector="$Config/SystemDriveErrorMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveErrorPercentThreshold" Selector="$Config/SystemDriveErrorPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveWarningMBytesThreshold" Selector="$Config/NonSystemDriveWarningMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveWarningPercentThreshold" Selector="$Config/NonSystemDriveWarningPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveErrorMBytesThreshold" Selector="$Config/NonSystemDriveErrorMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveErrorPercentThreshold" Selector="$Config/NonSystemDriveErrorPercentThreshold$" ParameterType="double" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/IntervalSeconds$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
                <ScriptName>Microsoft.Windows.Server.FreeSpace.ps1</ScriptName>
                <PSparam>param ($TargetComputer, $DebugFlag, $SysWarningMB, $SysWarningPct, $SysErrorMB, $SysErrorPct, $NonSysWarningMB, $NonSysWarningPct, $NonSysErrorMB, $NonSysErrorPct)</PSparam>
                <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
#
# Parameters that should be passed to this script
# 0 Computer (FQDN)
# 1 Debug Flag          - If True then script can output some trace information to event log.
# 2 System Drive Warning MBytes Threshold
# 3 System Drive Warning Percent Threshold
# 4 System Drive Error MBytes Threshold
# 5 System Drive Error Percent Threshold
# 6 Non System Drive Warning MBytes Threshold
# 7 Non System Drive Warning Percent Threshold
# 8 Non System Drive Error MBytes Threshold
# 9 Non System Drive Error Percent Threshold

$BYTES_IN_MB = 1048576 #=2^20

$DriveHealthyState            = 0
$DriveWarningState            = 1
$DriveErrorState              = 2

Function Main()
{
    $g_DebugFlag      = Convert-ToBoolean -sBool $DebugFlag
	$bBagIsNotEmpty = $false
	$IsNotEmpty     = $false

 	$IsNano = Is_NanoServer 
    $IsVolumeInfoSupported = Is_Win32_Volume_Supported $TargetComputer 
    $SystemDrive = Get_System_Drive $TargetComputer
  

   $oVolumes =  Get-Volumes -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -TargetComputer $TargetComputer  
    
    foreach ($oVolume in $oVolumes)
    {
 		$VolumeId = Get-VolumeId -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -Volume $oVolume
		if ($true -eq $IsNano)
		{
			$nFreeSpace = $oVolume.SizeRemaining
			$nMaxSize   = $oVolume.Size
		}
		else
		   {
				$nFreeSpace = $oVolume.FreeSpace
			   if ($IsVolumeInfoSupported)
			   {
				   $nMaxSize = $oVolume.Capacity
			   }
				else
					{
						$nMaxSize   = $oVolume.Size
					}
           }

 		    Create-PerfData -VolumeId $VolumeId -nMaxSize $nMaxSize -nFreeSpace $nFreeSpace -SystemDrive $SystemDrive -momAPI $momAPI  -bBagIsNotEmpty ([ref]$IsNotEmpty)
            if ($false -eq $bBagIsNotEmpty)
		    {
				if ($true -eq $IsNotEmpty)
				{
					$bBagIsNotEmpty = $true
				}
			}   
    }
    
    if ($false -eq $bBagIsNotEmpty)
    {
        $oBag = $momAPI.CreatePropertyBag()
        $oBag.AddValue("IsNotEmpty", "false")
        $oBag
    }

	Unload-Module -ModuleName "Storage"
	Unload-Module -ModuleName "CimCmdLets"

}

Function GetDriveHealthState
{
    param ($bIsSystem, $dSysWarnMB, $dSysWarnPct, $dSysErrorMB, $dSysErrorPct, $dNonSysWarnMB, $dNonSysWarnPct, $dNonSysErrorMB, $dNonSysErrorPct, $dPctFree, $dMBFree)

    $fResult = $DriveHealthyState

    If ($bIsSystem)
    {
        If (($dMBFree -le $dSysErrorMB) -and ($dPctFree -le $dSysErrorPct))
        {
            $fResult = $DriveErrorState
        }
        ElseIf (($dMBFree -le $dSysWarnMB) -and ($dPctFree -le $dSysWarnPct))
        {
            $fResult = $DriveWarningState
        }
    }
    Else
    {
        If (($dMBFree -le $dNonSysErrorMB) -and ($dPctFree -le $dNonSysErrorPct))
        {
            $fResult = $DriveErrorState
        }
        ElseIf (($dMBFree -le $dNonSysWarnMB) -and ($dPctFree -le $dNonSysWarnPct))
        {
            $fResult = $DriveWarningState
        }
    }

    return $fResult
}

Function Create-PerfData([string]$VolumeId,$nMaxSize,$nFreeSpace,[string]$SystemDrive,$momAPI, [ref]$bBagIsNotEmpty)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $momAPI)
	{
		return
	}

	if ($nMaxSize -eq $null -or $nMaxSize -eq 0)
    {
		return
	}

    if ($nFreeSpace -eq $null) 
	{
		 $nFreeSpace = 0 
	}

    $nPctFree = [math]::Round($nFreeSpace / $nMaxSize * 100, 2)
    $nMBFree = [math]::Round($nFreeSpace / $BYTES_IN_MB, 0)
    
	if ($VolumeId -ieq $SystemDrive)
    {
        $bIsSystemDrive = $true
    }
    else
    {
        $bIsSystemDrive = $false
    }

	$State = GetDriveHealthState $bIsSystemDrive $SysWarningMB $SysWarningPct $SysErrorMB $SysErrorPct $NonSysWarningMB $NonSysWarningPct $NonSysErrorMB $NonSysErrorPct $nPctFree $nMBFree
	
	$oBag = $momAPI.CreatePropertyBag()
    $oBag.AddValue("IsNotEmpty", "true")
    $oBag.AddValue("PerfInstance", $VolumeId)
	$oBag.AddValue("DiskState",$State)

	if ($error.Count -eq 0)
	{
		$oBag
		$bBagIsNotEmpty.Value = $true
	}

} 




Main
</ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>TargetComputer</Name>
                    <Value>$Config/ComputerName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>DebugFlag</Name>
                    <Value>false</Value>
                  </Parameter>
                  <Parameter>
                    <Name>SysWarningMB</Name>
                    <Value>$Config/SystemDriveWarningMBytesThreshold$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>SysWarningPct</Name>
                    <Value>$Config/SystemDriveWarningPercentThreshold$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>SysErrorMB</Name>
                    <Value>$Config/SystemDriveErrorMBytesThreshold$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>SysErrorPct</Name>
                    <Value>$Config/SystemDriveErrorPercentThreshold$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>NonSysWarningMB</Name>
                    <Value>$Config/NonSystemDriveWarningMBytesThreshold$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>NonSysWarningPct</Name>
                    <Value>$Config/NonSystemDriveWarningPercentThreshold$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>NonSysErrorMB</Name>
                    <Value>$Config/NonSystemDriveErrorMBytesThreshold$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>NonSysErrorPct</Name>
                    <Value>$Config/NonSystemDriveErrorPercentThreshold$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>300</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection ID="EmptyCD" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="Boolean">Property[@Name='IsNotEmpty']</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="Boolean">true</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </ConditionDetection>
              <ConditionDetection ID="InstanceFilter" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Property[@Name='DiskLabel']</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">$Config/DiskLabel$</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="InstanceFilter">
                <Node ID="EmptyCD">
                  <Node ID="PA">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.LogicalDisk.ModuleType" RunAs="System!System.PrivilegedMonitoringAccount" Accessibility="Internal">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/IntervalSeconds$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
                <ScriptName>Microsoft.Windows.Server.LogicalDiskHealthCheck.ps1</ScriptName>
                <PSparam>param ($TargetComputer)</PSparam>
                <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 Computer (FQDN)

Function Main()
{

	$IsNano = Is_NanoServer 
    $IsVolumeInfoSupported = Is_Win32_Volume_Supported $TargetComputer    
	$states = @{$false = "OK"; $true = "BAD"}
    $oVolumes =  Get-Volumes -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -TargetComputer $TargetComputer    

    foreach ($oVolume in $oVolumes)
    {
		 $VolumeId = Get-VolumeId -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -Volume $oVolume

        if ($false -eq [string]::IsNullOrEmpty($VolumeId) )
        {  
            if ($false -eq $IsNano)
            {
                $DirtyBitSet = -Not([string]::IsNullOrEmpty($oVolume.DirtyBitSet))
				if ($true -eq $DirtyBitSet)
				{
						$DirtyBitSet = $oVolume.DirtyBitSet
				}
			}
            else
            {
				#Change for Test Monitor on Nano. -Not was removed
                $DirtyBitSet = -Not ($oVolume.HealthStatus -ieq "Healthy")
            }
         
            $State = $states[$DirtyBitSet]

			Create-State -VolumeId $VolumeId -State $State -momAPI $momAPI
        }
    }

	Unload-Module -ModuleName "Storage"
}

Function Create-State([string]$VolumeId,[string]$State,$momAPI)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $momAPI)
	{
		return
	}

    $oBag = $momAPI.CreatePropertyBag()
    $oBag.AddValue("DiskLabel", $VolumeId)
    $oBag.AddValue("State", $State)

	if ($error.Count -eq 0)
	{
		$oBag
	}
} 



Main
</ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>TargetComputer</Name>
                    <Value>$Config/TargetComputerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.ModuleType" Accessibility="Internal">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NumSamples" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AllInstances" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="SystemPerf!System.Performance.DataProvider" ID="DS1">
                <ComputerName>$Config/TargetComputerName$</ComputerName>
                <CounterName>$Config/CounterName$</CounterName>
                <ObjectName>$Config/ObjectName$</ObjectName>
                <InstanceName>$Config/InstanceName$</InstanceName>
                <AllInstances>$Config/AllInstances$</AllInstances>
                <Frequency>$Config/IntervalSeconds$</Frequency>
              </DataSource>
              <ConditionDetection TypeID="SystemPerf!System.Performance.AveragerCondition" ID="CDAverageThreshold">
                <NumSamples>$Config/NumSamples$</NumSamples>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="CDAverageThreshold">
                <Node ID="DS1" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.DiskState.DS.Moduletype" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DiskLabel" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/IntervalSeconds$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
                <ScriptName>Microsoft.Windows.Server.DiskState.ps1</ScriptName>
                <PSparam>param ($TargetComputer)</PSparam>
                <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
#
# Parameters that should be passed to this script
# 0 Computer (FQDN)


$BYTES_IN_MB = 1048576 #=2^20

$LogicalObjectName     = "System Logical Disk"
$GeneralObjectName     = "Logical Disk"
$PrcFreeCounterName    = "PercentFree"
$MbFreeCounterName     = "MbFree"

Function Main()
{
	$bBagIsNotEmpty = $false
	$IsNotEmpty     = $false
 	$IsNano = Is_NanoServer 
    $IsVolumeInfoSupported = Is_Win32_Volume_Supported $TargetComputer 
    $SystemDrive = Get_System_Drive $TargetComputer
  

   $oVolumes =  Get-Volumes -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -TargetComputer $TargetComputer  
    

    foreach ($oVolume in $oVolumes)
    {
         
		$VolumeId = Get-VolumeId -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -Volume $oVolume
		if ($true -eq $IsNano)
		{
			$nFreeSpace = $oVolume.SizeRemaining
			$nMaxSize   = $oVolume.Size
		}
		else
		   {
				$nFreeSpace = $oVolume.FreeSpace
			   if ($IsVolumeInfoSupported)
			   {
				   $nMaxSize = $oVolume.Capacity
			   }
				else
					{
						$nMaxSize   = $oVolume.Size
					}
           }
            
		    
			Create-PerfData -VolumeId $VolumeId -nMaxSize $nMaxSize -nFreeSpace $nFreeSpace -SystemDrive $SystemDrive -momAPI $momAPI -bBagIsNotEmpty ([ref]$IsNotEmpty)
            if ($false -eq $bBagIsNotEmpty)
		    {
				if ($true -eq $IsNotEmpty)
				{
					$bBagIsNotEmpty = $true
				}
			}
        
    }
    
    if ($false -eq $bBagIsNotEmpty)
    {
		$ErrorActionPreference="SilentlyContinue"
		$error.Clear()
        $oBag = $momAPI.CreatePropertyBag()
        $oBag.AddValue("IsNotEmpty", "false")
        $oBag
    }

	Unload-Module -ModuleName "Storage"
	Unload-Module -ModuleName "CimCmdLets"
}

Function Create-PerfData([string]$VolumeId,$nMaxSize,$nFreeSpace,[string]$SystemDrive,$momAPI, [ref]$bBagIsNotEmpty)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $momAPI)
	{
		return
	}

	if ($nMaxSize -eq $null -or $nMaxSize -eq 0)
    {
		return
	}

    if ($nFreeSpace -eq $null) 
	{
		 $nFreeSpace = 0 
	}

    $nPctFree = [math]::Round($nFreeSpace / $nMaxSize * 100, 2)
    $nMBFree = [math]::Round($nFreeSpace / $BYTES_IN_MB, 0)
    if ($VolumeId -ieq $SystemDrive)
    {
       $bIsSystemDrive = "true"
       $sPerfObject = $LogicalObjectName
    }
    else
    {
       $bIsSystemDrive = "false"
       $sPerfObject = $GeneralObjectName  
    }

    $oBag = $momAPI.CreateTypedPropertyBag(2) 
	$oBag.AddValue("IsNotEmpty", "true")
    $oBag.AddValue("PerfObject" ,  $sPerfObject)
    $oBag.AddValue("PerfCounter" , $PrcFreeCounterName)
    $oBag.AddValue("PerfInstance", $VolumeId)
    $oBag.AddValue("PerfValue", [string]$nPctFree)

	if ($error.Count -eq 0)
	{
		$oBag
		$bBagIsNotEmpty.Value = $true
	}

	$error.Clear()
    $oBag = $momAPI.CreateTypedPropertyBag(2) 
    $oBag.AddValue("IsNotEmpty", "true")
    $oBag.AddValue("PerfObject" ,  $sPerfObject)
    $oBag.AddValue("PerfCounter" , $MbFreeCounterName)
    $oBag.AddValue("PerfInstance", $VolumeId)
    $oBag.AddValue("PerfValue", [string]$nMBFree)

	if ($error.Count -eq 0)
	{
		$oBag
		$bBagIsNotEmpty.Value = $true
	}
} 


Main
</ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>TargetComputer</Name>
                    <Value>$Config/ComputerName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>300</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection ID="PerfMapper" TypeID="SystemPerf!System.Performance.DataGenericMapper">
                <ObjectName>$Data/Property[@Name='PerfObject']$</ObjectName>
                <CounterName>$Data/Property[@Name='PerfCounter']$</CounterName>
                <InstanceName>$Data/Property[@Name='PerfInstance']$</InstanceName>
                <Value>$Data/Property[@Name='PerfValue']$</Value>
              </ConditionDetection>
              <ConditionDetection ID="EmptyCD" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="Boolean">Property[@Name='IsNotEmpty']</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="Boolean">true</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </ConditionDetection>
              <ConditionDetection ID="InstanceFilter" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='PerfInstance']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/DiskLabel$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">Property[@Name='PerfCounter']</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/CounterName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="PerfMapper">
                <Node ID="InstanceFilter">
                  <Node ID="EmptyCD">
                    <Node ID="PA">
                      <Node ID="Scheduler" />
                    </Node>
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.ModuleType" Accessibility="Public" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DebugFlag" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="DebugFlag" Selector="$Config/DebugFlag$" ParameterType="bool" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/IntervalSeconds$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
                <ScriptName>Microsoft.Windows.Server.Legacy.FreeSpace.ps1</ScriptName>
                <PSparam>param ($TargetComputer, $DebugFlag)</PSparam>
                <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
#
# Parameters that should be passed to this script
# 0 Computer (FQDN)
# 1 Debug Flag          - If True then script can output some trace information to event log.
# 2 System Drive Warning MBytes Threshold
# 3 System Drive Warning Percent Threshold
# 4 System Drive Error MBytes Threshold
# 5 System Drive Error Percent Threshold
# 6 Non System Drive Warning MBytes Threshold
# 7 Non System Drive Warning Percent Threshold
# 8 Non System Drive Error MBytes Threshold
# 9 Non System Drive Error Percent Threshold

$BYTES_IN_MB = 1048576 #=2^20

$DriveHealthyState            = 0
$DriveWarningState            = 1
$DriveErrorState              = 2

Function Main()
{
    $g_DebugFlag      = [System.Convert]::ToBoolean($DebugFlag)

	$IsNano = Is_NanoServer 
    $IsVolumeInfoSupported = Is_Win32_Volume_Supported $TargetComputer 
    $SystemDrive = Get_System_Drive $TargetComputer
  
    $bBagIsNotEmpty = $false

    $oVolumes =  Get-Volumes -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -TargetComputer $TargetComputer  
    
    foreach ($oVolume in $oVolumes)
    {
		$VolumeId = Get-VolumeId -IsNano $IsNano -IsVolumeSupported $IsVolumeInfoSupported -Volume $oVolume
		if ($true -eq $IsNano)
		{
			$nFreeSpace = $oVolume.SizeRemaining
			$nMaxSize   = $oVolume.Size
		}
		else
		   {
				$nFreeSpace = $oVolume.FreeSpace
			   if ($IsVolumeInfoSupported)
			   {
				   $nMaxSize = $oVolume.Capacity
			   }
				else
					{
						$nMaxSize   = $oVolume.Size
					}
           }

			Create-PerfData -VolumeId $VolumeId -nMaxSize $nMaxSize -nFreeSpace $nFreeSpace -SystemDrive $SystemDrive -momAPI $momAPI   
    }

	Unload-Module -ModuleName "Storage"
	Unload-Module -ModuleName "CimCmdLets"
}

Function Create-PerfData([string]$VolumeId,$nMaxSize,$nFreeSpace,[string]$SystemDrive,$momAPI)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $momAPI)
	{
		return
	}

	if ($nMaxSize -eq $null -or $nMaxSize -eq 0)
    {
		return
	}

    if ($nFreeSpace -eq $null) 
	{
		 $nFreeSpace = 0 
	}

    $nPctFree = [math]::Round($nFreeSpace / $nMaxSize * 100, 2)
    $nMBFree = [math]::Round($nFreeSpace / $BYTES_IN_MB, 0)
	
	$oBag = $momAPI.CreatePropertyBag()
	$oBag.AddValue("PctFree", [string]$nPctFree)
	$oBag.AddValue("MbFree", [string]$nMbFree)
	$oBag.AddValue("DiskLabel", $VolumeId)
    if ($VolumeId -ieq $SystemDrive)
    {
        $oBag.AddValue("IsSystem", "true")
    }
    else
    {
        $oBag.AddValue("IsSystem", "false")
    }

	if ($error.Count -eq 0)
	{
		$oBag
	}
} 

Main

</ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>TargetComputer</Name>
                    <Value>$Config/TargetComputerName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>DebugFlag</Name>
                    <Value>$Config/DebugFlag$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType" Accessibility="Public" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Frequency" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Frequency" Selector="$Config/Frequency$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval>$Config/Frequency$</Interval>
                    <SyncTime />
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PerfPA" TypeID="Microsoft.Windows.Server.10.0.PowerShellPerformanceProbe">
                <ScriptName>Microsoft.Windows.Server.CPUSocket.Performance.ps1</ScriptName>
                <PSparam />
                <ScriptBody>Function Main($objMomScriptAPI)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
 
	$PerfList = New-Object System.Collections.ArrayList($null)  
	Get-PhysicalCpuPerfData -PerfList $PerfList

    if($PerfList.Count -ne $null -and $PerfList.Count -ne 0)
	{
		Set-PerfDataFromList -PerfList $PerfList -objMomScriptAPI $objMomScriptAPI
	}
	else
	{
			Create-EmptyPerfData -objMomScriptAPI $objMomScriptAPI
	}

	Unload-Module -ModuleName "CimCmdLets"

}

Function Get-PhysicalCpuPerfData($PerfList)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	if($sTargetComputer -eq $null -or $sTargetComputer -eq "")
	{
	$sTargetComputer="."
	}
    $WMISet = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" "Win32_Processor"
	$LCpuCountersSet = WMIGetInstanceNoAbort $sTargetComputer "root\cimv2" "Win32_PerfFormattedData_PerfOS_Processor"
	$LCpuCountersSet =  Create-LCPUPerfData -LCpuCountersSet $LCpuCountersSet
	$LcpuNumber = [UInt32]0

	foreach ($owObj in $WMISet)
    {

 		$PerfInstance  =  $owObj.DeviceID.Substring(3)
		$NumberOfLCpu  =  $owObj.NumberOfLogicalProcessors
		Get-CpuPerfData -CpuId $PerfInstance -lCpuId $LcpuNumber -LcpuNumber $NumberOfLCpu -lCpuPerfData $LCpuCountersSet -PerfList $PerfList
		$LcpuNumber    += $NumberOfLCpu
	}

}

Function Create-LCPUPerfData($LCpuCountersSet)
{
  $ErrorActionPreference = "SilentlyContinue"
  
  $lCpuSet = @{}
  $CpuNumber = [Uint32]0

  $error.Clear()
  foreach ($lCpuData in $LCpuCountersSet)
  {
	  if (-Not [UInt32]::TryParse($lCpuData.Name,[ref]$CpuNumber))
	  {
		  continue
	  }

	  $PercentProcessorTime    = $lCpuData.PercentProcessorTime
	  $PercentDPCTime          = $lCpuData.PercentDPCTime
	  $PercentInterruptTime    = $lCpuData.PercentInterruptTime

	  if ($null -eq $PercentProcessorTime)
	  {
		  $PercentProcessorTime = [UInt64]0
	  }

	  if ($null -eq $PercentDPCTime)
	  {
		  $PercentDPCTime = [UInt64]0
	  }

	  if ($null -eq  $PercentInterruptTime)
	  {
		   $PercentInterruptTime = [UInt64]0
	  }



	  $CpuPdata = New-Object -TypeName psobject -Property @{
	  "PercentProcessorTime" = $lCpuData.PercentProcessorTime
	  "PercentDPCTime"       = $lCpuData.PercentDPCTime
	  "PercentInterruptTime" = $lCpuData.PercentInterruptTime
	    
	  }

	  $lCpuSet[$CpuNumber] =  $CpuPdata
	  
  }


 return $lCpuSet  
}


Function Get-CpuPerfData($CpuId,$lCpuId,$LcpuNumber,$lCpuPerfData,$PerfList)
{
  $ErrorActionPreference = "SilentlyContinue"
  $error.Clear()
	 
	$MaxCpuNumber        = $lCpuId + [Uint32]$LcpuNumber
	$DPCTime             = [UInt64]0
	$ProcessorTime       = [UInt64]0
	$ProcessorInterrupt  = [UInt64]0
	$i = [UInt32]0

	for ($i = $lCpuId; $i -lt $MaxCpuNumber; $i++)
	{
		$ProcessorTime      += $lCpuPerfData[$i].PercentProcessorTime
		$DPCTime            +=  $lCpuPerfData[$i].PercentDPCTime
		$ProcessorInterrupt +=  $lCpuPerfData[$i].PercentInterruptTime 
	}

	#DPCTime
	[void]$PerfList.Add((CreatePerformanceCounterData -strObjectName "Processor" -strCounterName "% DPC Time" -strInstanceName "$CpuId" -varValue ([math]::Round($DPCTime/$LcpuNumber,2)) ) )
	#Processor Time
	[void]$PerfList.Add((CreatePerformanceCounterData -strObjectName "Processor" -strCounterName "% Processor Time" -strInstanceName "$CpuId" -varValue ([math]::Round($ProcessorTime /$LcpuNumber,2)) ) )
	#Processor Interrupt Time
	[void]$PerfList.Add((CreatePerformanceCounterData -strObjectName "Processor" -strCounterName "% Interrupt Time" -strInstanceName "$CpuId" -varValue ([math]::Round($ProcessorInterrupt/$LcpuNumber,2)) ) )

}

Function Set-PerfDataFromList($PerfList,   $objMomScriptAPI)
{
	    if ($null -eq    $objMomScriptAPI)
	    {
		   return
 		}

		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$Error.Clear()
		foreach($data in $PerfList)
		{
				#Add the values for the perf counter#s object name, counter name, instance name and the value)
				if([string]::IsNullOrEmpty($data.PerfObject) )
				{
					continue
				}

			Create-PerformancePropertyBag -strObjectName $data.PerfObject -strCounterName $data.PerfCounter -strInstanceName $data.PerfInstance  -varValue $data.PerfValue -objMomScriptAPI $objMomScriptAPI
		}

}

Main -objMomScriptAPI $momAPI</ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection ID="CD" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <And>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">ObjectName</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/ObjectName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">CounterName</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/CounterName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="String">InstanceName</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="String">$Config/InstanceName$</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="CD">
                <Node ID="PerfPA">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.Windows.Server.10.0.TimeOffset.ModuleType" Accessibility="Internal">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NumSamples" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AllInstances" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <DataSource TypeID="SystemPerf!System.Performance.DataProvider" ID="DS1">
                <ComputerName>$Config/TargetComputerName$</ComputerName>
                <CounterName>$Config/CounterName$</CounterName>
                <ObjectName>$Config/ObjectName$</ObjectName>
                <InstanceName>$Config/InstanceName$</InstanceName>
                <AllInstances>$Config/AllInstances$</AllInstances>
                <Frequency>$Config/IntervalSeconds$</Frequency>
              </DataSource>
              <ConditionDetection TypeID="SystemPerf!System.Performance.AveragerCondition" ID="CDAverageThreshold">
                <NumSamples>$Config/NumSamples$</NumSamples>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="CDAverageThreshold">
                <Node ID="DS1" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
      </DataSourceModuleType>
      <ProbeActionModuleType ID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.ModuleType" Accessibility="Internal" Batching="false" PassThrough="false">
        <Configuration>
          <xsd:element minOccurs="1" name="IncludeCompliant" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IncludeCompliant" Selector="$Config/IncludeCompliant$" ParameterType="bool" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="PassThrough" TypeID="System!System.PassThroughProbe" />
              <ProbeAction ID="PA" TypeID="Microsoft.Windows.Server.10.0.BPA.PowerShellPropertyBagProbe">
                <ScriptName>Microsoft.Windows.Server.10.0.Monitoring.BPA.ShowBPAresults.Script.ps1</ScriptName>
                <PSparam>
Param($IncludeCompliant)
</PSparam>
                <ScriptBody>function WriteBPAResult
{
        param ([Microsoft.BestPractices.CoreInterface.Result]$BPAResult, [boolean]$IncludeAll)

        $Delimiter = New-Object String("-",12)
        if ($BPAResult.Problem -eq $null)
        {
            if ($IncludeAll)
            {
                Write-Host $(-Join("Title      : ", $BPAResult.Title))
                Write-Host $(-Join("Compliance : ", $BPAResult.Compliance))
        	    Write-Host $Delimiter
            }
        }
        else
        {
            Write-Host $(-Join("Title      : ", $BPAResult.Title))
            Write-Host $(-Join("Problem    : ", $BPAResult.Problem))
            Write-Host $(-Join("Impact     : ", $BPAResult.Impact))
            Write-Host $(-Join("Resolution : ", $BPAResult.Resolution))
    	    Write-Host $Delimiter
        }
 }
    
function WriteModelResults
    {
        param ([string]$BPAModel, [boolean]$IncludeAll)
        $ErrorActionPreference = "SilentlyContinue"
		$error.Clear()
        $BPAResults = Get-BPAResult -ModelId $BPAModel -ErrorAction SilentlyContinue

		if (0 -ne $error.Count -and $null -eq $BPAResults)
		{
			
			if ($BpaCategoryError -ieq $error[0].CategoryInfo.Category)
			{
				Write-Host $BpaScanNotRun 
				Write-Host $BpaScanMonitor
			}
			else 
			    {
					$msg = $error[0].Exception.Message
					$msg = $BpaErrorResults  -f $msg
					Write-Host $msg
				}

			return
		}


        if ($null -eq $BPAResults )
        {
				Write-Host $BpaEmptyResults 
			    return

		}

            $NotCompliantResults = $BPAResults | Where-Object {$_.Problem -ne $null}
            
            [boolean] $IsModelCompliant = [boolean]($NotCompliantResults -eq $null)
            
            if ($false -eq $IsModelCompliant -or $true -eq $IncludeAll)
            {
                Write-Host "Server Role: "  $BPAModel
                $RoleSeparator = New-Object String("=", [int] (14 + $BPAModel.Id.Length))
                Write-Host $RoleSeparator
            }
            
            foreach ($BPAResult in $BPAResults)
            {
               WriteBPAResult -BPAResult $BPAResult -IncludeAll $IncludeAll
            }
            
    }



Function Run-BPAResult()
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()

	$BpaModels          = New-Object System.Collections.ArrayList($null) 
	$ImportedAssemblies = New-Object System.Collections.ArrayList($null)
	
	if (0 -ne $error.Count)
	{
      Write-Host $BpaInitFailed 
	  return
	}

	$iResult = Check-BpaRequirement -ModelsToRun $BpaModels -ImportedAssemblies $ImportedAssemblies

	if ($BpaSuccess -ne $iResult)
	{
		if ($BpaModelLoadProblem -eq $iResult)
		{
            Unload-Modules -ImportedAssemblies $ImportedAssemblies
	    }

		return
	}

	$IncludeAll = Convert-ToBoolean -sBool $IncludeCompliant

	foreach ($BPAModel in $BPAModels)
	{
		WriteModelResults -BPAModel $BPAModel -IncludeAll $IncludeAll
	}

	Unload-Modules -ImportedAssemblies $ImportedAssemblies
}

Run-BPAResult</ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>IncludeCompliant</Name>
                    <Value>$Config/IncludeCompliant$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>300</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="PassThrough" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Windows!Microsoft.Windows.SerializedObjectData</OutputType>
        <TriggerOnly>true</TriggerOnly>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Microsoft.Windows.Server.10.0.Cmd.Probe" Accessibility="Public" Batching="false" PassThrough="false">
        <Configuration>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ApplicationName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CommandLine" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="Probe" TypeID="System!System.CommandExecuterProbe">
                <ApplicationName>$Config/ApplicationName$</ApplicationName>
                <WorkingDirectory />
                <CommandLine>$Config/CommandLine$</CommandLine>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <RequireOutput>true</RequireOutput>
                <Files />
              </ProbeAction>
              <ProbeAction ID="RegistryProbe" TypeID="Windows!Microsoft.Windows.RegistryProbe">
                <ComputerName>$Config/ComputerName$</ComputerName>
                <RegistryAttributeDefinitions>
                  <RegistryAttributeDefinition>
                    <AttributeName>SERVER_VERSION_IS_NANO</AttributeName>
                    <Path>SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels\NanoServer</Path>
                    <PathType>1</PathType>
                    <AttributeType>2</AttributeType>
                  </RegistryAttributeDefinition>
                </RegistryAttributeDefinitions>
              </ProbeAction>
              <ProbeAction ID="PassThrough" TypeID="System!System.PassThroughProbe" />
              <ConditionDetection ID="Filter" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <Not>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>Values/SERVER_VERSION_IS_NANO</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>1</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Not>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="Probe">
                <Node ID="Filter">
                  <Node ID="RegistryProbe">
                    <Node ID="PassThrough" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.CommandOutput</OutputType>
        <TriggerOnly>true</TriggerOnly>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Microsoft.Windows.Server.10.0.Cmd.Probe.Nano" Accessibility="Public" Batching="false" PassThrough="false">
        <Configuration>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ApplicationName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CommandLine" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="Probe" TypeID="System!System.CommandExecuterProbe">
                <ApplicationName>$Config/ApplicationName$</ApplicationName>
                <WorkingDirectory />
                <CommandLine>$Config/CommandLine$</CommandLine>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <RequireOutput>true</RequireOutput>
                <Files />
              </ProbeAction>
              <ProbeAction ID="RegistryProbe" TypeID="Windows!Microsoft.Windows.RegistryProbe">
                <ComputerName>$Config/ComputerName$</ComputerName>
                <RegistryAttributeDefinitions>
                  <RegistryAttributeDefinition>
                    <AttributeName>SERVER_VERSION_IS_NANO</AttributeName>
                    <Path>SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels\NanoServer</Path>
                    <PathType>1</PathType>
                    <AttributeType>2</AttributeType>
                  </RegistryAttributeDefinition>
                </RegistryAttributeDefinitions>
              </ProbeAction>
              <ProbeAction ID="PassThrough" TypeID="System!System.PassThroughProbe" />
              <ConditionDetection ID="Filter" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>Values/SERVER_VERSION_IS_NANO</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>1</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="Probe">
                <Node ID="Filter">
                  <Node ID="RegistryProbe">
                    <Node ID="PassThrough" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.CommandOutput</OutputType>
        <TriggerOnly>true</TriggerOnly>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe" Accessibility="Public" Batching="false">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>Windows!Microsoft.Windows.PowerShellSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ScriptName" type="NonNullString" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="PSparam" type="xsd:string" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptBody" type="NonNullString" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SnapIns" type="SnapInsType" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Parameters" type="NamedParametersType" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="StrictErrorHandling" type="xsd:boolean" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="PowerShellPA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagProbe">
                <ScriptName>$Config/ScriptName$</ScriptName>
                <ScriptBody>
                      
                                $Config/PSparam$
                                
$ErrorActionPreference = "Stop"

# Event type constants
$EVENT_TYPE_LOG = 0
$EVENT_TYPE_ERROR = 1
$EVENT_TYPE_WARNING = 2
$EVENT_TYPE_INFORMATION = 4

# Typed property bag constants
$PROPERTY_TYPE_ALERT = 0
$PROPERTY_TYPE_EVENT = 1
$PROPERTY_TYPE_PERFORMANCE = 2
$PROPERTY_TYPE_STATE = 3

# State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Error"

$momAPI = New-Object -ComObject Mom.ScriptAPI 
if ($null -eq $momAPI)
{
   exit -1
}

Function Load-CimModules
{
	$ErrorActionPreference = 'SilentlyContinue' 
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets

	}
}

Load-CimModules
# WMI Constant
$wbemCimtypeUseDefault        = 0   #Use Default Type CIM type - Custom
$wbemCimtypeSint16            = 2   #Signed 16-bit integer 
$wbemCimtypeSint32            = 3   #Signed 32-bit integer 
$wbemCimtypeReal32            = 4   #32-bit real number 
$wbemCimtypeReal64            = 5   #64-bit real number 
$wbemCimtypeString            = 8   #String 
$wbemCimtypeBoolean           = 11  #Boolean value 
$wbemCimtypeObject            = 13  #CIM object 
$wbemCimtypeSint8             = 16  #Signed 8-bit integer 
$wbemCimtypeUint8             = 17  #Unsigned 8-bit integer 
$wbemCimtypeUint16            = 18  #Unsigned 16-bit integer 
$wbemCimtypeUint32            = 19  #Unsigned 32-bit integer 
$wbemCimtypeSint64            = 20  #Signed 64-bit integer  
$wbemCimtypeUint64            = 21  #Unsigned 64-bit integer 
$wbemCimtypeDatetime          = 101 #Date/time value 
$wbemCimtypeReference         = 102 #Reference to a CIM object 
$wbemCimtypeChar16            = 103 #16-bit character 

$ErrAction_None               = 0
$ErrAction_Trace              = 1
$ErrAction_ThrowError         = 16
$ErrAction_Abort              = 32
$ErrAction_ThrowErrorAndAbort = 48

$DISKSIZE_BYTES_IN_MB = 1048576

$g_ErrorEventNumber = 4001
$g_TraceEventNumber = 4002
$g_DebugFlag = $false

#---------------------------------------------------------------------------
# Returns WMI Instance requested. Tries to execute WMI query a N times.
#---------------------------------------------------------------------------
Function WMIGetInstanceExTryN
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery, 
           [int]$N)

    for ($i = 0; $i -lt $N; $i++)
    {
        $error.Clear();
        
		Load-CimModules
		try
        {
		    $cimSessionOption = New-CimSessionOption -Protocol DCOM
		    $cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
            $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        catch
        {
             $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
        }
        Finally
        {
            Get-CimSession | Remove-CimSession
		    $cimsession =$null
		    $cimSessionOption = $null 
        }

        if ($error.Count -gt 0)
        {
            if ($i -eq ($N-1))
            {
                ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
            }
        }
        else
        {
            break;
        }
        sleep -m 1000
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceEx
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    $error.Clear();

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
            $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Connect to WMI.
#---------------------------------------------------------------------------
Function WMIConnect
{
    param ([string]$sTargetComputer,
           [string]$sNamespace)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
    
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg $error[0]
    }
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstance
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    WMIConnect $sTargetComputer $sNamespace
    $oInstance = WMIGetInstanceEx $sTargetComputer $sNamespace $sInstanceQuery
    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set.
#---------------------------------------------------------------------------
Function WMIExecQuery
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg, $error[0]
    }


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The Query '" + $sQuery + "' returned an invalid result set.  Please check to see if this is a valid WMI Query.") $error[0]
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set, no abort version.
#---------------------------------------------------------------------------
Function WMIExecQueryNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)    
    

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptErrorNoAbort
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    # Retrieve the name of this (running) script
    $ScriptFileName = $MyInvocation.ScriptName
    
    if ($oErr -ne $null)
    {
        $sMessage = $sMessage + ". " + $oErr.ErrorDetails
    }
    
    $momAPI.LogScriptEvent($ScriptFileName, $g_ErrorEventNumber, $EVENT_TYPE_ERROR, $sMessage)
    
    Write-Host $sMessage
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptError
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    ThrowScriptErrorNoAbort $sMessage $oErr
    exit
}

#---------------------------------------------------------------------------
# Verifies that number of arguments is correct
#---------------------------------------------------------------------------
Function VerifyNumberOfArguments
{
    param ($NumberOfArguments)

    if ($args.Length -ne $NumberOfArguments)
    {
       $sArgs = ""
       foreach ($argument in $args)
       {
           $sArgs += " {" + $argument + "}"
       }
       ThrowScriptError ("Invalid number of arguments (" + $args.Length + " instead of " + $NumberOfArguments + "). Arguments:" + $sArgs) $null
    }
}

#---------------------------------------------------------------------------
# Outputs to file and echo for debugging purposes
#---------------------------------------------------------------------------
Function TraceLogMessage
{
    param ([string]$sMessage)

    Write-Host $sMessage
    
    If ($g_DebugFlag -eq $true)
    {
        # Retrieve the name of this (running) script
        $ScriptFileName = $MyInvocation.ScriptName
        
        $momAPI.LogScriptEvent($ScriptFileName, $g_TraceEventNumber, $EVENT_TYPE_INFORMATION, $sMessage)
    }
}

#---------------------------------------------------------------------------
# Verifies the expression. If equals to False then generates an error and quits the script
#   Usage:
#     Verify Not WMISet Is Nothing, "WMISet is invalid!"
#     Verify WMISet.Count = 1, "Invalid quantity of services with name 'Server' (qty = " &amp; WMISet.Count &amp; ")."
#---------------------------------------------------------------------------
Function Verify
{
    param ([bool]$bBool, 
           [string]$sMessage)

    If ($bBool -eq $false)
    {
        ThrowScriptError $sMessage $null
    }
}

Function GetRegistryKeyValue
{
    param ([string]$keyPath, 
           [string]$key)

    $error.Clear()

    $strKeyValue = Get-ItemProperty -Path $keyPath -Name $key -ErrorAction SilentlyContinue
    if ($error.Count -gt 0)
    {
        ThrowScriptError ("An error occurred while reading the registry: '" + $keyPath + $key + "'") $error[0]
    }
    return $strKeyValue.$key
}


#---------------------------------------------------------------------------
# Function: ExpressedInMB
#   Usage:
#     Parameter (SizeInBytes) 
#     Returns the Size Expressed in MBytes
#---------------------------------------------------------------------------
Function ExpressedInMB
{
    param ($SizeInBytes)

    $NumberSizeExpInMB = [math]::Round($SizeInBytes / $DISKSIZE_BYTES_IN_MB, 0)
    return $NumberSizeExpInMB
}

Function Is_Win32_Volume_Supported($TargetComputer)
{
    $blnRet = $false
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = Is_NanoServer
	
	if ($true -eq $IsNano)
	{
		return $blnRet #NanoServer does not support Win32_Volume
	}

    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        if ([int]$objWMIOS.BuildNumber -ge 3624) 
		{
			 $blnRet = $true 
		}
    }

    return $blnRet
}

Function Get_System_Drive($TargetComputer)
{
    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        return $objWMIOS.SystemDirectory.SubString(0,2)
    }
}

Function Is_NanoServer
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels").GetValue("NanoServer")
	
	$IsNano = $IsNano -eq 1

	$error.Clear()

	return $IsNano

}

#---------------------------------------------------------------------------
# Function: StripEndChar
#   Usage:
#     Parameter (sName) 
#     Returns the sName without last special Character "\"
#---------------------------------------------------------------------------
Function StripEndChar([string]$sName)
{
    if ([string]::IsNullOrEmpty($sName))
    { 
        return [string]::Empty
    }
    else
    {
        return $sName.Substring(0, $sName.Length-1)
    }
}

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Get-Volumes([bool]$IsNano,[bool]$IsVolumeSupported,[string] $TargetComputer)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$oVolumes = $null

	if ($true -eq $IsNano)
	{
		$bLoadModule = Load-Module -ModuleName "Storage"
		if($false -eq $bLoadModule)
        {
			return $null
		} 

		$oVolumes =  Get-Volume | where {$_.DriveType -eq "Fixed" -and $false -eq [string]::IsNullOrEmpty($_.FileSystem )}
	}
	else 
		{
			if ($true -eq $IsVolumeSupported)
			{
				 $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_Volume where (DriveType=3) and FileSystem!=null" 
			}
			else
			   {
				   $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_LogicalDisk where (DriveType=3) and FileSystem!=null"  
			   }
		}

	return $oVolumes
} 

Function Get-VolumeId([bool]$IsNano,[bool]$IsVolumeSupported,$Volume)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $Volume)
	{
		return $null
	}

	if ($true -eq $IsVolumeSupported)
	{
		$VolumeId = $Volume.DriveLetter
		if([string]::IsNullOrEmpty($VolumeId) )
		{
			$VolumeId = StripEndChar -sName $Volume.Name 
		}
	}
	else
	    {
			if ($true -eq $IsNano )
			{
				$VolumeId = $Volume.DriveLetter
				if([string]::IsNullOrEmpty($VolumeId) )
				{
					$VolumeId = StripEndChar -sName $Volume.UniqueId 
				}
				else
				{
					if (1 -eq $VolumeId.Length)
					{
						$VolumeId = $VolumeId + ":" 
					}
				}
			}
			else
			    {
					$VolumeId = $Volume.DeviceId
				}
			
		}

	return $VolumeId
} 

Function CreatePerformanceCounterData($strObjectName, $strCounterName, $strInstanceName, $varValue)
{

									return @{ "PerfObject"  = $strObjectName;
                                             "PerfCounter"  = $strCounterName;
                                             "PerfInstance" = $strInstanceName;
                                             "PerfValue"     =  $varValue;
                                             }
}

Function Create-PerformancePropertyBag ($strObjectName, $strCounterName, $strInstanceName, $varValue,$objMomScriptAPI)
{
				$ErrorActionPreference = "SilentlyContinue"
				$error.Clear()

				if ([string]::IsNullOrEmpty($varValue))
	            {
					$varValue = 0
				}	

	            if ($null -eq $objMomScriptAPI)
				{
					return
				}

				$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

				$objTypedPropertyBag.AddValue("PerfObject"   ,$strObjectName)
				$objTypedPropertyBag.AddValue("PerfCounter"  ,$strCounterName)
				$objTypedPropertyBag.AddValue("PerfInstance" ,$strInstanceName)
				$objTypedPropertyBag.AddValue("PerfValue"    ,$varValue)
				$objTypedPropertyBag

     
}

Function Create-EmptyPerfData ($objMomScriptAPI)
{
	 if ($null -eq $objMomScriptAPI)
  	 {
		return
 
	 }

		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()
		$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

		$objTypedPropertyBag.AddValue("PerfObject"   ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfCounter"  ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfInstance" ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfValue"    ,"EMPTY")

		#Add the property bag to the script#s XML output
		$objTypedPropertyBag
	   
	   $error.Clear()
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

 Function Unload-Module([string]$ModuleName)
 {
		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()

	    if ([string]::IsNullOrEmpty($ModuleName))
		{
			return
		}

	    $module = Get-Module $ModuleName  
	    if ($null -eq $module)
		{
		   return
		}

		Remove-Module -Name $ModuleName -Force 
 }

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
                                $Config/ScriptBody$
                               
                    </ScriptBody>
                <SnapIns>$Config/SnapIns$</SnapIns>
                <Parameters>$Config/Parameters$</Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <StrictErrorHandling>$Config/StrictErrorHandling$</StrictErrorHandling>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PowerShellPA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Microsoft.Windows.Server.10.0.BPA.PowerShellPropertyBagProbe" Accessibility="Public" Batching="false">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>Windows!Microsoft.Windows.PowerShellSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ScriptName" type="NonNullString" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="PSparam" type="xsd:string" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptBody" type="NonNullString" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SnapIns" type="SnapInsType" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Parameters" type="NamedParametersType" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="StrictErrorHandling" type="xsd:boolean" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="PowerShellPA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagProbe">
                <ScriptName>$Config/ScriptName$</ScriptName>
                <ScriptBody>
                      
                                $Config/PSparam$
                                # State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Analysis"

$WarningRulesCount     = 0
$ErrorRulesCount       = 0

$BpaNotSupportedStatus = 1
$BpaNotLoadedStatus    = 2
$BpaModelsNotLoaded    = 3
$BpaSuccess            = 0
$SrvModule             = "ServerManager"
$BpaModule             = "BestPractices"
$BpaInitFailed         = "BPA Task Initialization failed." 
$BpaNotSupported       = "There are no Best Practices Analyzer modules found. Scan result is not supported on this Operating System." 
$BpaLoadProblem        = "Can not load BPA Scan Module"
$BpaModelLoadProblem   = "Can not get BPA Models"
$Description           = "There are no Best Practices Analyzer modules found."
$DESCRIPTION_NOMODULES = "There are no Best Practices Analyzer modules found."
$DESCRIPTION_WARNING   = "Best Practices Analyzer compliance verification was completed successfully with {0} warnings and {1} errors."
$DESCRIPTION_ERROR     = "Best Practices Analyzer can not complete compliance verification."
$BpaResultLoadFailed   = "Best Practices Analyzer can not get result"
$BpaCategoryError      = "ResourceUnavailable"
$BpaScanNotRun         = "BPA scan was not run or was not completed successfuly."
$BpaScanMonitor        = "Enable Windows Server 2016 Operating System BPA Monitor"
$BpaEmptyResults       = "BPA scan does not return any result."
$BpaErrorResults       = "Can not get Best Practices Analyzer compliance result. Command was completed with errors. Error: {0} ."
$BpaScanMode           = "Analysis"

Function Get-BpaWarningsAndErrorCounts($Detail,[ref]$WarningRulesCount,[ref]$ErrorRulesCount)
{
	if([string]::IsNullOrEmpty($Detail))
	{
		return
	}

	$WarningCount = 0
	$ErrorCount  = 0



	foreach($scanDetail in $Detail)
	{
		if ($BpaScanMode -eq $scanDetail.ScanMode)
		{
			$tWarninCount = 0
			$tErrorCount  = 0

		  	Get-BpaCountFromDetail -Detail $scanDetail -WarningMessages ([ref] $tWarninCount) -ErrorMessages ([ref] $tErrorCount)
			$WarningCount += $tWarninCount
			$ErrorCount   += $tErrorCount
		}
		else
		    {
				continue
			}
	}

	$WarningRulesCount.Value = $WarningCount
	$ErrorRulesCount.Value   = $ErrorCount
}


Function Get-BpaCountFromDetail($Detail,[ref]$WarningMessages,[ref]$ErrorMessages)
{
	if([string]::IsNullOrEmpty($Detail))
	{
		return $null
	}

   if([Microsoft.BestPractices.CoreInterface.InvokeBpaModelOutputDetail] -ne $Detail.GetType())
   {
	   retrun $null
   }

	$WarnCount  = 0
	$ErrorCount = 0
	[int]::TryParse($Detail.WarningMessages,[ref]$WarnCount)
	[int]::TryParse($Detail.ErrorMessages,[ref]$WarnCount)

	$WarningMessages.Value = $WarnCount
	$ErrorMessages.Value   = $ErrorCount

	return 0
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Check-Module([string] $ModuleName)
{

	$IsExist = $false
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $IsExist
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$module = Get-Module -ListAvailable -Name $ModuleName
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $IsExist
	   }

       $error.Clear()
	}

	$IsExist = $module -ne $null

	return $IsExist
}

Function Check-BpaRequirement($ModelsToRun,$ImportedAssemblies) 
{
    $IsSrvManager       = Check-Module -ModuleName $SrvModule
	$IsBpaModule        = Check-Module -ModuleName $BpaModule
	$IsSrvManagerLoaded = $false
	$IsBpaModuleLoaded  = $false

	if ($false -eq $IsBpaModule)
	{
		Write-Host $BpaNotSupported 
		return $BpaNotSupportedStatus
	}

	 SafeImportModule -ModuleName $BpaModule -LoadedAssemblies $ImportedAssemblies
	if ( 0 -eq $ImportedAssemblies.Count)
	{
		Write-Host $BpaLoadProblem
		return $BpaNotLoadedStatus
	}

 	if ($true -eq $IsSrvManager)
	{
		$IsSrvManagerLoaded = Load-Module -ModuleName $SrvModule
		if($true -eq $IsSrvManagerLoaded)
		{
			Get-InstalledFeatures -ModelsToRun $ModelsToRun
			
		}
		else
		    {
				$IsModelsLoaded = Get-BpaModels -ModelsToRun $ModelsToRun
				if($false -eq $IsModelsLoaded)
				{
					return $BpaModelsNotLoaded
				}
			}
	}
	else
	    {
				$IsModelsLoaded = Get-BpaModels -ModelsToRun $ModelsToRun
				if($false -eq $IsModelsLoaded)
				{
					return $BpaModelsNotLoaded
				}
		}

	return $BpaSuccess
}

Function Get-BpaModels($ModelsToRun)
{
					$ErrorActionPreference="SilentlyContinue"
					$error.Clear()

	                if($null -eq $ModelsToRun)
					{
						return
					} 

				    $BpaModels = Get-BpaModel
				    if (0 -ne $error.Count)
				    {
						Write-Host $BpaModelLoadProblem
						return $false
					} 
				   
				    foreach($BpaModel in $BpaModels)
					{
						if ([string]::IsNullOrEmpty($BpaModel.Id) )
						{
							continue
						}

						[void]$ModelsToRun.Add($BpaModel.Id) 
					}   
				   
				    return $true
}



Function Get-InstalledFeatures($ModelsToRun)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if($null -eq $ModelsToRun)
	{
		return
	}

  $WinFeatureToBPAmodel = @{
   "ADRMS"                   = "Microsoft/Windows/ADRMS";
   "Application-Server"      = "Microsoft/Windows/ApplicationServer";
   "AD-Certificate"          = "Microsoft/Windows/CertificateServices";
   "DHCP"                    = "Microsoft/Windows/DHCPServer";
   "AD-Domain-Services"      = "Microsoft/Windows/ADRMS";
   "DNS"                     = "Microsoft/Windows/DNSServer";
   "File-Services"           = "Microsoft/Windows/FileServices";
   "Hyper-V"                 = "Microsoft/Windows/Hyper-V";
   "ADLDS"                   = "Microsoft/Windows/LightweightDirectoryServices" ;
   "NPAS"                    = "Microsoft/Windows/NPAS";
   "Remote-Desktop-Services" = "Microsoft/Windows/TerminalServices";
   "Web-Server"              = "Microsoft/Windows/WebServer";
   "UpdateServices"          = "Microsoft/Windows/UpdateServices";
   "VolumeActivation"        = "Microsoft/Windows/VolumeActivation";
   "Failover-Clustering"     = "Microsoft/Windows/ClusterAwareUpdating";
   "RemoteAccess"            = "Microsoft/Windows/RemoteAccessServer";
   "MSMQ"                    = "Microsoft/Windows/MSMQ";
   "OOB-WSUS"                = "Microsoft/Windows/WSUS";

  }


	foreach ($feature in $WinFeatureToBPAmodel.Keys)
	{
		if ($true -eq (Get-WindowsFeature $feature).Installed)
		{
			$BpaModel = $WinFeatureToBPAmodel[$feature]
			if($false -eq [string]::IsNullOrEmpty($BpaModel) )
			{
				if ($feature -ieq "Failover-Clustering")
				{
					$ClusterName = (Get-ItemProperty -Path "HKLM:\Cluster" -Name "ClusterName").ClusterName
					if ([string]::IsNullOrEmpty($ClusterName))
					{
						continue
					}
				}

				[void]$ModelsToRun.Add($BpaModel)
			}
		}
	}

	$error.Clear()

}

function CreateStatePropertyBag
{
  param ($StateProperty = $StateProperty, $Message = $Message,$momAPI)

  if($null -eq $momAPI)
  {
	  return
  } 

  $SCRIPT_NAME = $MyInvocation.ScriptName
  if ($StateProperty -ne $STATE_SUCCESS -and $StateProperty -ne $STATE_WARNING -and $StateProperty -ne $STATE_ERROR)
  {
    Write-Warning "$SCRIPT_NAME - State property is not properly defined: $StateProperty"
    return
  }

  $ErrorActionPreference="SilentlyContinue"
  $error.Clear()
  $StatePropertyBag = $momAPI.CreateTypedPropertyBag($PROPERTY_TYPE_STATE)

  if ($StatePropertyBag -eq $null)
  {
    Write-Warning "$SCRIPT_NAME - Unable to create state property bag"
    return
  }

  $StatePropertyBag.AddValue('State', $StateProperty)
  Write-Verbose "$SCRIPT_NAME - added state property bag value for state $StateProperty"

  if ($Message -ne $null)
  {
    $StatePropertyBag.AddValue('Message', $Message)
    Write-Verbose "$SCRIPT_NAME - added state property bag value for message $Message"
  }

  # Submitting state property bag
  $StatePropertyBag

  #Write-Host "$SCRIPT_NAME - state property bag returned"
}

Function Get-BpaResults
{
        param ([string]$BPAModel,[ref]$WarnCount,[ref]$ErrorCount)
        $ErrorActionPreference = "SilentlyContinue"
		$error.Clear()

        $BPAResults = (Get-BPAResult -ModelId $BPAModel ) | Where-Object {$_.Severity -eq "Warning" -or $_.Severity -eq "Error"}

        $WarnCount.Value  = 0
	    $ErrorCount.Value = 0
	    $wCount = 0
	    $eCount = 0 
	     
		if (0 -ne $error.Count -and $null -eq $BPAResults)
		{
			
			return
		}

	    $Warnings = $BPAResults | Where-Object {$_.Severity -eq "Warning"}
	    $Errors   = $BPAResults | Where-Object {$_.Severity -eq "Errors"}

        if ($null -ne  $Warnings )
        {
			$wCount =  $Warnings.Count
			$WarnCount.Value = $wCount
		}

        if ($null -ne  $Errors )
        {
			$eCount =  $Errors.Count
			$ErrorCount.Value = $eCount
		}
            
}

Function Get-AllBpaResults 
{
        param ($BPAModels,[ref]$WarnCount,[ref]$ErrorCount)

        $ErrorActionPreference = "SilentlyContinue"
		$error.Clear()

	    $Warn  = 0 
		$Err   = 0
	    $Warns = 0
	    $Errors = 0    
        foreach($BPAModel in $BPAModels)
		{
		  Get-BpaResults -BPAModel $BPAModel -WarnCount ([ref]$Warn) -ErrorCount ([ref]$Err)
          $Warns  = $Warns + $Warn
          $Errors = $Errrors + $Err
		}
	    
	   $WarnCount.Value   = $Warns
	   $ErrorCount.Value  = $Errors
}
function SafeImportModule()
{
  param ($ModuleName = $ModuleName,$LoadedAssemblies)

  $LOCAL_SYSTEM_SRC = "SafetyImportModule"
  $LOCAL_SYSTEM_ID = 104
  $NestedModulesMarker = "NestedModules*"
  $AssemblyMarker = "dll"
  $ErrorActionPreference = "SilentlyContinue"
  $error.Clear()

  $SCRIPT_NAME = $MyInvocation.ScriptName


  if ($null -eq $LoadedAssemblies -or [string]::IsNullOrEmpty($ModuleName) )
  {
	  return 
  }

  $Module = Get-Module -ListAvailable -Name $ModuleName
  if ($null -eq $Module )
  {
	  return 
  }

  $NestedModulesString = cat $Module.Path | Where-object {$_ -like $NestedModulesMarker}
 
	if ([string]::IsNullOrEmpty($NestedModulesString))
	{
	  return 
	}

     $AssemblyCollection = $NestedModulesString.Split((",","'"),[System.StringSplitOptions]::RemoveEmptyEntries) | Where-Object {$_.Contains($AssemblyMarker)}

     foreach ($AssemblyName in $AssemblyCollection) 
     {
       $AssemblyFullPath = Join-Path $Module.ModuleBase $AssemblyName
       try
       { 
         $Assembly = [System.Reflection.Assembly]::LoadFile($AssemblyFullPath)
         Import-Module -Assembly $Assembly
         [void]$LoadedAssemblies.Add($Assembly.Location)
       }
       catch [System.IO.FileLoadException]
       {
          $momAPI.LogScriptEvent($LOCAL_SYSTEM_SRC, $LOCAL_SYSTEM_ID, $EVENT_TYPE_ERROR, $SCRIPT_NAME + "Could not load {0}" -f $AssemblyFullPath)
		  $LoadedAssemblies.Clear()
		  break
       }
       catch [System.IO.FileNotFoundException]
       {
          $momAPI.LogScriptEvent($LOCAL_SYSTEM_SRC, $LOCAL_SYSTEM_ID, $EVENT_TYPE_ERROR, $SCRIPT_NAME + "File {0} Not Found" -f $AssemblyFullPath)
		  $LoadedAssemblies.Clear()
		  break
       }

     }
  
}

function RemoveImportedAssembly
{
  param ($AssemblyName = $AssemblyName)
  $Modules = Get-Module
  foreach($Module in $Modules)
  {
    if ($Module.Path -ieq $AssemblyName)
      {
        Remove-Module $Module 
      }
  }
}

Function Unload-Modules($ImportedAssemblies)
{
 	foreach ($ImportedAssembly in $ImportedAssemblies)
	{
		RemoveImportedAssembly($ImportedAssembly)
	}
}

                                $Config/ScriptBody$
                               
                    </ScriptBody>
                <SnapIns>$Config/SnapIns$</SnapIns>
                <Parameters>$Config/Parameters$</Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <StrictErrorHandling>$Config/StrictErrorHandling$</StrictErrorHandling>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PowerShellPA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </ProbeActionModuleType>
      <ProbeActionModuleType ID="Microsoft.Windows.Server.10.0.PowerShellPerformanceProbe" Accessibility="Public" Batching="false">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>Windows!Microsoft.Windows.PowerShellSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ScriptName" type="NonNullString" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="PSparam" type="xsd:string" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptBody" type="NonNullString" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SnapIns" type="SnapInsType" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Parameters" type="NamedParametersType" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="StrictErrorHandling" type="xsd:boolean" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction ID="PowerShellPA" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
                <ScriptName>$Config/ScriptName$</ScriptName>
                <PSparam>$Config/PSparam$</PSparam>
                <ScriptBody>$Config/ScriptBody$</ScriptBody>
                <SnapIns>$Config/SnapIns$</SnapIns>
                <Parameters>$Config/Parameters$</Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <StrictErrorHandling>$Config/StrictErrorHandling$</StrictErrorHandling>
              </ProbeAction>
              <ConditionDetection ID="PerfMapper" TypeID="SystemPerf!System.Performance.DataGenericMapper">
                <ObjectName>$Data/Property[@Name='PerfObject']$</ObjectName>
                <CounterName>$Data/Property[@Name='PerfCounter']$</CounterName>
                <InstanceName>$Data/Property[@Name='PerfInstance']$</InstanceName>
                <Value>$Data/Property[@Name='PerfValue']$</Value>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="PerfMapper">
                <Node ID="PowerShellPA" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
        <InputType>System!System.BaseData</InputType>
      </ProbeActionModuleType>
      <ConditionDetectionModuleType ID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ConditionDetection.ModuleType" Accessibility="Internal" Batching="false" Stateful="true" PassThrough="false">
        <Configuration>
          <xsd:element minOccurs="1" name="Tolerance" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ToleranceType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:enumeration value="Absolute" />
                <xsd:enumeration value="Percentage" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element minOccurs="1" name="MaximumSampleSeparation" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="ReturnedObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="MonitoringObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Frequency" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ConditionDetection ID="TargetExpression" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>$Config/ReturnedObjectName$</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>$Config/MonitoringObjectName$</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </ConditionDetection>
              <ConditionDetection ID="OptimizedFilter" TypeID="SystemPerf!System.Performance.OptimizedCollectionFilter">
                <Tolerance>$Config/Tolerance$</Tolerance>
                <ToleranceType>$Config/ToleranceType$</ToleranceType>
                <MaximumSampleSeparation>$Config/MaximumSampleSeparation$</MaximumSampleSeparation>
                <SamplingPeriodInSeconds>$Config/Frequency$</SamplingPeriodInSeconds>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="OptimizedFilter">
                <Node ID="TargetExpression" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>SystemPerf!System.Performance.Data</OutputType>
        <InputTypes>
          <InputType>SystemPerf!System.Performance.Data</InputType>
        </InputTypes>
      </ConditionDetectionModuleType>
      <WriteActionModuleType ID="Microsoft.Windows.PSScriptWriteAction" Accessibility="Public">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.ParamListSchema</SchemaType>
            <SchemaType>System!System.CommandExecuterSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ScriptName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Arguments" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptBody" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SecureInput" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
                <xsd:maxLength value="256" />
              </xsd:restriction>
            </xsd:simpleType>
          </xsd:element>
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" maxOccurs="1" name="EventPolicy" type="CommandExecuterEventPolicyType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Arguments" Selector="$Config/Arguments$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <WriteAction TypeID="System!System.CommandExecuter" ID="WA1">
                <ApplicationName>%WINDIR%\system32\WindowsPowerShell\v1.0\powershell.exe</ApplicationName>
                <WorkingDirectory />
                <CommandLine>-nologo -command "&amp; '$File/$Config/ScriptName$$'" $Config/Arguments$</CommandLine>
                <SecureInput>$Config/SecureInput$</SecureInput>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
                <RequireOutput>true</RequireOutput>
                <Files>
                  <File>
                    <Name>$Config/ScriptName$</Name>
                    <Contents>$Config/ScriptBody$</Contents>
                    <Unicode>true</Unicode>
                  </File>
                </Files>
                <DefaultEventPolicy>
                  <StdOutMatches />
                  <StdErrMatches>\a+</StdErrMatches>
                  <ExitCodeMatches>[^0]+</ExitCodeMatches>
                </DefaultEventPolicy>
                <EventPolicy>$Config/EventPolicy$</EventPolicy>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="WA1" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.CommandOutput</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.WA.ModuleType" Accessibility="Internal">
        <Configuration>
          <xsd:element minOccurs="1" name="IncludeCompliant" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IncludeCompliant" Selector="$Config/IncludeCompliant$" ParameterType="bool" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="WA" TypeID="Microsoft.Windows.PSScriptWriteAction">
                <ScriptName>Microsoft.Windows.Server.10.0.Monitoring.BPA.ShowBPAresults.Script.ps1</ScriptName>
                <Arguments>"-IncludeCompliant '$Config/IncludeCompliant$'"</Arguments>
                <ScriptBody>
Param($IncludeCompliant)
# State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Analysis"

$WarningRulesCount     = 0
$ErrorRulesCount       = 0

$BpaNotSupportedStatus = 1
$BpaNotLoadedStatus    = 2
$BpaModelsNotLoaded    = 3
$BpaSuccess            = 0
$SrvModule             = "ServerManager"
$BpaModule             = "BestPractices"
$BpaInitFailed         = "BPA Task Initialization failed." 
$BpaNotSupported       = "There are no Best Practices Analyzer modules found. Scan result is not supported on this Operating System." 
$BpaLoadProblem        = "Can not load BPA Scan Module"
$BpaModelLoadProblem   = "Can not get BPA Models"
$Description           = "There are no Best Practices Analyzer modules found."
$DESCRIPTION_NOMODULES = "There are no Best Practices Analyzer modules found."
$DESCRIPTION_WARNING   = "Best Practices Analyzer compliance verification was completed successfully with {0} warnings and {1} errors."
$DESCRIPTION_ERROR     = "Best Practices Analyzer can not complete compliance verification."
$BpaResultLoadFailed   = "Best Practices Analyzer can not get result"
$BpaCategoryError      = "ResourceUnavailable"
$BpaScanNotRun         = "BPA scan was not run or was not completed successfuly."
$BpaScanMonitor        = "Enable Windows Server 2016 Operating System BPA Monitor"
$BpaEmptyResults       = "BPA scan does not return any result."
$BpaErrorResults       = "Can not get Best Practices Analyzer compliance result. Command was completed with errors. Error: {0} ."
$BpaScanMode           = "Analysis"

Function Get-BpaWarningsAndErrorCounts($Detail,[ref]$WarningRulesCount,[ref]$ErrorRulesCount)
{
	if([string]::IsNullOrEmpty($Detail))
	{
		return
	}

	$WarningCount = 0
	$ErrorCount  = 0



	foreach($scanDetail in $Detail)
	{
		if ($BpaScanMode -eq $scanDetail.ScanMode)
		{
			$tWarninCount = 0
			$tErrorCount  = 0

		  	Get-BpaCountFromDetail -Detail $scanDetail -WarningMessages ([ref] $tWarninCount) -ErrorMessages ([ref] $tErrorCount)
			$WarningCount += $tWarninCount
			$ErrorCount   += $tErrorCount
		}
		else
		    {
				continue
			}
	}

	$WarningRulesCount.Value = $WarningCount
	$ErrorRulesCount.Value   = $ErrorCount
}


Function Get-BpaCountFromDetail($Detail,[ref]$WarningMessages,[ref]$ErrorMessages)
{
	if([string]::IsNullOrEmpty($Detail))
	{
		return $null
	}

   if([Microsoft.BestPractices.CoreInterface.InvokeBpaModelOutputDetail] -ne $Detail.GetType())
   {
	   retrun $null
   }

	$WarnCount  = 0
	$ErrorCount = 0
	[int]::TryParse($Detail.WarningMessages,[ref]$WarnCount)
	[int]::TryParse($Detail.ErrorMessages,[ref]$WarnCount)

	$WarningMessages.Value = $WarnCount
	$ErrorMessages.Value   = $ErrorCount

	return 0
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Check-Module([string] $ModuleName)
{

	$IsExist = $false
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $IsExist
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$module = Get-Module -ListAvailable -Name $ModuleName
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $IsExist
	   }

       $error.Clear()
	}

	$IsExist = $module -ne $null

	return $IsExist
}

Function Check-BpaRequirement($ModelsToRun,$ImportedAssemblies) 
{
    $IsSrvManager       = Check-Module -ModuleName $SrvModule
	$IsBpaModule        = Check-Module -ModuleName $BpaModule
	$IsSrvManagerLoaded = $false
	$IsBpaModuleLoaded  = $false

	if ($false -eq $IsBpaModule)
	{
		Write-Host $BpaNotSupported 
		return $BpaNotSupportedStatus
	}

	 SafeImportModule -ModuleName $BpaModule -LoadedAssemblies $ImportedAssemblies
	if ( 0 -eq $ImportedAssemblies.Count)
	{
		Write-Host $BpaLoadProblem
		return $BpaNotLoadedStatus
	}

 	if ($true -eq $IsSrvManager)
	{
		$IsSrvManagerLoaded = Load-Module -ModuleName $SrvModule
		if($true -eq $IsSrvManagerLoaded)
		{
			Get-InstalledFeatures -ModelsToRun $ModelsToRun
			
		}
		else
		    {
				$IsModelsLoaded = Get-BpaModels -ModelsToRun $ModelsToRun
				if($false -eq $IsModelsLoaded)
				{
					return $BpaModelsNotLoaded
				}
			}
	}
	else
	    {
				$IsModelsLoaded = Get-BpaModels -ModelsToRun $ModelsToRun
				if($false -eq $IsModelsLoaded)
				{
					return $BpaModelsNotLoaded
				}
		}

	return $BpaSuccess
}

Function Get-BpaModels($ModelsToRun)
{
					$ErrorActionPreference="SilentlyContinue"
					$error.Clear()

	                if($null -eq $ModelsToRun)
					{
						return
					} 

				    $BpaModels = Get-BpaModel
				    if (0 -ne $error.Count)
				    {
						Write-Host $BpaModelLoadProblem
						return $false
					} 
				   
				    foreach($BpaModel in $BpaModels)
					{
						if ([string]::IsNullOrEmpty($BpaModel.Id) )
						{
							continue
						}

						[void]$ModelsToRun.Add($BpaModel.Id) 
					}   
				   
				    return $true
}



Function Get-InstalledFeatures($ModelsToRun)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if($null -eq $ModelsToRun)
	{
		return
	}

  $WinFeatureToBPAmodel = @{
   "ADRMS"                   = "Microsoft/Windows/ADRMS";
   "Application-Server"      = "Microsoft/Windows/ApplicationServer";
   "AD-Certificate"          = "Microsoft/Windows/CertificateServices";
   "DHCP"                    = "Microsoft/Windows/DHCPServer";
   "AD-Domain-Services"      = "Microsoft/Windows/ADRMS";
   "DNS"                     = "Microsoft/Windows/DNSServer";
   "File-Services"           = "Microsoft/Windows/FileServices";
   "Hyper-V"                 = "Microsoft/Windows/Hyper-V";
   "ADLDS"                   = "Microsoft/Windows/LightweightDirectoryServices" ;
   "NPAS"                    = "Microsoft/Windows/NPAS";
   "Remote-Desktop-Services" = "Microsoft/Windows/TerminalServices";
   "Web-Server"              = "Microsoft/Windows/WebServer";
   "UpdateServices"          = "Microsoft/Windows/UpdateServices";
   "VolumeActivation"        = "Microsoft/Windows/VolumeActivation";
   "Failover-Clustering"     = "Microsoft/Windows/ClusterAwareUpdating";
   "RemoteAccess"            = "Microsoft/Windows/RemoteAccessServer";
   "MSMQ"                    = "Microsoft/Windows/MSMQ";
   "OOB-WSUS"                = "Microsoft/Windows/WSUS";

  }


	foreach ($feature in $WinFeatureToBPAmodel.Keys)
	{
		if ($true -eq (Get-WindowsFeature $feature).Installed)
		{
			$BpaModel = $WinFeatureToBPAmodel[$feature]
			if($false -eq [string]::IsNullOrEmpty($BpaModel) )
			{
				if ($feature -ieq "Failover-Clustering")
				{
					$ClusterName = (Get-ItemProperty -Path "HKLM:\Cluster" -Name "ClusterName").ClusterName
					if ([string]::IsNullOrEmpty($ClusterName))
					{
						continue
					}
				}

				[void]$ModelsToRun.Add($BpaModel)
			}
		}
	}

	$error.Clear()

}

function CreateStatePropertyBag
{
  param ($StateProperty = $StateProperty, $Message = $Message,$momAPI)

  if($null -eq $momAPI)
  {
	  return
  } 

  $SCRIPT_NAME = $MyInvocation.ScriptName
  if ($StateProperty -ne $STATE_SUCCESS -and $StateProperty -ne $STATE_WARNING -and $StateProperty -ne $STATE_ERROR)
  {
    Write-Warning "$SCRIPT_NAME - State property is not properly defined: $StateProperty"
    return
  }

  $ErrorActionPreference="SilentlyContinue"
  $error.Clear()
  $StatePropertyBag = $momAPI.CreateTypedPropertyBag($PROPERTY_TYPE_STATE)

  if ($StatePropertyBag -eq $null)
  {
    Write-Warning "$SCRIPT_NAME - Unable to create state property bag"
    return
  }

  $StatePropertyBag.AddValue('State', $StateProperty)
  Write-Verbose "$SCRIPT_NAME - added state property bag value for state $StateProperty"

  if ($Message -ne $null)
  {
    $StatePropertyBag.AddValue('Message', $Message)
    Write-Verbose "$SCRIPT_NAME - added state property bag value for message $Message"
  }

  # Submitting state property bag
  $StatePropertyBag

  #Write-Host "$SCRIPT_NAME - state property bag returned"
}

Function Get-BpaResults
{
        param ([string]$BPAModel,[ref]$WarnCount,[ref]$ErrorCount)
        $ErrorActionPreference = "SilentlyContinue"
		$error.Clear()

        $BPAResults = (Get-BPAResult -ModelId $BPAModel ) | Where-Object {$_.Severity -eq "Warning" -or $_.Severity -eq "Error"}

        $WarnCount.Value  = 0
	    $ErrorCount.Value = 0
	    $wCount = 0
	    $eCount = 0 
	     
		if (0 -ne $error.Count -and $null -eq $BPAResults)
		{
			
			return
		}

	    $Warnings = $BPAResults | Where-Object {$_.Severity -eq "Warning"}
	    $Errors   = $BPAResults | Where-Object {$_.Severity -eq "Errors"}

        if ($null -ne  $Warnings )
        {
			$wCount =  $Warnings.Count
			$WarnCount.Value = $wCount
		}

        if ($null -ne  $Errors )
        {
			$eCount =  $Errors.Count
			$ErrorCount.Value = $eCount
		}
            
}

Function Get-AllBpaResults 
{
        param ($BPAModels,[ref]$WarnCount,[ref]$ErrorCount)

        $ErrorActionPreference = "SilentlyContinue"
		$error.Clear()

	    $Warn  = 0 
		$Err   = 0
	    $Warns = 0
	    $Errors = 0    
        foreach($BPAModel in $BPAModels)
		{
		  Get-BpaResults -BPAModel $BPAModel -WarnCount ([ref]$Warn) -ErrorCount ([ref]$Err)
          $Warns  = $Warns + $Warn
          $Errors = $Errrors + $Err
		}
	    
	   $WarnCount.Value   = $Warns
	   $ErrorCount.Value  = $Errors
}
function SafeImportModule()
{
  param ($ModuleName = $ModuleName,$LoadedAssemblies)

  $LOCAL_SYSTEM_SRC = "SafetyImportModule"
  $LOCAL_SYSTEM_ID = 104
  $NestedModulesMarker = "NestedModules*"
  $AssemblyMarker = "dll"
  $ErrorActionPreference = "SilentlyContinue"
  $error.Clear()

  $SCRIPT_NAME = $MyInvocation.ScriptName


  if ($null -eq $LoadedAssemblies -or [string]::IsNullOrEmpty($ModuleName) )
  {
	  return 
  }

  $Module = Get-Module -ListAvailable -Name $ModuleName
  if ($null -eq $Module )
  {
	  return 
  }

  $NestedModulesString = cat $Module.Path | Where-object {$_ -like $NestedModulesMarker}
 
	if ([string]::IsNullOrEmpty($NestedModulesString))
	{
	  return 
	}

     $AssemblyCollection = $NestedModulesString.Split((",","'"),[System.StringSplitOptions]::RemoveEmptyEntries) | Where-Object {$_.Contains($AssemblyMarker)}

     foreach ($AssemblyName in $AssemblyCollection) 
     {
       $AssemblyFullPath = Join-Path $Module.ModuleBase $AssemblyName
       try
       { 
         $Assembly = [System.Reflection.Assembly]::LoadFile($AssemblyFullPath)
         Import-Module -Assembly $Assembly
         [void]$LoadedAssemblies.Add($Assembly.Location)
       }
       catch [System.IO.FileLoadException]
       {
          $momAPI.LogScriptEvent($LOCAL_SYSTEM_SRC, $LOCAL_SYSTEM_ID, $EVENT_TYPE_ERROR, $SCRIPT_NAME + "Could not load {0}" -f $AssemblyFullPath)
		  $LoadedAssemblies.Clear()
		  break
       }
       catch [System.IO.FileNotFoundException]
       {
          $momAPI.LogScriptEvent($LOCAL_SYSTEM_SRC, $LOCAL_SYSTEM_ID, $EVENT_TYPE_ERROR, $SCRIPT_NAME + "File {0} Not Found" -f $AssemblyFullPath)
		  $LoadedAssemblies.Clear()
		  break
       }

     }
  
}

function RemoveImportedAssembly
{
  param ($AssemblyName = $AssemblyName)
  $Modules = Get-Module
  foreach($Module in $Modules)
  {
    if ($Module.Path -ieq $AssemblyName)
      {
        Remove-Module $Module 
      }
  }
}

Function Unload-Modules($ImportedAssemblies)
{
 	foreach ($ImportedAssembly in $ImportedAssemblies)
	{
		RemoveImportedAssembly($ImportedAssembly)
	}
}
function WriteBPAResult
{
        param ([Microsoft.BestPractices.CoreInterface.Result]$BPAResult, [boolean]$IncludeAll)

        $Delimiter = New-Object String("-",12)
        if ($BPAResult.Problem -eq $null)
        {
            if ($IncludeAll)
            {
                Write-Host $(-Join("Title      : ", $BPAResult.Title))
                Write-Host $(-Join("Compliance : ", $BPAResult.Compliance))
        	    Write-Host $Delimiter
            }
        }
        else
        {
            Write-Host $(-Join("Title      : ", $BPAResult.Title))
            Write-Host $(-Join("Problem    : ", $BPAResult.Problem))
            Write-Host $(-Join("Impact     : ", $BPAResult.Impact))
            Write-Host $(-Join("Resolution : ", $BPAResult.Resolution))
    	    Write-Host $Delimiter
        }
 }
    
function WriteModelResults
    {
        param ([string]$BPAModel, [boolean]$IncludeAll)
        $ErrorActionPreference = "SilentlyContinue"
		$error.Clear()
        $BPAResults = Get-BPAResult -ModelId $BPAModel -ErrorAction SilentlyContinue

		if (0 -ne $error.Count -and $null -eq $BPAResults)
		{
			
			if ($BpaCategoryError -ieq $error[0].CategoryInfo.Category)
			{
				Write-Host $BpaScanNotRun 
				Write-Host $BpaScanMonitor
			}
			else 
			    {
					$msg = $error[0].Exception.Message
					$msg = $BpaErrorResults  -f $msg
					Write-Host $msg
				}

			return
		}


        if ($null -eq $BPAResults )
        {
				Write-Host $BpaEmptyResults 
			    return

		}

            $NotCompliantResults = $BPAResults | Where-Object {$_.Problem -ne $null}
            
            [boolean] $IsModelCompliant = [boolean]($NotCompliantResults -eq $null)
            
            if ($false -eq $IsModelCompliant -or $true -eq $IncludeAll)
            {
                Write-Host "Server Role: "  $BPAModel
                $RoleSeparator = New-Object String("=", [int] (14 + $BPAModel.Id.Length))
                Write-Host $RoleSeparator
            }
            
            foreach ($BPAResult in $BPAResults)
            {
               WriteBPAResult -BPAResult $BPAResult -IncludeAll $IncludeAll
            }
            
    }



Function Run-BPAResult()
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()

	$BpaModels          = New-Object System.Collections.ArrayList($null) 
	$ImportedAssemblies = New-Object System.Collections.ArrayList($null)
	
	if (0 -ne $error.Count)
	{
      Write-Host $BpaInitFailed 
	  return
	}

	$iResult = Check-BpaRequirement -ModelsToRun $BpaModels -ImportedAssemblies $ImportedAssemblies

	if ($BpaSuccess -ne $iResult)
	{
		if ($BpaModelLoadProblem -eq $iResult)
		{
            Unload-Modules -ImportedAssemblies $ImportedAssemblies
	    }

		return
	}

	$IncludeAll = Convert-ToBoolean -sBool $IncludeCompliant

	foreach ($BPAModel in $BPAModels)
	{
		WriteModelResults -BPAModel $BPAModel -IncludeAll $IncludeAll
	}

	Unload-Modules -ImportedAssemblies $ImportedAssemblies
}

Run-BPAResult</ScriptBody>
                <TimeoutSeconds>300</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="WA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.CommandOutput</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
    </ModuleTypes>
    <MonitorTypes>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="HealthyState" NoDetection="false" />
          <MonitorTypeState ID="WarningState" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="Threshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumOfSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IsDiscoverDisabled" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IsUseMacAddress" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Threshold" Selector="$Config/Threshold$" ParameterType="double" />
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="NumOfSamples" Selector="$Config/NumOfSamples$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ModuleType">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <IsDiscoverDisabled>$Config/IsDiscoverDisabled$</IsDiscoverDisabled>
              <IsUseMacAddress>$Config/IsUseMacAddress$</IsUseMacAddress>
              <ComputerName>$Config/ComputerName$</ComputerName>
              <InstanceName>$Config/InstanceName$</InstanceName>
              <CounterName>$Config/CounterName$</CounterName>
            </DataSource>
            <ConditionDetection ID="TargetFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">/DataItem/InstanceName</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">$Config/InstanceName$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="SamplesCondition" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesCondition">
              <Threshold>$Config/Threshold$</Threshold>
              <Direction>greaterequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="FilterOk" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumOfSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNotOk" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>GreaterEqual</Operator>
                  <ValueExpression>
                    <Value Type="Integer">$Config/NumOfSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="HealthyState">
              <Node ID="FilterOk">
                <Node ID="SamplesCondition">
                  <Node ID="TargetFilter">
                    <Node ID="DS" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="WarningState">
              <Node ID="FilterNotOk">
                <Node ID="SamplesCondition">
                  <Node ID="TargetFilter">
                    <Node ID="DS" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="CPUUtilizationNormal" />
          <MonitorTypeState ID="CPUUtilizationHigh" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CPUPercentageThreshold" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CPUQueueLengthThreshold" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NumSamples" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AllInstances" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
          <OverrideableParameter ID="CPUPercentageThreshold" Selector="$Config/CPUPercentageThreshold$" ParameterType="int" />
          <OverrideableParameter ID="CPUQueueLengthThreshold" Selector="$Config/CPUQueueLengthThreshold$" ParameterType="int" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Microsoft.Windows.Server.10.0.CPUUtilization.ModuleType" ID="DS1">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <TargetComputerName>$Config/TargetComputerName$</TargetComputerName>
              <NumSamples>$Config/NumSamples$</NumSamples>
              <CounterName>$Config/CounterName$</CounterName>
              <ObjectName>$Config/ObjectName$</ObjectName>
              <InstanceName>$Config/InstanceName$</InstanceName>
              <AllInstances>$Config/AllInstances$</AllInstances>
            </DataSource>
            <ProbeAction ID="ProbeActionDS" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
              <ScriptName>Microsoft.Windows.Server.CPUUtilization.Monitortype.ps1</ScriptName>
              <PSparam>param ($CPU_PERCENTAGE_THRESHOLD, $CPU_QUEUELEN_THRESHOLD, $TargetComputer, $CPU_USAGE)</PSparam>
              <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 CPU_PERCENTAGE_THRESHOLD
# 1 CPU_QUEUELEN_THRESHOLD
# 2 Computer (FQDN)
# 3 CPU_USAGE

Function Main()
{    
    if ($CPU_USAGE -lt 0 -or ($CPU_USAGE - $CPU_PERCENTAGE_THRESHOLD -lt 0))
    {
        ReturnResults "GOOD" 0 $CPU_USAGE
        exit
    }

    #
    # Sample the queue length. If we exceed threshold, then we will wait and sample agian
    # to avoid sampling a cpu spike, both have exceeded, then we have a runaway cpu.
    #
    
    $lNumProcessors = GetNumProcessors $TargetComputer

    $nQueueLength = GetCpuQueueLength $TargetComputer
    if ($nQueueLength -gt [long]$CPU_QUEUELEN_THRESHOLD * $lNumProcessors)
    {
        sleep -m 500
        $nQueueLength = GetCpuQueueLength $TargetComputer
        if ($nQueueLength -gt [long]$CPU_QUEUELEN_THRESHOLD * $lNumProcessors)
        {
            ReturnResults "BAD" $nQueueLength $CPU_USAGE
            exit
        }
    }

    ReturnResults "GOOD" $nQueueLength $CPU_USAGE
	Unload-Module -ModuleName "CimCmdLets"
}

Function ReturnResults
{
    param ($State, $QueueLength, $PctUsage)

    $oBag = $momAPI.CreatePropertyBag()
    $oBag.AddValue("State", $State)
    $oBag.AddValue("QueueLength", $QueueLength)
    $oBag.AddValue("PctUsage", $PctUsage)
    $oBag
}

# Windows Server 2003, Windows XP, and Windows 2000: Because the NumberOfLogicalProcessors property
# is not available, NumberOfProcessors indicates the number of logical processors available in the
# system. In the case of a computer system that has two physical processors each containing two
# logical processors, the value of NumberOfProcessors is 4.
# For more information see "http://msdn2.microsoft.com/en-us/library/aa394102(VS.85).aspx"
Function GetNumProcessors($TargetComputer)
{
    $WMISet = WMIGetInstanceEx $TargetComputer "root\cimv2" "Win32_ComputerSystem"
    foreach ($owObj in $WMISet)
    {
        $error.Clear()
        return $owObj.NumberOfLogicalProcessors
        if ($error.Count -ne 0)
        {
            return $owObj.NumberOfProcessors
        }
    }
}

Function GetCpuQueueLength($TargetComputer)
{
    $WMISet = WMIGetInstanceEx $TargetComputer "root\cimv2" "Win32_PerfRawData_PerfOS_System"
    foreach ($owObj in $WMISet)
    {
        return $owObj.ProcessorQueueLength
    }
}

Main
</ScriptBody>
              <Parameters>
                <Parameter>
                  <Name>CPU_PERCENTAGE_THRESHOLD</Name>
                  <Value>$Config/CPUPercentageThreshold$</Value>
                </Parameter>
                <Parameter>
                  <Name>CPU_QUEUELEN_THRESHOLD</Name>
                  <Value>$Config/CPUQueueLengthThreshold$</Value>
                </Parameter>
                <Parameter>
                  <Name>TargetComputer</Name>
                  <Value>$Config/TargetComputerName$</Value>
                </Parameter>
                <Parameter>
                  <Name>CPU_USAGE</Name>
                  <Value>$Data/Value$</Value>
                </Parameter>
              </Parameters>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </ProbeAction>
            <ConditionDetection ID="FilterOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery>Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>ContainsSubstring</Operator>
                  <Pattern>GOOD</Pattern>
                </RegExExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNotOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery>Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>ContainsSubstring</Operator>
                  <Pattern>BAD</Pattern>
                </RegExExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="CPUUtilizationNormal">
              <Node ID="FilterOK">
                <Node ID="ProbeActionDS">
                  <Node ID="DS1" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="CPUUtilizationHigh">
              <Node ID="FilterNotOK">
                <Node ID="ProbeActionDS">
                  <Node ID="DS1" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="UnderWarningThresholds" NoDetection="false" />
          <MonitorTypeState ID="OverWarningUnderErrorThresholds" NoDetection="false" />
          <MonitorTypeState ID="OverErrorThresholds" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DiskLabel" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveWarningMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveWarningPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveErrorMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveErrorPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveWarningMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveWarningPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveErrorMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveErrorPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SystemDriveWarningMBytesTheshold" Selector="$Config/SystemDriveWarningMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveWarningPercentThreshold" Selector="$Config/SystemDriveWarningPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveErrorMBytesThreshold" Selector="$Config/SystemDriveErrorMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveErrorPercentThreshold" Selector="$Config/SystemDriveErrorPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveWarningMBytesThreshold" Selector="$Config/NonSystemDriveWarningMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveWarningPercentThreshold" Selector="$Config/NonSystemDriveWarningPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveErrorMBytesThreshold" Selector="$Config/NonSystemDriveErrorMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveErrorPercentThreshold" Selector="$Config/NonSystemDriveErrorPercentThreshold$" ParameterType="double" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <DiskLabel>$Config/DiskLabel$</DiskLabel>
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SystemDriveWarningMBytesThreshold>$Config/SystemDriveWarningMBytesThreshold$</SystemDriveWarningMBytesThreshold>
              <SystemDriveWarningPercentThreshold>$Config/SystemDriveWarningPercentThreshold$</SystemDriveWarningPercentThreshold>
              <SystemDriveErrorMBytesThreshold>$Config/SystemDriveErrorMBytesThreshold$</SystemDriveErrorMBytesThreshold>
              <SystemDriveErrorPercentThreshold>$Config/SystemDriveErrorPercentThreshold$</SystemDriveErrorPercentThreshold>
              <NonSystemDriveWarningMBytesThreshold>$Config/NonSystemDriveWarningMBytesThreshold$</NonSystemDriveWarningMBytesThreshold>
              <NonSystemDriveWarningPercentThreshold>$Config/NonSystemDriveWarningPercentThreshold$</NonSystemDriveWarningPercentThreshold>
              <NonSystemDriveErrorMBytesThreshold>$Config/NonSystemDriveErrorMBytesThreshold$</NonSystemDriveErrorMBytesThreshold>
              <NonSystemDriveErrorPercentThreshold>$Config/NonSystemDriveErrorPercentThreshold$</NonSystemDriveErrorPercentThreshold>
            </DataSource>
            <ConditionDetection ID="ErrorSamplesCD" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesCondition">
              <Threshold>2</Threshold>
              <Direction>greaterequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="HealthySamplesCD" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesCondition">
              <Threshold>0</Threshold>
              <Direction>lessequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="SamplesCounter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Double">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>GreaterEqual</Operator>
                  <ValueExpression>
                    <Value Type="Double">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCD" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Double">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="Double">1</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="PerfMapper" TypeID="SystemPerf!System.Performance.DataGenericMapper">
              <ObjectName>Logical Disk</ObjectName>
              <CounterName>Free Space Counter</CounterName>
              <InstanceName>$Config/DiskLabel$</InstanceName>
              <Value>$Data/Property[@Name='DiskState']$</Value>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="UnderWarningThresholds">
              <Node ID="SamplesCounter">
                <Node ID="HealthySamplesCD">
                  <Node ID="PerfMapper">
                    <Node ID="DS" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="OverWarningUnderErrorThresholds">
              <Node ID="WarningCD">
                <Node ID="PerfMapper">
                  <Node ID="DS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="OverErrorThresholds">
              <Node ID="SamplesCounter">
                <Node ID="ErrorSamplesCD">
                  <Node ID="PerfMapper">
                    <Node ID="DS" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="Good" />
          <MonitorTypeState ID="Bad" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="DiskLabel" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="ScriptDS" TypeID="Microsoft.Windows.Server.10.0.LogicalDisk.ModuleType">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <TargetComputerName>$Config/TargetComputerName$</TargetComputerName>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </DataSource>
            <ConditionDetection ID="FilterOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <XPathQuery>Property[@Name='State']</XPathQuery>
                      </ValueExpression>
                      <Operator>ContainsSubstring</Operator>
                      <Pattern>OK</Pattern>
                    </RegExExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="String">Property[@Name='DiskLabel']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="String">$Config/DiskLabel$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNotOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <XPathQuery>Property[@Name='State']</XPathQuery>
                      </ValueExpression>
                      <Operator>ContainsSubstring</Operator>
                      <Pattern>BAD</Pattern>
                    </RegExExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="String">Property[@Name='DiskLabel']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="String">$Config/DiskLabel$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Good">
              <Node ID="FilterOK">
                <Node ID="ScriptDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Bad">
              <Node ID="FilterNotOK">
                <Node ID="ScriptDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="Warning" NoDetection="false" />
          <MonitorTypeState ID="Success" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="SchedulerStart" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SchedulerDaysOfWeekMask" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="FilePercentFragmentationThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="UseOSRecommendation" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="SchedulerStart" Selector="$Config/SchedulerStart$" ParameterType="string" />
          <OverrideableParameter ID="SchedulerDaysOfWeekMask" Selector="$Config/SchedulerDaysOfWeekMask$" ParameterType="int" />
          <OverrideableParameter ID="FilePercentFragmentationThreshold" Selector="$Config/FilePercentFragmentationThreshold$" ParameterType="double" />
          <OverrideableParameter ID="UseOSRecommendation" Selector="$Config/UseOSRecommendation$" ParameterType="bool" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
              <Scheduler>
                <WeeklySchedule>
                  <Windows>
                    <Daily>
                      <Start>$Config/SchedulerStart$</Start>
                      <End>$Config/SchedulerStart$</End>
                      <DaysOfWeekMask>$Config/SchedulerDaysOfWeekMask$</DaysOfWeekMask>
                    </Daily>
                  </Windows>
                </WeeklySchedule>
                <ExcludeDates />
              </Scheduler>
            </DataSource>
            <ProbeAction ID="Script" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
              <ScriptName>Microsoft.Windows.Server.LogicalDisk.DefragAnalysis.ps1</ScriptName>
              <PSparam>param ($TargetComputer)</PSparam>
              <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 Computer (FQDN)

Function Main()
{   
    # Fragmentation analysis requires lots of time and consumes lots of CPU.
    # So it is important to trace such activity in events log in order to be able
    # to understand what is going on.
    $g_DebugFlag = $true

	$IsMsftVolumeSupported = Is_MSFT_Volume_Supported_On_NanoServer $TargetComputer
	$IsVolumeInfoSupported = Is_Win32_Volume_Supported $TargetComputer

	if ($IsMsftVolumeSupported -eq $true) # Win32_Volume is not supported on NanoServer
	{
		Start-DefragAnalysisOnNano -TargetComputer $TargetComputer -momAPI $momAPI
	}
	else
       {
		   if ($false -eq $IsVolumeInfoSupported)
			{ 
				TraceLogMessage ("This Operating System doesn't support volumes WMI class.")
				return
			}
           
		    Start-DefragAnalysis -TargetComputer $TargetComputer -momAPI $momAPI
	   }
   
    Unload-Module -ModuleName "CimCmdLets"
 
}

Function Is_MSFT_Volume_Supported_On_NanoServer($TargetComputer)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$bRet = $false
	$IsNano = Is_NanoServer 
	if ($true -eq $IsNano)
	{
		Load-CimModules
	    try
		{
			$cimSessionOption = New-CimSessionOption -Protocol DCOM
			$cimsession = New-CimSession -SessionOption $cimSessionOption 
			$oWMI = Get-CimClass -CimSession $cimsession -NameSpace "root\microsoft\windows\storage" MSFT_Volume -ErrorAction SilentlyContinue
		}
		Finally
		{
			Get-CimSession | Remove-CimSession
			$cimsession =$null
			$cimSessionOption = $null 
		}
		if ($oWMI -ne $null)
		{
			$bRet = $true
		}
	}

	return $bRet
}

Function Start-DefragAnalysisOnNano($TargetComputer,$momAPI)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$IsDiskFound = $false

		$oWmiDiskSet = WMIGetInstanceNoAbort $TargetComputer "root\microsoft\windows\storage" "MSFT_Volume WHERE (DriveType=3 or DriveType=6) and FileSystem!=null"
		foreach ($oWmiDisk in $oWmiDiskSet)
		{
			$sDriveLetter = $oWmiDisk.DriveLetter
			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				$sDriveLetter = $oWmiDisk.UniqueId
			}

			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				continue
			}

			TraceLogMessage ("Running DefragAnalysis (disk: " + $sDriveLetter + "; computer: " + $TargetComputer + ").")
			$error.Clear()
			Load-CimModules
			try
			{
				$cimSessionOption = New-CimSessionOption -Protocol DCOM
				$cimsession = New-CimSession -SessionOption $cimSessionOption 
				$ret = Invoke-CimMethod -CimSession $cimsession -CimInstance $oWmiDisk -MethodName Optimize -Arguments @{ReTrim=$false;Analyze=$true;Defrag=$false;SlabConsolidate=$false;TierOptimize=$false} -ErrorAction SilentlyContinue
			}
			Finally
			{
				Get-CimSession | Remove-CimSession
				$cimsession =$null
				$cimSessionOption = $null 
			}
			TraceLogMessage ("DefragAnalysis results (return code: " + $ret.ReturnValue + ")(disk: " + $sDriveLetter + "; computer: " + $TargetComputer + ")")
                
			If ($ret.ReturnValue -ne 0 -or $error.Count -ne 0)
			{
				$pctFrag = 25
				$DefragRecomend = $true
				Add-BagData -sDriveLetter $sDriveLetter -pctFrag $pctFrag -DefragRecomend $DefragRecomend -objMomApi $momAPI	
			}

 
		}

		return

}

Function Start-DefragAnalysis($TargetComputer,$momAPI)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()

    $oWmiDiskSet = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_Volume WHERE (DriveType=3 or DriveType=6) and FileSystem!=null"

		foreach ($oWmiDisk in $oWmiDiskSet)
		{
			$sDriveLetter = $oWmiDisk.DriveLetter
			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				            $sDriveLetter = $oWmiDisk.Name
							$sDriveLetter = StripEndChar -sName $sDriveLetter
			}

			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				continue
			}

			TraceLogMessage ("Running DefragAnalysis (disk: " + $sDriveLetter + "; computer: " + $TargetComputer + ").")
			$error.Clear()
			Load-CimModules
			try
			{
				$cimSessionOption = New-CimSessionOption -Protocol DCOM
				$cimsession = New-CimSession -SessionOption $cimSessionOption 
				$ret = Invoke-CimMethod -CimSession $cimsession -CimInstance $oWmiDisk -MethodName DefragAnalysis -ErrorAction SilentlyContinue
			}
			Finally
			{
				Get-CimSession | Remove-CimSession
				$cimsession =$null
				$cimSessionOption = $null 
			}
			TraceLogMessage ("DefragAnalysis results (return code: " + $ret.ReturnValue + ")(disk: " + $sDriveLetter + "; computer: " + $TargetComputer + "): OSRecommended = " + $ret.DefragRecommended + "; FilePercentFragmentation = " + $ret.DefragAnalysis.FilePercentFragmentation + ".")
                  
			$pctFrag        = $ret.DefragAnalysis.FilePercentFragmentation
			$DefragRecomend = $ret.DefragRecommended
			Add-BagData -sDriveLetter $sDriveLetter -pctFrag $pctFrag -DefragRecomend $DefragRecomend -objMomApi $momAPI
 
		}

		return

}

Function Add-BagData($sDriveLetter,$pctFrag,$DefragRecomend,$objMomApi)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()

	if ($null -eq $sDriveLetterobjMomApi)
	{
		return
	}

	$oBag = $momAPI.CreatePropertyBag()

	if ($Null -eq $oBag)
	{
		return
	}

	$oBag.AddValue("DiskLabel", $sDriveLetter)
	$oBag.AddValue("OSRecommended", $DefragRecomend)
	$oBag.AddValue("FilePercentFragmentation", $pctFrag )
	$oBag

}

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
Main

</ScriptBody>
              <Parameters>
                <Parameter>
                  <Name>TargetComputer</Name>
                  <Value>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Value>
                </Parameter>
              </Parameters>
              <TimeoutSeconds>3600</TimeoutSeconds>
            </ProbeAction>
            <ConditionDetection ID="FilterDrive" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='DiskLabel']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="ErrorFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <Or>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <Value Type="Boolean">$Config/UseOSRecommendation$</Value>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="Boolean">false</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">Property[@Name='FilePercentFragmentation']</XPathQuery>
                          </ValueExpression>
                          <Operator>Greater</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/FilePercentFragmentationThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <Value Type="Boolean">$Config/UseOSRecommendation$</Value>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="Boolean">true</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Boolean">Property[@Name='OSRecommended']</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="Boolean">true</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                </Or>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="SuccessFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <Not>
                  <Expression>
                    <Or>
                      <Expression>
                        <And>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <Value Type="Boolean">$Config/UseOSRecommendation$</Value>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value Type="Boolean">false</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='FilePercentFragmentation']</XPathQuery>
                              </ValueExpression>
                              <Operator>LessEqual</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/FilePercentFragmentationThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </And>
                      </Expression>
                      <Expression>
                        <And>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <Value Type="Boolean">$Config/UseOSRecommendation$</Value>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value Type="Boolean">true</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Boolean">Property[@Name='OSRecommended']</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value Type="Boolean">false</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </And>
                      </Expression>
                    </Or>
                  </Expression>
                </Not>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="ErrorFilter">
                <Node ID="FilterDrive">
                  <Node ID="Script">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Success">
              <Node ID="SuccessFilter">
                <Node ID="FilterDrive">
                  <Node ID="Script">
                    <Node ID="Scheduler" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="MemoryAvailableMBytesNormal" />
          <MonitorTypeState ID="MemoryAvailableMBytesLow" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MemoryThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NumSamples" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AllInstances" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
          <OverrideableParameter ID="MemoryThreshold" Selector="$Config/MemoryThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="ScriptDS" TypeID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.ModuleType">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <TargetComputerName>$Config/TargetComputerName$</TargetComputerName>
              <NumSamples>$Config/NumSamples$</NumSamples>
              <CounterName>$Config/CounterName$</CounterName>
              <ObjectName>$Config/ObjectName$</ObjectName>
              <InstanceName>$Config/InstanceName$</InstanceName>
              <AllInstances>$Config/AllInstances$</AllInstances>
            </DataSource>
            <ProbeAction ID="ProbeActionDS" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
              <ScriptName>MemoryUtilization.ps1</ScriptName>
              <PSparam>param ($MEMORY_THRESHOLD, $TargetComputer, $AvailableMBytes)</PSparam>
              <ScriptBody>
# ##### Scripts\PowerShell\MemoryUtilization.ps1
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 MEMORY_THRESHOLD
# 1 Computer (FQDN) that the Mount Point will be hosted on

Function Main()
{
	$ErrorActionPreference = "SilentlyContinue"
    $oBag = $momAPI.CreatePropertyBag()
    $ERROR_KEY_NOT_FOUND = 2

	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $TargetComputer -SessionOption $cimSessionOption 
		$ret = Invoke-CimMethod -CimSession $cimsession -ClassName StdRegProv -NameSpace root/default -MethodName GetStringValue -Arguments @{sSubKeyName="SYSTEM\CurrentControlSet\Services\MSExchangeSA";sValueName=""}
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    if ($ret.ReturnValue -eq $ERROR_KEY_NOT_FOUND)
    {
	    if ([double]$AvailableMBytes -ge [double]$MEMORY_THRESHOLD)
        {
            $oBag.AddValue("State", "GOOD")
			$oBag.AddValue("AvailableMBytes", $AvailableMBytes + "")
            $oBag
        }
	    else
        {
            $oBag.AddValue("State", "BAD")
            $oBag.AddValue("AvailableMBytes", $AvailableMBytes + "")
            $oBag
	    }
	}
    else
    {
	    # FIXME Should We have to generate the event? 
      $oBag.AddValue("State", "GOOD")
      $oBag.AddValue("AvailableMBytes", $AvailableMBytes + "")
      $oBag
	}

	Unload-Module -ModuleName "CimCmdlets"
}
Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
Main</ScriptBody>
              <Parameters>
                <Parameter>
                  <Name>MEMORY_THRESHOLD</Name>
                  <Value>$Config/MemoryThreshold$</Value>
                </Parameter>
                <Parameter>
                  <Name>TargetComputer</Name>
                  <Value>$Config/TargetComputerName$</Value>
                </Parameter>
                <Parameter>
                  <Name>AvailableMBytes</Name>
                  <Value>$Data/Value$</Value>
                </Parameter>
              </Parameters>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </ProbeAction>
            <ConditionDetection ID="FilterOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery>Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>ContainsSubstring</Operator>
                  <Pattern>GOOD</Pattern>
                </RegExExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNotOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery>Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>ContainsSubstring</Operator>
                  <Pattern>BAD</Pattern>
                </RegExExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="MemoryAvailableMBytesNormal">
              <Node ID="FilterOK">
                <Node ID="ProbeActionDS">
                  <Node ID="ScriptDS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="MemoryAvailableMBytesLow">
              <Node ID="FilterNotOK">
                <Node ID="ProbeActionDS">
                  <Node ID="ScriptDS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="Good" />
          <MonitorTypeState ID="Bad" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="DeviceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MonitorMediaDisconnection" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MonitorDisconnection" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MonitorHardwareMalfunction" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
          <OverrideableParameter ID="MonitorMediaDisconnection" ParameterType="bool" Selector="$Config/MonitorMediaDisconnection$" />
          <OverrideableParameter ID="MonitorDisconnection" ParameterType="bool" Selector="$Config/MonitorDisconnection$" />
          <OverrideableParameter ID="MonitorHardwareMalfunction" ParameterType="bool" Selector="$Config/MonitorHardwareMalfunction$" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <LogName>System</LogName>
              <Expression>
                <Or>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery>EventSourceName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value>Tcpip</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <Or>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery>EventDisplayNumber</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value>4201</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery>EventDisplayNumber</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value>4202</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </Or>
                      </Expression>
                    </And>
                  </Expression>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery>EventSourceName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value>Microsoft-Windows-Iphlpsvc</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <Or>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery>EventDisplayNumber</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value>4200</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery>EventDisplayNumber</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value>4201</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </Or>
                      </Expression>
                    </And>
                  </Expression>
                </Or>
              </Expression>
            </DataSource>
            <ProbeAction ID="PassThrough" TypeID="System!System.PassThroughProbe" />
            <ProbeAction ID="ProbeActionGoodDS" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagProbe">
              <ScriptName>NetworkAdapterCheck.ps1</ScriptName>
              <ScriptBody>
                
                                    param ($TargetComputer, $MediaDisconnectionFlag, $DisconnectionFlag, $HardwareFlag)
                                    
$ErrorActionPreference = "Stop"

# Event type constants
$EVENT_TYPE_LOG = 0
$EVENT_TYPE_ERROR = 1
$EVENT_TYPE_WARNING = 2
$EVENT_TYPE_INFORMATION = 4

# Typed property bag constants
$PROPERTY_TYPE_ALERT = 0
$PROPERTY_TYPE_EVENT = 1
$PROPERTY_TYPE_PERFORMANCE = 2
$PROPERTY_TYPE_STATE = 3

# State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Error"

$momAPI = New-Object -ComObject Mom.ScriptAPI 
if ($null -eq $momAPI)
{
   exit -1
}

Function Load-CimModules
{
	$ErrorActionPreference = 'SilentlyContinue' 
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets

	}
}

Load-CimModules
# WMI Constant
$wbemCimtypeUseDefault        = 0   #Use Default Type CIM type - Custom
$wbemCimtypeSint16            = 2   #Signed 16-bit integer 
$wbemCimtypeSint32            = 3   #Signed 32-bit integer 
$wbemCimtypeReal32            = 4   #32-bit real number 
$wbemCimtypeReal64            = 5   #64-bit real number 
$wbemCimtypeString            = 8   #String 
$wbemCimtypeBoolean           = 11  #Boolean value 
$wbemCimtypeObject            = 13  #CIM object 
$wbemCimtypeSint8             = 16  #Signed 8-bit integer 
$wbemCimtypeUint8             = 17  #Unsigned 8-bit integer 
$wbemCimtypeUint16            = 18  #Unsigned 16-bit integer 
$wbemCimtypeUint32            = 19  #Unsigned 32-bit integer 
$wbemCimtypeSint64            = 20  #Signed 64-bit integer  
$wbemCimtypeUint64            = 21  #Unsigned 64-bit integer 
$wbemCimtypeDatetime          = 101 #Date/time value 
$wbemCimtypeReference         = 102 #Reference to a CIM object 
$wbemCimtypeChar16            = 103 #16-bit character 

$ErrAction_None               = 0
$ErrAction_Trace              = 1
$ErrAction_ThrowError         = 16
$ErrAction_Abort              = 32
$ErrAction_ThrowErrorAndAbort = 48

$DISKSIZE_BYTES_IN_MB = 1048576

$g_ErrorEventNumber = 4001
$g_TraceEventNumber = 4002
$g_DebugFlag = $false

#---------------------------------------------------------------------------
# Returns WMI Instance requested. Tries to execute WMI query a N times.
#---------------------------------------------------------------------------
Function WMIGetInstanceExTryN
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery, 
           [int]$N)

    for ($i = 0; $i -lt $N; $i++)
    {
        $error.Clear();
        
		Load-CimModules
		try
        {
		    $cimSessionOption = New-CimSessionOption -Protocol DCOM
		    $cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
            $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        catch
        {
             $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
        }
        Finally
        {
            Get-CimSession | Remove-CimSession
		    $cimsession =$null
		    $cimSessionOption = $null 
        }

        if ($error.Count -gt 0)
        {
            if ($i -eq ($N-1))
            {
                ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
            }
        }
        else
        {
            break;
        }
        sleep -m 1000
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceEx
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    $error.Clear();

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
            $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Connect to WMI.
#---------------------------------------------------------------------------
Function WMIConnect
{
    param ([string]$sTargetComputer,
           [string]$sNamespace)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
    
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg $error[0]
    }
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstance
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    WMIConnect $sTargetComputer $sNamespace
    $oInstance = WMIGetInstanceEx $sTargetComputer $sNamespace $sInstanceQuery
    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set.
#---------------------------------------------------------------------------
Function WMIExecQuery
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg, $error[0]
    }


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The Query '" + $sQuery + "' returned an invalid result set.  Please check to see if this is a valid WMI Query.") $error[0]
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set, no abort version.
#---------------------------------------------------------------------------
Function WMIExecQueryNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)    
    

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptErrorNoAbort
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    # Retrieve the name of this (running) script
    $ScriptFileName = $MyInvocation.ScriptName
    
    if ($oErr -ne $null)
    {
        $sMessage = $sMessage + ". " + $oErr.ErrorDetails
    }
    
    $momAPI.LogScriptEvent($ScriptFileName, $g_ErrorEventNumber, $EVENT_TYPE_ERROR, $sMessage)
    
    Write-Host $sMessage
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptError
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    ThrowScriptErrorNoAbort $sMessage $oErr
    exit
}

#---------------------------------------------------------------------------
# Verifies that number of arguments is correct
#---------------------------------------------------------------------------
Function VerifyNumberOfArguments
{
    param ($NumberOfArguments)

    if ($args.Length -ne $NumberOfArguments)
    {
       $sArgs = ""
       foreach ($argument in $args)
       {
           $sArgs += " {" + $argument + "}"
       }
       ThrowScriptError ("Invalid number of arguments (" + $args.Length + " instead of " + $NumberOfArguments + "). Arguments:" + $sArgs) $null
    }
}

#---------------------------------------------------------------------------
# Outputs to file and echo for debugging purposes
#---------------------------------------------------------------------------
Function TraceLogMessage
{
    param ([string]$sMessage)

    Write-Host $sMessage
    
    If ($g_DebugFlag -eq $true)
    {
        # Retrieve the name of this (running) script
        $ScriptFileName = $MyInvocation.ScriptName
        
        $momAPI.LogScriptEvent($ScriptFileName, $g_TraceEventNumber, $EVENT_TYPE_INFORMATION, $sMessage)
    }
}

#---------------------------------------------------------------------------
# Verifies the expression. If equals to False then generates an error and quits the script
#   Usage:
#     Verify Not WMISet Is Nothing, "WMISet is invalid!"
#     Verify WMISet.Count = 1, "Invalid quantity of services with name 'Server' (qty = " &amp; WMISet.Count &amp; ")."
#---------------------------------------------------------------------------
Function Verify
{
    param ([bool]$bBool, 
           [string]$sMessage)

    If ($bBool -eq $false)
    {
        ThrowScriptError $sMessage $null
    }
}

Function GetRegistryKeyValue
{
    param ([string]$keyPath, 
           [string]$key)

    $error.Clear()

    $strKeyValue = Get-ItemProperty -Path $keyPath -Name $key -ErrorAction SilentlyContinue
    if ($error.Count -gt 0)
    {
        ThrowScriptError ("An error occurred while reading the registry: '" + $keyPath + $key + "'") $error[0]
    }
    return $strKeyValue.$key
}


#---------------------------------------------------------------------------
# Function: ExpressedInMB
#   Usage:
#     Parameter (SizeInBytes) 
#     Returns the Size Expressed in MBytes
#---------------------------------------------------------------------------
Function ExpressedInMB
{
    param ($SizeInBytes)

    $NumberSizeExpInMB = [math]::Round($SizeInBytes / $DISKSIZE_BYTES_IN_MB, 0)
    return $NumberSizeExpInMB
}

Function Is_Win32_Volume_Supported($TargetComputer)
{
    $blnRet = $false
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = Is_NanoServer
	
	if ($true -eq $IsNano)
	{
		return $blnRet #NanoServer does not support Win32_Volume
	}

    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        if ([int]$objWMIOS.BuildNumber -ge 3624) 
		{
			 $blnRet = $true 
		}
    }

    return $blnRet
}

Function Get_System_Drive($TargetComputer)
{
    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        return $objWMIOS.SystemDirectory.SubString(0,2)
    }
}

Function Is_NanoServer
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels").GetValue("NanoServer")
	
	$IsNano = $IsNano -eq 1

	$error.Clear()

	return $IsNano

}

#---------------------------------------------------------------------------
# Function: StripEndChar
#   Usage:
#     Parameter (sName) 
#     Returns the sName without last special Character "\"
#---------------------------------------------------------------------------
Function StripEndChar([string]$sName)
{
    if ([string]::IsNullOrEmpty($sName))
    { 
        return [string]::Empty
    }
    else
    {
        return $sName.Substring(0, $sName.Length-1)
    }
}

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Get-Volumes([bool]$IsNano,[bool]$IsVolumeSupported,[string] $TargetComputer)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$oVolumes = $null

	if ($true -eq $IsNano)
	{
		$bLoadModule = Load-Module -ModuleName "Storage"
		if($false -eq $bLoadModule)
        {
			return $null
		} 

		$oVolumes =  Get-Volume | where {$_.DriveType -eq "Fixed" -and $false -eq [string]::IsNullOrEmpty($_.FileSystem )}
	}
	else 
		{
			if ($true -eq $IsVolumeSupported)
			{
				 $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_Volume where (DriveType=3) and FileSystem!=null" 
			}
			else
			   {
				   $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_LogicalDisk where (DriveType=3) and FileSystem!=null"  
			   }
		}

	return $oVolumes
} 

Function Get-VolumeId([bool]$IsNano,[bool]$IsVolumeSupported,$Volume)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $Volume)
	{
		return $null
	}

	if ($true -eq $IsVolumeSupported)
	{
		$VolumeId = $Volume.DriveLetter
		if([string]::IsNullOrEmpty($VolumeId) )
		{
			$VolumeId = StripEndChar -sName $Volume.Name 
		}
	}
	else
	    {
			if ($true -eq $IsNano )
			{
				$VolumeId = $Volume.DriveLetter
				if([string]::IsNullOrEmpty($VolumeId) )
				{
					$VolumeId = StripEndChar -sName $Volume.UniqueId 
				}
				else
				{
					if (1 -eq $VolumeId.Length)
					{
						$VolumeId = $VolumeId + ":" 
					}
				}
			}
			else
			    {
					$VolumeId = $Volume.DeviceId
				}
			
		}

	return $VolumeId
} 

Function CreatePerformanceCounterData($strObjectName, $strCounterName, $strInstanceName, $varValue)
{

									return @{ "PerfObject"  = $strObjectName;
                                             "PerfCounter"  = $strCounterName;
                                             "PerfInstance" = $strInstanceName;
                                             "PerfValue"     =  $varValue;
                                             }
}

Function Create-PerformancePropertyBag ($strObjectName, $strCounterName, $strInstanceName, $varValue,$objMomScriptAPI)
{
				$ErrorActionPreference = "SilentlyContinue"
				$error.Clear()

				if ([string]::IsNullOrEmpty($varValue))
	            {
					$varValue = 0
				}	

	            if ($null -eq $objMomScriptAPI)
				{
					return
				}

				$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

				$objTypedPropertyBag.AddValue("PerfObject"   ,$strObjectName)
				$objTypedPropertyBag.AddValue("PerfCounter"  ,$strCounterName)
				$objTypedPropertyBag.AddValue("PerfInstance" ,$strInstanceName)
				$objTypedPropertyBag.AddValue("PerfValue"    ,$varValue)
				$objTypedPropertyBag

     
}

Function Create-EmptyPerfData ($objMomScriptAPI)
{
	 if ($null -eq $objMomScriptAPI)
  	 {
		return
 
	 }

		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()
		$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

		$objTypedPropertyBag.AddValue("PerfObject"   ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfCounter"  ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfInstance" ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfValue"    ,"EMPTY")

		#Add the property bag to the script#s XML output
		$objTypedPropertyBag
	   
	   $error.Clear()
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

 Function Unload-Module([string]$ModuleName)
 {
		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()

	    if ([string]::IsNullOrEmpty($ModuleName))
		{
			return
		}

	    $module = Get-Module $ModuleName  
	    if ($null -eq $module)
		{
		   return
		}

		Remove-Module -Name $ModuleName -Force 
 }

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 Computer (FQDN)
# 1 Media Disconnection Flag
# 2 Disconnection Flag
# 3 Hardware Flag

Function Main()
{
    $MediaDisconnectionFlag = Convert-ToBoolean -sBool $MediaDisconnectionFlag
    $DisconnectionFlag      = Convert-ToBoolean -sBool $DisconnectionFlag
    $HardwareFlag           = Convert-ToBoolean -sBool $HardwareFlag
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	# Win32_NetworkAdapter is deprecated and not returning results on NanoServer
	# Need to use MSFT_NetAdapter
	$IsModuleLoaded = Load-Module -ModuleName "NetAdapter"
	if ($false -eq $IsModuleLoaded)
	{
		return
	}

	$error.Clear()
	
	$netAdapters = Get-NetAdapter
		foreach ($netAdapter in $netAdapters)
		{
			$oBag = $momAPI.CreatePropertyBag()
        
			$oBag.AddValue("DeviceName", $netAdapter.DeviceID)
			If ( (($MediaDisconnectionFlag -eq $true) -and ($netAdapter.MediaConnectState -eq 2)) -or
			   (($DisconnectionFlag -eq $true) -and ($netAdapter.MediaConnectState -eq 2)) -or
			   (($HardwareFlag -eq $true) -and ($netAdapter.MediaConnectState -eq 2)))
			{
			   $oBag.AddValue("State", "BAD")
			}
			else
			{
			   $oBag.AddValue("State", "GOOD")
			}
        
			$oBag
		}

	 Unload-Module -ModuleName "NetAdapter"
}

Main

</ScriptBody>
              <Parameters>
                <Parameter>
                  <Name>TargetComputer</Name>
                  <Value>$Config/ComputerName$</Value>
                </Parameter>
                <Parameter>
                  <Name>MediaDisconnectionFlag</Name>
                  <Value>$Config/MonitorMediaDisconnection$</Value>
                </Parameter>
                <Parameter>
                  <Name>DisconnectionFlag</Name>
                  <Value>$Config/MonitorDisconnection$</Value>
                </Parameter>
                <Parameter>
                  <Name>HardwareFlag</Name>
                  <Value>$Config/MonitorHardwareMalfunction$</Value>
                </Parameter>
              </Parameters>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </ProbeAction>
            <ConditionDetection ID="FilterOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery>Property[@Name='DeviceName']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value>$Config/DeviceName$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <XPathQuery>Property[@Name='State']</XPathQuery>
                      </ValueExpression>
                      <Operator>ContainsSubstring</Operator>
                      <Pattern>GOOD</Pattern>
                    </RegExExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNotOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery>Property[@Name='DeviceName']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value>$Config/DeviceName$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <XPathQuery>Property[@Name='State']</XPathQuery>
                      </ValueExpression>
                      <Operator>ContainsSubstring</Operator>
                      <Pattern>BAD</Pattern>
                    </RegExExpression>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Good">
              <Node ID="FilterOK">
                <Node ID="ProbeActionGoodDS">
                  <Node ID="DS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Bad">
              <Node ID="FilterNotOK">
                <Node ID="ProbeActionGoodDS">
                  <Node ID="DS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="Good">
              <Node ID="FilterOK">
                <Node ID="ProbeActionGoodDS">
                  <Node ID="PassThrough" />
                </Node>
              </Node>
            </OnDemandDetection>
            <OnDemandDetection MonitorTypeStateID="Bad">
              <Node ID="FilterNotOK">
                <Node ID="ProbeActionGoodDS">
                  <Node ID="PassThrough" />
                </Node>
              </Node>
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.Monitoring.MonitorType" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="Healthy" NoDetection="false" />
          <MonitorTypeState ID="Warning" NoDetection="false" />
          <MonitorTypeState ID="Error" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="Interval" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Interval" Selector="$Config/Interval$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
              <Scheduler>
                <SimpleReccuringSchedule>
                  <Interval>$Config/Interval$</Interval>
                  <SyncTime />
                </SimpleReccuringSchedule>
                <ExcludeDates />
              </Scheduler>
            </DataSource>
            <ProbeAction ID="PA" TypeID="Microsoft.Windows.Server.10.0.BPA.PowerShellPropertyBagProbe">
              <ScriptName>Microsoft.Windows.Server.10.0.Monitoring.BPA.RunBPA.Script.ps1</ScriptName>
              <PSparam />
              <ScriptBody>Function Main()
{
	$State = $STATE_SUCCESS
	$ErrorActionPreference = "SilentlyContinue"

	$momAPI = New-Object -ComObject Mom.ScriptAPI
	if ($null -eq $momAPI)
	{
	  return
	}

	$error.Clear()
	$Models             = New-Object System.Collections.ArrayList($null) 
	$ImportedAssemblies = New-Object System.Collections.ArrayList($null)
	
	if (0 -ne $error.Count)
	{
      CreateStatePropertyBag -StateProperty $State -Message $BpaInitFailed  -momAPI $momAPI
	  return
	}

	$iResult = Check-BpaRequirement -ModelsToRun $Models -ImportedAssemblies $ImportedAssemblies
    
	if ($BpaNotSupportedStatus -eq $iResult)
	{
        CreateStatePropertyBag -StateProperty $State -Message $Description -momAPI $momAPI
		return
	}

	if ($BpaNotLoadedStatus  -eq $iResult)
	{
        CreateStatePropertyBag -StateProperty $State -Message $BpaLoadProblem -momAPI $momAPI
		return

	}

	if ($BpaModelLoadProblem  -eq $iResult)
	{
        CreateStatePropertyBag -StateProperty $State -Message $BpaModelLoadProblem -momAPI $momAPI
	    
		Unload-Modules -ImportedAssemblies $ImportedAssemblies
	
		return

	}

	$ErrorActionPreference = "Stop"

	$WarningRulesCount = 0
	$ErrorRulesCount   = 0

    try
    {
        $Details = $Models | Invoke-BPAModel 
        foreach ($Detail in $Details)
        {
            If ($State -ne $STATE_ERROR)
            {
                if ($false -eq $Detail.Success)
                {
                    $State       = $STATE_ERROR
    				$Description = $DESCRIPTION_ERROR
                }
                else
                {
					$tWarningRulesCount = 0
					$tErrorRulesCount   = 0

					Get-BpaWarningsAndErrorCounts -Detail $Detail.Detail -WarningRulesCount ([ref] $tWarningRulesCount)  -ErrorRulesCount ([ref] $tErrorRulesCount)
                    if (($tWarningRulesCount -ne 0) -or ($tErrorRulesCount -ne 0))
					{
						$State              = $STATE_WARNING
    					$WarningRulesCount += $tWarningRulesCount
    					$ErrorRulesCount   += $tErrorRulesCount
					}
                }
            }
        }

        If ($State -eq $STATE_WARNING)
        {
    		$Description = $DESCRIPTION_WARNING -f $WarningRulesCount, $ErrorRulesCount
        }
    }
    catch [System.Exception]
    {
        $Description = $_.ToString()
        $State = $STATE_ERROR
    }
    finally
    {
		$ErrorActionPreference = "SilentlyContinue"

		if ($State -eq $STATE_SUCCESS)
		{
			$WarningRulesCount = 0
			$ErrorRulesCount   = 0
			Get-AllBpaResults -BPAModels $Models -WarnCount ([ref]$WarningRulesCount) -ErrorCount ([ref]$ErrorRulesCount)
			if (($WarningRulesCount -ne 0) -or ($ErrorRulesCount -ne 0))
			{
						$State              = $STATE_WARNING
						$Description        = $DESCRIPTION_WARNING -f $WarningRulesCount, $ErrorRulesCount
			}
		}

        Unload-Modules -ImportedAssemblies $ImportedAssemblies
        CreateStatePropertyBag -StateProperty $State -Message $Description -momAPI $momAPI
    }

}

Main
</ScriptBody>
              <TimeoutSeconds>300</TimeoutSeconds>
            </ProbeAction>
            <ProbeAction ID="PassThrough" TypeID="System!System.PassThroughProbe" />
            <ConditionDetection ID="FilterHealthy" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Success</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterWarning" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Warning</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterError" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Error</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Healthy">
              <Node ID="FilterHealthy">
                <Node ID="PA">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Warning">
              <Node ID="FilterWarning">
                <Node ID="PA">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Error">
              <Node ID="FilterError">
                <Node ID="PA">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="Healthy">
              <Node ID="FilterHealthy">
                <Node ID="PA">
                  <Node ID="PassThrough" />
                </Node>
              </Node>
            </OnDemandDetection>
            <OnDemandDetection MonitorTypeStateID="Warning">
              <Node ID="FilterWarning">
                <Node ID="PA">
                  <Node ID="PassThrough" />
                </Node>
              </Node>
            </OnDemandDetection>
            <OnDemandDetection MonitorTypeStateID="Error">
              <Node ID="FilterError">
                <Node ID="PA">
                  <Node ID="PassThrough" />
                </Node>
              </Node>
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="UnderWarningThresholds" NoDetection="false" />
          <MonitorTypeState ID="OverWarningUnderErrorThresholds" NoDetection="false" />
          <MonitorTypeState ID="OverErrorThresholds" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="DiskLabel" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NumSamples" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveWarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="SystemDriveErrorThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveWarningThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" name="NonSystemDriveErrorThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="SystemDriveWarningThreshold" Selector="$Config/SystemDriveWarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveErrorThreshold" Selector="$Config/SystemDriveErrorThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveWarningThreshold" Selector="$Config/NonSystemDriveWarningThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveErrorThreshold" Selector="$Config/NonSystemDriveErrorThreshold$" ParameterType="double" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.DiskState.DS.Moduletype">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <DiskLabel>$Config/DiskLabel$</DiskLabel>
              <CounterName>$Config/CounterName$</CounterName>
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
            </DataSource>
            <ConditionDetection ID="SamplesCD" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesCondition">
              <Threshold>0</Threshold>
              <Direction>greaterequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="SamplesCounter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Double">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>GreaterEqual</Operator>
                  <ValueExpression>
                    <Value Type="Double">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCD" TypeID="System!System.ExpressionFilter">
              <Expression>
                <Or>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="String">ObjectName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="String">System Logical Disk</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>Greater</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/SystemDriveErrorThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>Greater</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/SystemDriveWarningThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="String">ObjectName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="String">Logical Disk</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>Greater</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/NonSystemDriveErrorThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>Greater</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/NonSystemDriveWarningThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                </Or>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="WarningCD" TypeID="System!System.ExpressionFilter">
              <Expression>
                <Or>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="String">ObjectName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="String">System Logical Disk</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>Greater</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/SystemDriveErrorThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>LessEqual</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/SystemDriveWarningThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="String">ObjectName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="String">Logical Disk</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>Greater</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/NonSystemDriveErrorThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>LessEqual</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/NonSystemDriveWarningThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                </Or>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="ErrorCD" TypeID="System!System.ExpressionFilter">
              <Expression>
                <Or>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="String">ObjectName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="String">System Logical Disk</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>LessEqual</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/SystemDriveErrorThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                  <Expression>
                    <And>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="String">ObjectName</XPathQuery>
                          </ValueExpression>
                          <Operator>Equal</Operator>
                          <ValueExpression>
                            <Value Type="String">Logical Disk</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                      <Expression>
                        <SimpleExpression>
                          <ValueExpression>
                            <XPathQuery Type="Double">SampleValue</XPathQuery>
                          </ValueExpression>
                          <Operator>LessEqual</Operator>
                          <ValueExpression>
                            <Value Type="Double">$Config/NonSystemDriveErrorThreshold$</Value>
                          </ValueExpression>
                        </SimpleExpression>
                      </Expression>
                    </And>
                  </Expression>
                </Or>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="UnderWarningThresholds">
              <Node ID="HealthyCD">
                <Node ID="SamplesCD">
                  <Node ID="DS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="OverWarningUnderErrorThresholds">
              <Node ID="WarningCD">
                <Node ID="SamplesCounter">
                  <Node ID="SamplesCD">
                    <Node ID="DS" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="OverErrorThresholds">
              <Node ID="ErrorCD">
                <Node ID="SamplesCounter">
                  <Node ID="SamplesCD">
                    <Node ID="DS" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" Accessibility="Public">
        <MonitorTypeStates>
          <MonitorTypeState ID="UnderWarningThresholds" NoDetection="false" />
          <MonitorTypeState ID="OverWarningUnderErrorThresholds" NoDetection="false" />
          <MonitorTypeState ID="OverErrorThresholds" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SystemDriveWarningMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SystemDriveWarningPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SystemDriveErrorMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SystemDriveErrorPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NonSystemDriveWarningMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NonSystemDriveWarningPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NonSystemDriveErrorMBytesThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NonSystemDriveErrorPercentThreshold" type="xsd:double" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="DiskLabel" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="DebugFlag" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SystemDriveWarningMBytesThreshold" Selector="$Config/SystemDriveWarningMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveWarningPercentThreshold" Selector="$Config/SystemDriveWarningPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveErrorMBytesThreshold" Selector="$Config/SystemDriveErrorMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="SystemDriveErrorPercentThreshold" Selector="$Config/SystemDriveErrorPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveWarningMBytesThreshold" Selector="$Config/NonSystemDriveWarningMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveWarningPercentThreshold" Selector="$Config/NonSystemDriveWarningPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveErrorMBytesThreshold" Selector="$Config/NonSystemDriveErrorMBytesThreshold$" ParameterType="double" />
          <OverrideableParameter ID="NonSystemDriveErrorPercentThreshold" Selector="$Config/NonSystemDriveErrorPercentThreshold$" ParameterType="double" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="DebugFlag" Selector="$Config/DebugFlag$" ParameterType="bool" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="ScriptDS" TypeID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.ModuleType">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <TargetComputerName>$Config/TargetComputerName$</TargetComputerName>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              <DebugFlag>$Config/DebugFlag$</DebugFlag>
            </DataSource>
            <ConditionDetection ID="FilterOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="String">Property[@Name='DiskLabel']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="String">$Config/DiskLabel$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <Not>
                      <Expression>
                        <Or>
                          <Expression>
                            <And>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Equal</Operator>
                                  <ValueExpression>
                                    <Value Type="Boolean">true</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/SystemDriveErrorPercentThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/SystemDriveErrorMBytesThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                            </And>
                          </Expression>
                          <Expression>
                            <And>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Equal</Operator>
                                  <ValueExpression>
                                    <Value Type="Boolean">false</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/NonSystemDriveErrorPercentThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/NonSystemDriveErrorMBytesThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                            </And>
                          </Expression>
                        </Or>
                      </Expression>
                    </Not>
                  </Expression>
                  <Expression>
                    <Not>
                      <Expression>
                        <Or>
                          <Expression>
                            <And>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Equal</Operator>
                                  <ValueExpression>
                                    <Value Type="Boolean">true</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/SystemDriveWarningPercentThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/SystemDriveWarningMBytesThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                            </And>
                          </Expression>
                          <Expression>
                            <And>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Equal</Operator>
                                  <ValueExpression>
                                    <Value Type="Boolean">false</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/NonSystemDriveWarningPercentThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/NonSystemDriveWarningMBytesThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                            </And>
                          </Expression>
                        </Or>
                      </Expression>
                    </Not>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterWarning" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="String">Property[@Name='DiskLabel']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="String">$Config/DiskLabel$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <Not>
                      <Expression>
                        <Or>
                          <Expression>
                            <And>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Equal</Operator>
                                  <ValueExpression>
                                    <Value Type="Boolean">true</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/SystemDriveErrorPercentThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/SystemDriveErrorMBytesThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                            </And>
                          </Expression>
                          <Expression>
                            <And>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Equal</Operator>
                                  <ValueExpression>
                                    <Value Type="Boolean">false</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/NonSystemDriveErrorPercentThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                              <Expression>
                                <SimpleExpression>
                                  <ValueExpression>
                                    <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                                  </ValueExpression>
                                  <Operator>Less</Operator>
                                  <ValueExpression>
                                    <Value Type="Double">$Config/NonSystemDriveErrorMBytesThreshold$</Value>
                                  </ValueExpression>
                                </SimpleExpression>
                              </Expression>
                            </And>
                          </Expression>
                        </Or>
                      </Expression>
                    </Not>
                  </Expression>
                  <Expression>
                    <Or>
                      <Expression>
                        <And>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value Type="Boolean">true</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/SystemDriveWarningPercentThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/SystemDriveWarningMBytesThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </And>
                      </Expression>
                      <Expression>
                        <And>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value Type="Boolean">false</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/NonSystemDriveWarningPercentThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/NonSystemDriveWarningMBytesThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </And>
                      </Expression>
                    </Or>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNotOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="String">Property[@Name='DiskLabel']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="String">$Config/DiskLabel$</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <Or>
                      <Expression>
                        <And>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value Type="Boolean">true</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/SystemDriveErrorPercentThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/SystemDriveErrorMBytesThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </And>
                      </Expression>
                      <Expression>
                        <And>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Boolean">Property[@Name='IsSystem']</XPathQuery>
                              </ValueExpression>
                              <Operator>Equal</Operator>
                              <ValueExpression>
                                <Value Type="Boolean">false</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='PctFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/NonSystemDriveErrorPercentThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                          <Expression>
                            <SimpleExpression>
                              <ValueExpression>
                                <XPathQuery Type="Double">Property[@Name='MbFree']</XPathQuery>
                              </ValueExpression>
                              <Operator>Less</Operator>
                              <ValueExpression>
                                <Value Type="Double">$Config/NonSystemDriveErrorMBytesThreshold$</Value>
                              </ValueExpression>
                            </SimpleExpression>
                          </Expression>
                        </And>
                      </Expression>
                    </Or>
                  </Expression>
                </And>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="UnderWarningThresholds">
              <Node ID="FilterOK">
                <Node ID="ScriptDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="OverWarningUnderErrorThresholds">
              <Node ID="FilterWarning">
                <Node ID="ScriptDS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="OverErrorThresholds">
              <Node ID="FilterNotOK">
                <Node ID="ScriptDS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.Processor.Monitortype" Accessibility="Public">
        <MonitorTypeStates>
          <MonitorTypeState ID="UnderThreshold" NoDetection="false" />
          <MonitorTypeState ID="OverThreshold" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Frequency" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Threshold" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NumSamples" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="Frequency" Selector="$Config/Frequency$" ParameterType="int" />
          <OverrideableParameter ID="Threshold" Selector="$Config/Threshold$" ParameterType="int" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType" ID="DS">
              <CounterName>$Config/CounterName$</CounterName>
              <ObjectName>$Config/ObjectName$</ObjectName>
              <InstanceName>$Config/InstanceName$</InstanceName>
              <Frequency>$Config/Frequency$</Frequency>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </DataSource>
            <ConditionDetection ID="SamplesCD" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesCondition">
              <Threshold>$Config/Threshold$</Threshold>
              <Direction>greaterequal</Direction>
            </ConditionDetection>
            <ConditionDetection ID="ErrorCD" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Double">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>GreaterEqual</Operator>
                  <ValueExpression>
                    <Value Type="Double">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="HealthyCD" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Double">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Less</Operator>
                  <ValueExpression>
                    <Value Type="Double">$Config/NumSamples$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="UnderThreshold">
              <Node ID="HealthyCD">
                <Node ID="SamplesCD">
                  <Node ID="DS" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="OverThreshold">
              <Node ID="ErrorCD">
                <Node ID="SamplesCD">
                  <Node ID="DS" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="TimeOffsetNormal" />
          <MonitorTypeState ID="TimeOffsetHigh" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TargetComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Threshold" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NumSamples" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CounterName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ObjectName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AllInstances" type="xsd:boolean" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
          <OverrideableParameter ID="Threshold" Selector="$Config/Threshold$" ParameterType="string" />
          <OverrideableParameter ID="NumSamples" Selector="$Config/NumSamples$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource TypeID="Microsoft.Windows.Server.10.0.TimeOffset.ModuleType" ID="DS1">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <TargetComputerName>$Config/TargetComputerName$</TargetComputerName>
              <NumSamples>$Config/NumSamples$</NumSamples>
              <CounterName>$Config/CounterName$</CounterName>
              <ObjectName>$Config/ObjectName$</ObjectName>
              <InstanceName>$Config/InstanceName$</InstanceName>
              <AllInstances>$Config/AllInstances$</AllInstances>
            </DataSource>
            <ProbeAction ID="ProbeActionDS" TypeID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
              <ScriptName>Microsoft.Windows.Server.TimeOffset.Monitortype.ps1</ScriptName>
              <PSparam>param ($TimeOffSet_THRESHOLD, $TargetComputer, $Time_Offset)</PSparam>
              <ScriptBody>
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 TimeOffSet_THRESHOLD
# 1 Time_Offset
[Decimal]$thold 
[Decimal]$toffset
	
$useCulture = New-Object System.Globalization.CultureInfo("en-US")

[Decimal]$toffset = [convert]::ToDecimal($Time_Offset,$useCulture)
# default threshold value in a form of MilliSeconds
# we can change threshold values to in form of Microseconds, Ex: threshold = 0.001 is a 1 Microsecond
# Converting threshold value in milliseconds  to microseconds. Hence we need to convert to decimal.
[Decimal]$thold = [convert]::ToDecimal($TimeOffSet_THRESHOLD,$useCulture)

Function Main()
{    

TraceLogMessage("Computed Time Offset " + $Time_Offset.ToString())

   $thold = $thold * 1000
    if ($toffset -le 0 )
    {
		ReturnResults "GOOD" $toffset
    }
	elseif($toffset - $thold -ge 0)
	{
		ReturnResults "BAD" $toffset
	}
	else
	{
		 ReturnResults "GOOD" $toffset
	}


}

Function ReturnResults
{
    param ($State, [Decimal]$toffset)

	[string]$message1 = $toffset.ToString()  + " Micro Seconds"

    $oBag = $momAPI.CreatePropertyBag()
    $oBag.AddValue("State", $State)
    #$oBag.AddValue("TimeOffset", $toffset)
	
	$oBag.AddValue("TimeOffset", $message1)
	if($State -eq "BAD")
	{
	  $oBag.AddValue("Description", "Time Accuracy Out of Range")
	}

    $oBag
}

Main
</ScriptBody>
              <Parameters>
                <Parameter>
                  <Name>TimeOffSet_THRESHOLD</Name>
                  <Value>$Config/Threshold$</Value>
                </Parameter>
                <Parameter>
                  <Name>TargetComputer</Name>
                  <Value>$Config/TargetComputerName$</Value>
                </Parameter>
                <Parameter>
                  <Name>Time_Offset</Name>
                  <Value>$Data/Value$</Value>
                </Parameter>
              </Parameters>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </ProbeAction>
            <ConditionDetection ID="FilterOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery>Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>ContainsSubstring</Operator>
                  <Pattern>GOOD</Pattern>
                </RegExExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNotOK" TypeID="System!System.ExpressionFilter">
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery>Property[@Name='State']</XPathQuery>
                  </ValueExpression>
                  <Operator>ContainsSubstring</Operator>
                  <Pattern>BAD</Pattern>
                </RegExExpression>
              </Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="TimeOffsetNormal">
              <Node ID="FilterOK">
                <Node ID="ProbeActionDS">
                  <Node ID="DS1" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="TimeOffsetHigh">
              <Node ID="FilterNotOK">
                <Node ID="ProbeActionDS">
                  <Node ID="DS1" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
    </MonitorTypes>
  </TypeDefinitions>
  <Monitoring>
    <Rules>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.CheckingFileSystemOccuredOnStartup.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Application</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Wininit</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>1001</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.CleanShutdown.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Eventlog</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>6006</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.DirtyShutdown.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Eventlog</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>6008</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogFull.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Microsoft-Windows-Eventlog</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>6000</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogFull.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.IPAddressConflict.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>TCPIP</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>4198</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>4199</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>2</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.IPAddressConflict.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.LDMCantReadDisk.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>DISK</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>31</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.LDMCantReadDisk.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.NetworkAdapterDisconnected.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>TCPIP</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>4202</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSDelayedWriteLost.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventSourceName</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>DISK</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventSourceName</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>Ntfs</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>11</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>50</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSDelayedWriteLost.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSFileSystemCorrupt.Alert" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventSourceName</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>DISK</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventSourceName</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>Ntfs</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="UnsignedInteger">41</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="UnsignedInteger">55</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSFileSystemCorrupt.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSQuotaThresholdLimitReached.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>DISK</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>40</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSQuotaThresholdReached.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>DISK</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>36</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.PerfCounterDataRequestTimeOut.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Application</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Perflib</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>1015</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>2</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.PerfCounterDataRequestTimeOut.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.PerformanceRegistryCorruption.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Application</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>loadperf</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <Or>
                        <Expression>
                          <Or>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery>EventDisplayNumber</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value>2004</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery>EventDisplayNumber</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value>2006</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                          </Or>
                        </Expression>
                        <Expression>
                          <Or>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery>EventDisplayNumber</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value>2007</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery>EventDisplayNumber</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value>3000</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                          </Or>
                        </Expression>
                      </Or>
                    </Expression>
                    <Expression>
                      <Or>
                        <Expression>
                          <Or>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery>EventDisplayNumber</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value>3001</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery>EventDisplayNumber</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value>3002</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                          </Or>
                        </Expression>
                        <Expression>
                          <Or>
                            <Expression>
                              <SimpleExpression>
                                <ValueExpression>
                                  <XPathQuery>EventDisplayNumber</XPathQuery>
                                </ValueExpression>
                                <Operator>Equal</Operator>
                                <ValueExpression>
                                  <Value>3012</Value>
                                </ValueExpression>
                              </SimpleExpression>
                            </Expression>
                            <Expression>
                              <Or>
                                <Expression>
                                  <SimpleExpression>
                                    <ValueExpression>
                                      <XPathQuery>EventDisplayNumber</XPathQuery>
                                    </ValueExpression>
                                    <Operator>Equal</Operator>
                                    <ValueExpression>
                                      <Value>3018</Value>
                                    </ValueExpression>
                                  </SimpleExpression>
                                </Expression>
                                <Expression>
                                  <SimpleExpression>
                                    <ValueExpression>
                                      <XPathQuery>EventDisplayNumber</XPathQuery>
                                    </ValueExpression>
                                    <Operator>Equal</Operator>
                                    <ValueExpression>
                                      <Value>3015</Value>
                                    </ValueExpression>
                                  </SimpleExpression>
                                </Expression>
                              </Or>
                            </Expression>
                          </Or>
                        </Expression>
                      </Or>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.PerformanceRegistryCorruption.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.RebootFromBugCheck.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>BugCheck</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>1000</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>1001</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.RestartEvent.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Eventlog</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>6005</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceEnteredUnpredictableState.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Service Control Manager</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7037</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7030</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>2</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceEnteredUnpredictableState.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceMisconfigured.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Service Control Manager</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7015</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7017</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7018</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7019</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7020</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>2</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceMisconfigured.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Alert" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Service Control Manager</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7000</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7001</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7002</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7003</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7008</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7022</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7023</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7025</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7026</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7038</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7041</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Service Control Manager</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7000</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7001</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7002</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7003</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7008</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7022</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7023</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7025</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7026</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7038</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7041</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Alert" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Service Control Manager</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7021</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7024</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7031</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7032</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7033</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7034</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Service Control Manager</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7021</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7024</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7031</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7032</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7033</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>7034</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Alert" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Server</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>2507</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>2511</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Server</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>2507</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery>EventDisplayNumber</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value>2511</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Alert" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Microsoft-Windows-WindowsUpdateClient</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>20</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>2</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue />
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Microsoft-Windows-WindowsUpdateClient</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>20</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdatesInstalled.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Microsoft-Windows-WindowsUpdateClient</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>19</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdatesScheduledForInstallation.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Microsoft-Windows-WindowsUpdateClient</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>18</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.NTFSFileSystemCorrupt.Alert" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Microsoft-Windows-Ntfs</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">98</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <Value Type="String">$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/Name$</Value>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[1]</XPathQuery>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <Or>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="UnsignedInteger">Params/Param[3]</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="UnsignedInteger">1</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="UnsignedInteger">Params/Param[3]</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="UnsignedInteger">2</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <XPathQuery Type="UnsignedInteger">Params/Param[3]</XPathQuery>
                        </ValueExpression>
                        <Operator>Equal</Operator>
                        <ValueExpression>
                          <Value Type="UnsignedInteger">3</Value>
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </Or>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.NTFSFileSystemCorrupt.Alert.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
              <AlertParameter2>$Data/Params/Param[1]$</AlertParameter2>
              <AlertParameter3>$Data/Params/Param[2]$</AlertParameter3>
              <AlertParameter4>$Data/Params/Param[3]$</AlertParameter4>
            </AlertParameters>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceConfiguration.Rule" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true">
        <Category>EventCollection</Category>
        <DataSources>
          <DataSource ID="EventDS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>System</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventSourceName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>Server</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery>EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value>2506</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectEvent" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishEventData" />
          <WriteAction ID="GenerateAlert" TypeID="SystemHealth!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceConfiguration.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
            </AlertParameters>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.ModuleType">
            <PhysicalMemory>$Target/Property[Type="Windows!Microsoft.Windows.OperatingSystem"]/PhysicalMemory$</PhysicalMemory>
            <Tolerance>50</Tolerance>
            <Frequency>300</Frequency>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.CurrentBandwidth.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Current Bandwidth</CounterName>
            <ObjectName>Network Adapter</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>100</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.OutputQueueLength.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Output Queue Length</CounterName>
            <ObjectName>Network Adapter</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>2</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ModuleType">
            <IntervalSeconds>300</IntervalSeconds>
            <IsDiscoverDisabled>true</IsDiscoverDisabled>
            <IsUseMacAddress>true</IsUseMacAddress>
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <CounterName>PercentBandwidthUsedRead</CounterName>
          </DataSource>
        </DataSources>
        <ConditionDetection ID="CD" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ConditionDetection.ModuleType">
          <Tolerance>10</Tolerance>
          <ToleranceType>Absolute</ToleranceType>
          <MaximumSampleSeparation>12</MaximumSampleSeparation>
          <ReturnedObjectName>/DataItem/InstanceName</ReturnedObjectName>
          <MonitoringObjectName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</MonitoringObjectName>
          <Frequency>300</Frequency>
        </ConditionDetection>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ModuleType">
            <IntervalSeconds>300</IntervalSeconds>
            <IsDiscoverDisabled>true</IsDiscoverDisabled>
            <IsUseMacAddress>true</IsUseMacAddress>
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <CounterName>PercentBandwidthUsedTotal</CounterName>
          </DataSource>
        </DataSources>
        <ConditionDetection ID="CD" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ConditionDetection.ModuleType">
          <Tolerance>10</Tolerance>
          <ToleranceType>Absolute</ToleranceType>
          <MaximumSampleSeparation>12</MaximumSampleSeparation>
          <ReturnedObjectName>/DataItem/InstanceName</ReturnedObjectName>
          <MonitoringObjectName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</MonitoringObjectName>
          <Frequency>300</Frequency>
        </ConditionDetection>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ModuleType">
            <IntervalSeconds>300</IntervalSeconds>
            <IsDiscoverDisabled>true</IsDiscoverDisabled>
            <IsUseMacAddress>true</IsUseMacAddress>
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <CounterName>PercentBandwidthUsedWrite</CounterName>
          </DataSource>
        </DataSources>
        <ConditionDetection ID="CD" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ConditionDetection.ModuleType">
          <Tolerance>10</Tolerance>
          <ToleranceType>Absolute</ToleranceType>
          <MaximumSampleSeparation>12</MaximumSampleSeparation>
          <ReturnedObjectName>/DataItem/InstanceName</ReturnedObjectName>
          <MonitoringObjectName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</MonitoringObjectName>
          <Frequency>300</Frequency>
        </ConditionDetection>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskQueueLength.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk Queue Length</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>15</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk sec/Read</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>0.026</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk sec/Transfer</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>0.026</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk sec/Write</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>0.026</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Current Disk Queue Length</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>32</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskBytesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Bytes/sec</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskReadsPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Reads/sec</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskWritesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Writes/sec</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeMB.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Free Megabytes</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Free Space</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdle.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Idle Time</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>50</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskReadBytesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Read Bytes/sec</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskWriteBytesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Write Bytes/sec</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.AverageDiskReadQueueLength.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk Read Queue Length</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>15</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.AverageDiskWriteQueueLength.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk Write Queue Length</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>15</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalDisk.SplitIOPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Split IO/Sec</CounterName>
            <ObjectName>LogicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesReceivedPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Bytes Received/sec</CounterName>
            <ObjectName>Network Adapter</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>25</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesSentPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Bytes Sent/sec</CounterName>
            <ObjectName>Network Adapter</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>25</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesTotalPerSec.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Bytes Total/sec</CounterName>
            <ObjectName>Network Adapter</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>25</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Available MBytes</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageReadsPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Page Reads/sec</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>250</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSec.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Pages/sec</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>250</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageWritesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Page Writes/sec</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>250</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPercentCommittedBytesInUse.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Committed Bytes In Use</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolNonPagedBytes.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Pool Nonpaged Bytes</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>2000000</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolPagedBytes.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Pool Paged Bytes</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>2000000</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.PageFilePercentUsage.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Usage</CounterName>
            <ObjectName>Paging File</ObjectName>
            <InstanceName>_Total</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.SystemContextSwitchesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Context Switches/sec</CounterName>
            <ObjectName>System</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>50</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.SystemProcessorQueueLength.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Processor Queue Length</CounterName>
            <ObjectName>System</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentDPCTime.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% DPC Time</CounterName>
            <ObjectName>Processor Information</ObjectName>
            <InstanceName>_Total</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Interrupt Time</CounterName>
            <ObjectName>Processor Information</ObjectName>
            <InstanceName>_Total</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentProcessorTime.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Processor Time</CounterName>
            <ObjectName>Processor Information</ObjectName>
            <InstanceName>_Total</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>5</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskQueueLength.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk Queue Length</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>15</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk sec/Read</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>0.026</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk sec/Transfer</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>0.026</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk sec/Write</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>0.026</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Current Disk Queue Length</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>32</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskBytesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Bytes/sec</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskReadsPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Reads/sec</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskWritesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Writes/sec</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdle.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Idle Time</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>50</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskReadBytesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Read Bytes/sec</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskWriteBytesPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Disk Write Bytes/sec</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AverageDiskReadQueueLength.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk Read Queue Length</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>15</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AverageDiskWriteQueueLength.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Avg. Disk Write Queue Length</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>15</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.PhysicalDisk.SplitIOPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Split IO/Sec</CounterName>
            <ObjectName>PhysicalDisk</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType">
            <CounterName>% DPC Time</CounterName>
            <ObjectName>Processor</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.Processor"]/PerfmonInstance$</InstanceName>
            <Frequency>300</Frequency>
            <TimeoutSeconds>300</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType">
            <CounterName>% Interrupt Time</CounterName>
            <ObjectName>Processor</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.Processor"]/PerfmonInstance$</InstanceName>
            <Frequency>300</Frequency>
            <TimeoutSeconds>300</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.Processor.PercentProcessorTime.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType">
            <CounterName>% Processor Time</CounterName>
            <ObjectName>Processor</ObjectName>
            <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.Processor"]/PerfmonInstance$</InstanceName>
            <Frequency>300</Frequency>
            <TimeoutSeconds>300</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% DPC Time</CounterName>
            <ObjectName>Processor</ObjectName>
            <InstanceName>$Target/Property[Type="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Interrupt Time</CounterName>
            <ObjectName>Processor</ObjectName>
            <InstanceName>$Target/Property[Type="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentProcessorTime.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>% Processor Time</CounterName>
            <ObjectName>Processor</ObjectName>
            <InstanceName>$Target/Property[Type="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor"]/PerfmonInstance$</InstanceName>
            <AllInstances>false</AllInstances>
            <Frequency>300</Frequency>
            <Tolerance>5</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.MemoryFreeSystemPageTableEntries.Collection" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Free System Page Table Entries</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>800</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCacheBytes.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Cache Bytes</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCommittedBytes.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Committed Bytes</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesOutputPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Pages Output/sec</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesInputPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Pages Input/sec</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCommitLimit.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Commit Limit</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolPagedResidentBytes.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Pool Paged Resident Bytes</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemorySystemCacheResidentBytes.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>System Cache Resident Bytes</CounterName>
            <ObjectName>Memory</ObjectName>
            <InstanceName />
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Percentage</ToleranceType>
            <MaximumSampleSeparation>6</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.CacheDataMapHitsPercent.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <CounterName>Data Map Hits %</CounterName>
            <ObjectName>Cache</ObjectName>
            <InstanceName />
            <Frequency>300</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>12</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionsEstablished.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Connections Established</CounterName>
            <ObjectName>TCPv4</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>25</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionsEstablished.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Connections Established</CounterName>
            <ObjectName>TCPv6</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>25</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionFailures.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Connection Failures</CounterName>
            <ObjectName>TCPv4</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>25</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionFailures.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Connection Failures</CounterName>
            <ObjectName>TCPv6</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>25</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionsReset.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Connections Reset</CounterName>
            <ObjectName>TCPv4</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>25</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionsReset.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Connections Reset</CounterName>
            <ObjectName>TCPv6</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>25</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Segments Retransmitted/sec</CounterName>
            <ObjectName>TCPv4</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>100</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Segments Retransmitted/sec</CounterName>
            <ObjectName>TCPv6</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>100</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Segments Received/sec</CounterName>
            <ObjectName>TCPv4</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>100</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Segments Received/sec</CounterName>
            <ObjectName>TCPv6</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>100</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Segments Sent/sec</CounterName>
            <ObjectName>TCPv4</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>100</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec.Collection" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem">
        <Category>PerformanceCollection</Category>
        <DataSources>
          <DataSource ID="PerformanceDS" TypeID="SystemPerf!System.Performance.OptimizedDataProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
            <CounterName>Segments Sent/sec</CounterName>
            <ObjectName>TCPv6</ObjectName>
            <InstanceName />
            <AllInstances>false</AllInstances>
            <Frequency>600</Frequency>
            <Tolerance>10</Tolerance>
            <ToleranceType>Absolute</ToleranceType>
            <MaximumSampleSeparation>100</MaximumSampleSeparation>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WriteToDB" TypeID="SC!Microsoft.SystemCenter.CollectPerformanceData" />
          <WriteAction ID="WriteToDW" TypeID="SCDW!Microsoft.SystemCenter.DataWarehouse.PublishPerformanceData" />
        </WriteActions>
      </Rule>
    </Rules>
    <Tasks>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.ActiveConnections.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\NETSTAT.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine />
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.IPConfig.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\IPCONFIG.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>/ALL</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.LocalUsersQuery.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\NET.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>USER</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.NetStatisticsServer.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellProbe" RunAs="System!System.PrivilegedMonitoringAccount">
          <ScriptName>Microsoft.Windows.Server.10.0.Computer.NetStatisticsServer.Task.ps1</ScriptName>
          <ScriptBody>
                  
                              param ()
                             $SCRIPT_NAME = "NetStatisticsServer"
                             try
                              {
                              $ErrorActionPreference = "Stop"
                              $Error.Clear()
                              net.exe statistics server 
                              }
                              catch{
                                if($Error[0].Exception.Message.Contains("The syntax of this command is"))
                                    { "Task is not supported on this OS" }
                                   else
                                    { $Error[0].Exception.Message }
                               $Error.Clear()
                              }
                          
                </ScriptBody>
          <TimeoutSeconds>300</TimeoutSeconds>
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.NetStatisticsWorkstation.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\NET.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>statistics workstation</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.NetworkShareQuery.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\NET.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>SHARE</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.ProcessList.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\CMD.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>/c $file/process.cmd$</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files>
            <File>
              <Name>process.cmd</Name>
              <Contents>
                        
                        @echo off
                         if exist "%WINDIR%\System32\TASKLIST.EXE" (
                            %WINDIR%\System32\TASKLIST.EXE
                            goto end
                          )
                         if exist "%windir%\system32\WindowsPowerShell\v1.0\powershell.exe" (
                            "%windir%\system32\WindowsPowerShell\v1.0\powershell.exe" -Command Get-Process
                            goto end
                          )
                         :end 
                        
                      </Contents>
              <Unicode>false</Unicode>
            </File>
          </Files>
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.RoutePrint.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\ROUTE.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>print</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.ServicesQuery.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\NET.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>Start</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.SessionQuery.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\NET.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>SESSION</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Computer.UserAccountSettingsQuery.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\NET.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>ACCOUNTS</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\chkdsk.exe</ApplicationName>
          <WorkingDirectory />
          <CommandLine>"$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$"</CommandLine>
          <TimeoutSeconds>300</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkntfs.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\CMD.EXE</ApplicationName>
          <WorkingDirectory />
          <CommandLine>/c $file/checkntfs.cmd$</CommandLine>
          <TimeoutSeconds>30</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files>
            <File>
              <Name>checkntfs.cmd</Name>
              <Contents>
                      
                        @echo off
                         if exist %WINDIR%\System32\chkntfs.exe (
                            %WINDIR%\System32\chkntfs.exe "$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$"
                            goto end
                          )
                          echo chkntfs is not supported on this Operating System.
                         :end 
                        
                    </Contents>
              <Unicode>false</Unicode>
            </File>
          </Files>
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.VolumeInfo.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\fsutil.exe</ApplicationName>
          <WorkingDirectory />
          <CommandLine>fsinfo volumeinfo "$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$"</CommandLine>
          <TimeoutSeconds>300</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.OperatingSystem.StartServerService.Task" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Timeout="600" Remotable="true">
        <Category>Maintenance</Category>
        <WriteAction ID="WA" TypeID="WindowsServer!Microsoft.Windows.Server.StartServiceViaWMI.ModuleType.PowerShell">
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
          <ServiceName>LanmanServer</ServiceName>
        </WriteAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.OperatingSystem.TopCPUUsage.Task" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Timeout="600" Remotable="true">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="WindowsServer!Microsoft.Windows.Server.TopCPUUsage.ProbeAction.PowerShell">
          <IntervalMilliseconds>2000</IntervalMilliseconds>
          <NumSamples>5</NumSamples>
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Task" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Timeout="3600" Remotable="true">
        <Category>Maintenance</Category>
        <WriteAction ID="Defrag" TypeID="Microsoft.Windows.PSScriptWriteAction">
          <ScriptName>Microsoft.Windows.Server.LogicalDisk.Defrag.ps1</ScriptName>
          <Arguments>"-TargetComputer '$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$' -DiskLabel '$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$'"</Arguments>
          <ScriptBody>
                  
param ($TargetComputer, $DiskLabel)

$ErrorActionPreference = "Stop"

# Event type constants
$EVENT_TYPE_LOG = 0
$EVENT_TYPE_ERROR = 1
$EVENT_TYPE_WARNING = 2
$EVENT_TYPE_INFORMATION = 4

# Typed property bag constants
$PROPERTY_TYPE_ALERT = 0
$PROPERTY_TYPE_EVENT = 1
$PROPERTY_TYPE_PERFORMANCE = 2
$PROPERTY_TYPE_STATE = 3

# State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Error"

$momAPI = New-Object -ComObject Mom.ScriptAPI 
if ($null -eq $momAPI)
{
   exit -1
}

Function Load-CimModules
{
	$ErrorActionPreference = 'SilentlyContinue' 
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets

	}
}

Load-CimModules
# WMI Constant
$wbemCimtypeUseDefault        = 0   #Use Default Type CIM type - Custom
$wbemCimtypeSint16            = 2   #Signed 16-bit integer 
$wbemCimtypeSint32            = 3   #Signed 32-bit integer 
$wbemCimtypeReal32            = 4   #32-bit real number 
$wbemCimtypeReal64            = 5   #64-bit real number 
$wbemCimtypeString            = 8   #String 
$wbemCimtypeBoolean           = 11  #Boolean value 
$wbemCimtypeObject            = 13  #CIM object 
$wbemCimtypeSint8             = 16  #Signed 8-bit integer 
$wbemCimtypeUint8             = 17  #Unsigned 8-bit integer 
$wbemCimtypeUint16            = 18  #Unsigned 16-bit integer 
$wbemCimtypeUint32            = 19  #Unsigned 32-bit integer 
$wbemCimtypeSint64            = 20  #Signed 64-bit integer  
$wbemCimtypeUint64            = 21  #Unsigned 64-bit integer 
$wbemCimtypeDatetime          = 101 #Date/time value 
$wbemCimtypeReference         = 102 #Reference to a CIM object 
$wbemCimtypeChar16            = 103 #16-bit character 

$ErrAction_None               = 0
$ErrAction_Trace              = 1
$ErrAction_ThrowError         = 16
$ErrAction_Abort              = 32
$ErrAction_ThrowErrorAndAbort = 48

$DISKSIZE_BYTES_IN_MB = 1048576

$g_ErrorEventNumber = 4001
$g_TraceEventNumber = 4002
$g_DebugFlag = $false

#---------------------------------------------------------------------------
# Returns WMI Instance requested. Tries to execute WMI query a N times.
#---------------------------------------------------------------------------
Function WMIGetInstanceExTryN
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery, 
           [int]$N)

    for ($i = 0; $i -lt $N; $i++)
    {
        $error.Clear();
        
		Load-CimModules
		try
        {
		    $cimSessionOption = New-CimSessionOption -Protocol DCOM
		    $cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
            $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        catch
        {
             $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
        }
        Finally
        {
            Get-CimSession | Remove-CimSession
		    $cimsession =$null
		    $cimSessionOption = $null 
        }

        if ($error.Count -gt 0)
        {
            if ($i -eq ($N-1))
            {
                ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
            }
        }
        else
        {
            break;
        }
        sleep -m 1000
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceEx
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    $error.Clear();

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
            $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Connect to WMI.
#---------------------------------------------------------------------------
Function WMIConnect
{
    param ([string]$sTargetComputer,
           [string]$sNamespace)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
    
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg $error[0]
    }
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstance
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    WMIConnect $sTargetComputer $sNamespace
    $oInstance = WMIGetInstanceEx $sTargetComputer $sNamespace $sInstanceQuery
    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set.
#---------------------------------------------------------------------------
Function WMIExecQuery
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg, $error[0]
    }


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The Query '" + $sQuery + "' returned an invalid result set.  Please check to see if this is a valid WMI Query.") $error[0]
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set, no abort version.
#---------------------------------------------------------------------------
Function WMIExecQueryNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)    
    

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptErrorNoAbort
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    # Retrieve the name of this (running) script
    $ScriptFileName = $MyInvocation.ScriptName
    
    if ($oErr -ne $null)
    {
        $sMessage = $sMessage + ". " + $oErr.ErrorDetails
    }
    
    $momAPI.LogScriptEvent($ScriptFileName, $g_ErrorEventNumber, $EVENT_TYPE_ERROR, $sMessage)
    
    Write-Host $sMessage
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptError
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    ThrowScriptErrorNoAbort $sMessage $oErr
    exit
}

#---------------------------------------------------------------------------
# Verifies that number of arguments is correct
#---------------------------------------------------------------------------
Function VerifyNumberOfArguments
{
    param ($NumberOfArguments)

    if ($args.Length -ne $NumberOfArguments)
    {
       $sArgs = ""
       foreach ($argument in $args)
       {
           $sArgs += " {" + $argument + "}"
       }
       ThrowScriptError ("Invalid number of arguments (" + $args.Length + " instead of " + $NumberOfArguments + "). Arguments:" + $sArgs) $null
    }
}

#---------------------------------------------------------------------------
# Outputs to file and echo for debugging purposes
#---------------------------------------------------------------------------
Function TraceLogMessage
{
    param ([string]$sMessage)

    Write-Host $sMessage
    
    If ($g_DebugFlag -eq $true)
    {
        # Retrieve the name of this (running) script
        $ScriptFileName = $MyInvocation.ScriptName
        
        $momAPI.LogScriptEvent($ScriptFileName, $g_TraceEventNumber, $EVENT_TYPE_INFORMATION, $sMessage)
    }
}

#---------------------------------------------------------------------------
# Verifies the expression. If equals to False then generates an error and quits the script
#   Usage:
#     Verify Not WMISet Is Nothing, "WMISet is invalid!"
#     Verify WMISet.Count = 1, "Invalid quantity of services with name 'Server' (qty = " &amp; WMISet.Count &amp; ")."
#---------------------------------------------------------------------------
Function Verify
{
    param ([bool]$bBool, 
           [string]$sMessage)

    If ($bBool -eq $false)
    {
        ThrowScriptError $sMessage $null
    }
}

Function GetRegistryKeyValue
{
    param ([string]$keyPath, 
           [string]$key)

    $error.Clear()

    $strKeyValue = Get-ItemProperty -Path $keyPath -Name $key -ErrorAction SilentlyContinue
    if ($error.Count -gt 0)
    {
        ThrowScriptError ("An error occurred while reading the registry: '" + $keyPath + $key + "'") $error[0]
    }
    return $strKeyValue.$key
}


#---------------------------------------------------------------------------
# Function: ExpressedInMB
#   Usage:
#     Parameter (SizeInBytes) 
#     Returns the Size Expressed in MBytes
#---------------------------------------------------------------------------
Function ExpressedInMB
{
    param ($SizeInBytes)

    $NumberSizeExpInMB = [math]::Round($SizeInBytes / $DISKSIZE_BYTES_IN_MB, 0)
    return $NumberSizeExpInMB
}

Function Is_Win32_Volume_Supported($TargetComputer)
{
    $blnRet = $false
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = Is_NanoServer
	
	if ($true -eq $IsNano)
	{
		return $blnRet #NanoServer does not support Win32_Volume
	}

    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        if ([int]$objWMIOS.BuildNumber -ge 3624) 
		{
			 $blnRet = $true 
		}
    }

    return $blnRet
}

Function Get_System_Drive($TargetComputer)
{
    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        return $objWMIOS.SystemDirectory.SubString(0,2)
    }
}

Function Is_NanoServer
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels").GetValue("NanoServer")
	
	$IsNano = $IsNano -eq 1

	$error.Clear()

	return $IsNano

}

#---------------------------------------------------------------------------
# Function: StripEndChar
#   Usage:
#     Parameter (sName) 
#     Returns the sName without last special Character "\"
#---------------------------------------------------------------------------
Function StripEndChar([string]$sName)
{
    if ([string]::IsNullOrEmpty($sName))
    { 
        return [string]::Empty
    }
    else
    {
        return $sName.Substring(0, $sName.Length-1)
    }
}

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Get-Volumes([bool]$IsNano,[bool]$IsVolumeSupported,[string] $TargetComputer)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$oVolumes = $null

	if ($true -eq $IsNano)
	{
		$bLoadModule = Load-Module -ModuleName "Storage"
		if($false -eq $bLoadModule)
        {
			return $null
		} 

		$oVolumes =  Get-Volume | where {$_.DriveType -eq "Fixed" -and $false -eq [string]::IsNullOrEmpty($_.FileSystem )}
	}
	else 
		{
			if ($true -eq $IsVolumeSupported)
			{
				 $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_Volume where (DriveType=3) and FileSystem!=null" 
			}
			else
			   {
				   $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_LogicalDisk where (DriveType=3) and FileSystem!=null"  
			   }
		}

	return $oVolumes
} 

Function Get-VolumeId([bool]$IsNano,[bool]$IsVolumeSupported,$Volume)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $Volume)
	{
		return $null
	}

	if ($true -eq $IsVolumeSupported)
	{
		$VolumeId = $Volume.DriveLetter
		if([string]::IsNullOrEmpty($VolumeId) )
		{
			$VolumeId = StripEndChar -sName $Volume.Name 
		}
	}
	else
	    {
			if ($true -eq $IsNano )
			{
				$VolumeId = $Volume.DriveLetter
				if([string]::IsNullOrEmpty($VolumeId) )
				{
					$VolumeId = StripEndChar -sName $Volume.UniqueId 
				}
				else
				{
					if (1 -eq $VolumeId.Length)
					{
						$VolumeId = $VolumeId + ":" 
					}
				}
			}
			else
			    {
					$VolumeId = $Volume.DeviceId
				}
			
		}

	return $VolumeId
} 

Function CreatePerformanceCounterData($strObjectName, $strCounterName, $strInstanceName, $varValue)
{

									return @{ "PerfObject"  = $strObjectName;
                                             "PerfCounter"  = $strCounterName;
                                             "PerfInstance" = $strInstanceName;
                                             "PerfValue"     =  $varValue;
                                             }
}

Function Create-PerformancePropertyBag ($strObjectName, $strCounterName, $strInstanceName, $varValue,$objMomScriptAPI)
{
				$ErrorActionPreference = "SilentlyContinue"
				$error.Clear()

				if ([string]::IsNullOrEmpty($varValue))
	            {
					$varValue = 0
				}	

	            if ($null -eq $objMomScriptAPI)
				{
					return
				}

				$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

				$objTypedPropertyBag.AddValue("PerfObject"   ,$strObjectName)
				$objTypedPropertyBag.AddValue("PerfCounter"  ,$strCounterName)
				$objTypedPropertyBag.AddValue("PerfInstance" ,$strInstanceName)
				$objTypedPropertyBag.AddValue("PerfValue"    ,$varValue)
				$objTypedPropertyBag

     
}

Function Create-EmptyPerfData ($objMomScriptAPI)
{
	 if ($null -eq $objMomScriptAPI)
  	 {
		return
 
	 }

		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()
		$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

		$objTypedPropertyBag.AddValue("PerfObject"   ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfCounter"  ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfInstance" ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfValue"    ,"EMPTY")

		#Add the property bag to the script#s XML output
		$objTypedPropertyBag
	   
	   $error.Clear()
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

 Function Unload-Module([string]$ModuleName)
 {
		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()

	    if ([string]::IsNullOrEmpty($ModuleName))
		{
			return
		}

	    $module = Get-Module $ModuleName  
	    if ($null -eq $module)
		{
		   return
		}

		Remove-Module -Name $ModuleName -Force 
 }

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 Computer (FQDN)
# 1 Logical Drive Letter

Function Main()
{   
    # Fragmentation analysis requires lots of time and consumes lots of CPU.
    # So it is important to trace such activity in events log in order to be able
    # to understand what is going on.
    $g_DebugFlag = $true

	$IsMsftVolumeSupported = Is_MSFT_Volume_Supported_On_NanoServer $TargetComputer
	$IsVolumeInfoSupported = Is_Win32_Volume_Supported $TargetComputer

	if ($IsMsftVolumeSupported -eq $true) # Win32_Volume is not supported on NanoServer
	{
		Start-DefragOnNano -TargetComputer $TargetComputer -DiskLabel $DiskLabel
	}
	else
       {
		   if ($false -eq $IsVolumeInfoSupported)
			{ 
				TraceLogMessage ("This Operating System doesn't support volumes WMI class.")
				return
			}
           
		    Start-Defrag -TargetComputer $TargetComputer -DiskLabel $DiskLabel
	   }
   
    Unload-Module -ModuleName "CimCmdLets"
}



Function Is_MSFT_Volume_Supported_On_NanoServer($TargetComputer)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$bRet = $false
	$IsNano = Is_NanoServer 
	if ($true -eq $IsNano)
	{
		Load-CimModules
		try
		{
	 		$cimSessionOption = New-CimSessionOption -Protocol DCOM
	 		$cimsession = New-CimSession -SessionOption $cimSessionOption 
	 		$oWMI = Get-CimClass -CimSession $cimsession -NameSpace "root\microsoft\windows\storage" MSFT_Volume -ErrorAction SilentlyContinue
		}
		Finally
		{
	 		Get-CimSession | Remove-CimSession
	 		$cimsession =$null
	 		$cimSessionOption = $null 
		}
		if ($oWMI -ne $null)
		{
	 		$bRet = $true
		}
	}

	return $bRet
}

Function Start-DefragOnNano($TargetComputer,$DiskLabel)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$IsDiskFound = $false

		$oWmiDiskSet = WMIGetInstanceNoAbort $TargetComputer "root\microsoft\windows\storage" "MSFT_Volume WHERE (DriveType=3 or DriveType=6) and FileSystem!=null"
		foreach ($oWmiDisk in $oWmiDiskSet)
		{
			$sDriveLetter = $oWmiDisk.DriveLetter
			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				$sDriveLetter = $oWmiDisk.UniqueId
			}
			else
				{
				   $sDriveLetter = $oWmiDisk.DriveLetter + ":" # MSFT_Volume only has "C" instead of "C:" as DriveLetter
				}

			if ($sDriveLetter -ieq $DiskLabel)
			{
					TraceLogMessage ("Perform Defragmentation (disk: " + $DiskLabel + "; computer: " + $TargetComputer + ").")
					$error.Clear()
					Load-CimModules
					try
					{
						$cimSessionOption = New-CimSessionOption -Protocol DCOM
						$cimsession = New-CimSession -SessionOption $cimSessionOption 
						$ret = Invoke-CimMethod -CimSession $cimsession -CimInstance $oWmiDisk -MethodName Optimize -Arguments @{ReTrim=$false;Analyze=$false;Defrag=$true;SlabConsolidate=$false;TierOptimize=$false} -ErrorAction SilentlyContinue
					}
					Finally
					{
						Get-CimSession | Remove-CimSession
						$cimsession =$null
						$cimSessionOption = $null 
					}
					TraceLogMessage ("Defragmentation completed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + ").")
            
					If ($ret.ReturnValue -ne 0 -or $error.Count -ne 0)
					{
							ThrowScriptError ("Defrag failed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). Return code: " + $ret.ReturnValue + ".") $error[0]
					}

					$IsDiskFound = $true
					break
		   }
 
		}

        if ($false -eq $IsDiskFound)
		{
		   		TraceLogMessage ("ERROR: Could not find a disk (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). In cluster environment this might occur when disk does not belong to current computer anymore.")
		}

		return

}

Function Start-Defrag($TargetComputer,$DiskLabel)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$IsDiskFound = $false

    $oWmiDiskSet = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_Volume WHERE (DriveType=3 or DriveType=6) and FileSystem!=null"

		foreach ($oWmiDisk in $oWmiDiskSet)
		{
			$sDriveLetter = $oWmiDisk.DriveLetter
			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				            $sDriveLetter = $oWmiDisk.Name
							$sDriveLetter = StripEndChar -sName $sDriveLetter
			}

			if ($sDriveLetter -ieq $DiskLabel)
			{
					TraceLogMessage ("Perform Defragmentation (disk: " + $DiskLabel + "; computer: " + $TargetComputer + ").")
					$error.Clear()
					Load-CimModules
					try
					{
						$cimSessionOption = New-CimSessionOption -Protocol DCOM
						$cimsession = New-CimSession -SessionOption $cimSessionOption 
						$ret = Invoke-CimMethod -CimSession $cimsession -CimInstance $oWmiDisk -MethodName Defrag -Arguments @{Force=$false} -ErrorAction SilentlyContinue
					}
					Finally
					{
						Get-CimSession | Remove-CimSession
						$cimsession =$null
						$cimSessionOption = $null 
					}
		            TraceLogMessage ("Defragmentation completed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "): FilePercentFragmentation = " + $ret.DefragAnalysis.FilePercentFragmentation + ".")
            
					If ($ret.ReturnValue -ne 0 -or $error.Count -ne 0)
					{
							ThrowScriptError ("Defrag failed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). Return code: " + $ret.ReturnValue + ".") $error[0]
					}

					$IsDiskFound = $true
					break
		   }
 
		}

        if ($false -eq $IsDiskFound)
		{
		   		TraceLogMessage ("ERROR: Could not find a disk (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). In cluster environment this might occur when disk does not belong to current computer anymore.")
		}

		return

}

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
Main
</ScriptBody>
          <TimeoutSeconds>3600</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.Monitoring.BPA.CheckBPAResult.Task" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Timeout="300" Remotable="true">
        <Category>ConfigurationHealth</Category>
        <WriteAction ID="Probe" TypeID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.WA.ModuleType">
          <IncludeCompliant>true</IncludeCompliant>
        </WriteAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Scan.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\chkdsk.exe</ApplicationName>
          <WorkingDirectory />
          <CommandLine>"$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$" /scan</CommandLine>
          <TimeoutSeconds>300</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.SpotFix.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\chkdsk.exe</ApplicationName>
          <WorkingDirectory />
          <CommandLine>"$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$" /spotfix</CommandLine>
          <TimeoutSeconds>300</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Full.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\chkdsk.exe</ApplicationName>
          <WorkingDirectory />
          <CommandLine>"$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$" /f</CommandLine>
          <TimeoutSeconds>300</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.LogicalDisk.FsUtil.RepairState.Task" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="System!System.CommandExecuterProbe">
          <ApplicationName>%WINDIR%\System32\fsutil.exe</ApplicationName>
          <WorkingDirectory />
          <CommandLine>repair state "$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$"</CommandLine>
          <TimeoutSeconds>300</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
          <Files />
        </ProbeAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.OperatingSystem.StartFirewallService.Task" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Timeout="600" Remotable="true">
        <Category>Maintenance</Category>
        <WriteAction ID="WA" TypeID="WindowsServer!Microsoft.Windows.Server.StartServiceViaWMI.ModuleType.PowerShell">
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
          <ServiceName>MpsSvc</ServiceName>
        </WriteAction>
      </Task>
      <Task ID="Microsoft.Windows.Server.10.0.OperatingSystem.StartWindowsRemoteManagementService.Task" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Timeout="600" Remotable="true">
        <Category>Maintenance</Category>
        <WriteAction ID="WA" TypeID="WindowsServer!Microsoft.Windows.Server.StartServiceViaWMI.ModuleType.PowerShell">
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
          <ServiceName>WinRM</ServiceName>
        </WriteAction>
      </Task>
    </Tasks>
    <Monitors>
      <AggregateMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal">
        <Category>StateCollection</Category>
        <Algorithm>WorstOf</Algorithm>
      </AggregateMonitor>
      <AggregateMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpaceMonitorRollup" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </AggregateMonitor>
      <AggregateMonitor ID="Microsoft.Windows.Server.10.0.Processor.PerformanceRollup" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
      </AggregateMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor" RunAs="System!System.PrivilegedMonitoringAccount" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.Monitoring.MonitorType" ConfirmDelivery="true">
        <Category>ConfigurationHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='Message']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="MonitorHealthyState" MonitorTypeStateID="Healthy" HealthState="Success" />
          <OperationalState ID="MonitorWarningState" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="MonitorErrorState" MonitorTypeStateID="Error" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <Interval>86400</Interval>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/Name$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="NotAvailabile" MonitorTypeStateID="Bad" HealthState="Error" />
          <OperationalState ID="Availabile" MonitorTypeStateID="Good" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>3600</IntervalSeconds>
          <TargetComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</TargetComputerName>
          <DiskLabel>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</DiskLabel>
          <TimeoutSeconds>300</TimeoutSeconds>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" ConfirmDelivery="true">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/Name$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Disconnected" MonitorTypeStateID="Bad" HealthState="Error" />
          <OperationalState ID="Connected" MonitorTypeStateID="Good" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <DeviceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</DeviceName>
          <TimeoutSeconds>300</TimeoutSeconds>
          <MonitorMediaDisconnection>false</MonitorMediaDisconnection>
          <MonitorDisconnection>true</MonitorDisconnection>
          <MonitorHardwareMalfunction>false</MonitorHardwareMalfunction>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth" RunAs="System!System.PrivilegedMonitoringAccount" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>Browser</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>DHCP</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>DNSCache</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>Eventlog</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>PlugPlay</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>RpcSs</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>lanmanserver</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>LmHosts</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.3SingleEventLog3StateUnitMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Activated" MonitorTypeStateID="FirstEventRaised" HealthState="Success" />
          <OperationalState ID="NeedsActivated6Days" MonitorTypeStateID="ThirdEventRaised" HealthState="Error" />
          <OperationalState ID="NeedsActivated15Days" MonitorTypeStateID="SecondEventRaised" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <FirstComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</FirstComputerName>
          <FirstLogName>Application</FirstLogName>
          <FirstExpression>
            <And>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery>EventSourceName</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value>Windows Product Activation</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery>EventDisplayNumber</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value>1006</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </And>
          </FirstExpression>
          <SecondComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</SecondComputerName>
          <SecondLogName>Application</SecondLogName>
          <SecondExpression>
            <And>
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery>EventSourceName</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value>Windows Product Activation</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery>EventDisplayNumber</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value>1005</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Params/Param[1]</XPathQuery>
                      </ValueExpression>
                      <Operator>Greater</Operator>
                      <ValueExpression>
                        <Value Type="Integer">6</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Params/Param[1]</XPathQuery>
                      </ValueExpression>
                      <Operator>LessEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">15</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
            </And>
          </SecondExpression>
          <ThirdComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ThirdComputerName>
          <ThirdLogName>Application</ThirdLogName>
          <ThirdExpression>
            <And>
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery>EventSourceName</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value>Windows Product Activation</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery>EventDisplayNumber</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value>1005</Value>
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Integer">Params/Param[1]</XPathQuery>
                  </ValueExpression>
                  <Operator>LessEqual</Operator>
                  <ValueExpression>
                    <Value Type="Integer">6</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </And>
          </ThirdExpression>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>Lanmanworkstation</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="WindowsServer!Microsoft.Windows.Server.MaxConcurrentAPI.MonitorType" ConfirmDelivery="false" RunAs="System!System.PrivilegedMonitoringAccount">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="MaxConcurrentAPIAvailable" MonitorTypeStateID="Success" HealthState="Success" />
          <OperationalState ID="MaxConcurrentAPIReached" MonitorTypeStateID="Error" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <DiagnosticMode>0</DiagnosticMode>
          <IntervalSeconds>900</IntervalSeconds>
          <SyncTime />
          <TimeoutSeconds>300</TimeoutSeconds>
          <ThresholdWaiters>50</ThresholdWaiters>
          <ThresholdTimeouts>2000</ThresholdTimeouts>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>MpsSvc</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.CheckNTServiceStateMonitorType" ConfirmDelivery="false">
        <Category>StateCollection</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <ServiceName>WinRM</ServiceName>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" ParentMonitorID="WindowsServer!Microsoft.Windows.Server.Computer.HardwareAvailabilityAggregate" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.SingleEventLogTimer2StateMonitorType" ConfirmDelivery="false" RunAs="System!System.PrivilegedMonitoringAccount">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>High</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="TimerEventRaised" HealthState="Success" MonitorTypeStateID="TimerEventRaised" />
          <OperationalState ID="EventRaised" HealthState="Error" MonitorTypeStateID="EventRaised" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <LogName>System</LogName>
          <Expression>
            <And>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="UnsignedInteger">153</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">PublisherName</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Disk</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </And>
          </Expression>
          <TimerWaitInSeconds>86400</TimerWaitInSeconds>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% Idle Time</CounterName>
          <ObjectName>LogicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
          <Frequency>900</Frequency>
          <Threshold>20</Threshold>
          <Direction>lessequal</Direction>
          <NumSamples>24</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Current Disk Queue Length</CounterName>
          <ObjectName>LogicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
          <Frequency>300</Frequency>
          <Threshold>32</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% Idle Time</CounterName>
          <ObjectName>PhysicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
          <Frequency>900</Frequency>
          <Threshold>20</Threshold>
          <Direction>lessequal</Direction>
          <NumSamples>24</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Current Disk Queue Length</CounterName>
          <ObjectName>PhysicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
          <Frequency>300</Frequency>
          <Threshold>32</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Free System Page Table Entries</CounterName>
          <ObjectName>Memory</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>5000</Threshold>
          <Direction>lessequal</Direction>
          <NumSamples>6</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Pages/Sec</CounterName>
          <ObjectName>Memory</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>5000</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType" ConfirmDelivery="true">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads.Alert.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="HealthyState" HealthState="Success" />
          <OperationalState ID="OverThreshold" MonitorTypeStateID="WarningState" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
          <CounterName>PercentBandwidthUsedRead</CounterName>
          <Threshold>60</Threshold>
          <NumOfSamples>12</NumOfSamples>
          <IntervalSeconds>300</IntervalSeconds>
          <IsDiscoverDisabled>false</IsDiscoverDisabled>
          <IsUseMacAddress>true</IsUseMacAddress>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType" ConfirmDelivery="true">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal.Alert.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="HealthyState" HealthState="Success" />
          <OperationalState ID="OverThreshold" MonitorTypeStateID="WarningState" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
          <CounterName>PercentBandwidthUsedTotal</CounterName>
          <Threshold>75</Threshold>
          <NumOfSamples>12</NumOfSamples>
          <IntervalSeconds>300</IntervalSeconds>
          <IsDiscoverDisabled>false</IsDiscoverDisabled>
          <IsUseMacAddress>true</IsUseMacAddress>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType" ConfirmDelivery="true">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites.Alert.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="HealthyState" HealthState="Success" />
          <OperationalState ID="OverThreshold" MonitorTypeStateID="WarningState" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetbiosComputerName$</ComputerName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.NetworkAdapter"]/PerfmonInstance$</InstanceName>
          <CounterName>PercentBandwidthUsedWrite</CounterName>
          <Threshold>60</Threshold>
          <NumOfSamples>12</NumOfSamples>
          <IntervalSeconds>300</IntervalSeconds>
          <IsDiscoverDisabled>false</IsDiscoverDisabled>
          <IsUseMacAddress>true</IsUseMacAddress>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Avg. Disk sec/Read</CounterName>
          <ObjectName>LogicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
          <Frequency>60</Frequency>
          <Threshold>0.04</Threshold>
          <Direction>greater</Direction>
          <NumSamples>15</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Avg. Disk sec/Transfer</CounterName>
          <ObjectName>LogicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
          <Frequency>60</Frequency>
          <Threshold>0.04</Threshold>
          <Direction>greater</Direction>
          <NumSamples>15</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Avg. Disk sec/Write</CounterName>
          <ObjectName>LogicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</InstanceName>
          <Frequency>60</Frequency>
          <Threshold>0.04</Threshold>
          <Direction>greater</Direction>
          <NumSamples>15</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" ConfirmDelivery="true">
        <Category>Custom</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderWarningThresholds" MonitorTypeStateID="UnderWarningThresholds" HealthState="Success" />
          <OperationalState ID="OverWarningUnderErrorThresholds" MonitorTypeStateID="OverWarningUnderErrorThresholds" HealthState="Warning" />
          <OperationalState ID="OverErrorThresholds" MonitorTypeStateID="OverErrorThresholds" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <DiskLabel>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</DiskLabel>
          <IntervalSeconds>900</IntervalSeconds>
          <SystemDriveWarningMBytesThreshold>500</SystemDriveWarningMBytesThreshold>
          <SystemDriveWarningPercentThreshold>10</SystemDriveWarningPercentThreshold>
          <SystemDriveErrorMBytesThreshold>300</SystemDriveErrorMBytesThreshold>
          <SystemDriveErrorPercentThreshold>5</SystemDriveErrorPercentThreshold>
          <NonSystemDriveWarningMBytesThreshold>2000</NonSystemDriveWarningMBytesThreshold>
          <NonSystemDriveWarningPercentThreshold>10</NonSystemDriveWarningPercentThreshold>
          <NonSystemDriveErrorMBytesThreshold>1000</NonSystemDriveErrorMBytesThreshold>
          <NonSystemDriveErrorPercentThreshold>5</NonSystemDriveErrorPercentThreshold>
          <NumSamples>4</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis" RunAs="System!System.PrivilegedMonitoringAccount" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$ ($Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/Name$)</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter2>
            <AlertParameter3>$Data/Context/Property[@Name='FilePercentFragmentation']$</AlertParameter3>
            <AlertParameter4>$Data/Context/Property[@Name='OSRecommended']$</AlertParameter4>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="Warning" HealthState="Warning" />
          <OperationalState ID="OverThreshold" MonitorTypeStateID="Success" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <SchedulerStart>03:00</SchedulerStart>
          <SchedulerDaysOfWeekMask>64</SchedulerDaysOfWeekMask>
          <FilePercentFragmentationThreshold>10</FilePercentFragmentationThreshold>
          <UseOSRecommendation>true</UseOSRecommendation>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='AvailableMBytes']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="MemoryAvailableMBytesNormal" HealthState="Success" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="MemoryAvailableMBytesLow" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>900</IntervalSeconds>
          <TimeoutSeconds>300</TimeoutSeconds>
          <TargetComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</TargetComputerName>
          <MemoryThreshold>100</MemoryThreshold>
          <NumSamples>3</NumSamples>
          <CounterName>Available MBytes</CounterName>
          <ObjectName>Memory</ObjectName>
          <InstanceName />
          <AllInstances>false</AllInstances>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% Committed Bytes In Use</CounterName>
          <ObjectName>Memory</ObjectName>
          <InstanceName />
          <Frequency>120</Frequency>
          <Threshold>80</Threshold>
          <Direction>greater</Direction>
          <NumSamples>3</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='PctUsage']$</AlertParameter1>
            <AlertParameter2>$Data/Context/Property[@Name='QueueLength']$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="CPUUtilizationHigh" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="CPUUtilizationNormal" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>900</IntervalSeconds>
          <TimeoutSeconds>300</TimeoutSeconds>
          <TargetComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</TargetComputerName>
          <CPUPercentageThreshold>95</CPUPercentageThreshold>
          <CPUQueueLengthThreshold>15</CPUQueueLengthThreshold>
          <NumSamples>3</NumSamples>
          <CounterName>% Processor Time</CounterName>
          <ObjectName>Processor Information</ObjectName>
          <InstanceName>_Total</InstanceName>
          <AllInstances>false</AllInstances>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% DPC Time</CounterName>
          <ObjectName>Processor Information</ObjectName>
          <InstanceName>_Total</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>95</Threshold>
          <Direction>greater</Direction>
          <NumSamples>5</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% Interrupt Time</CounterName>
          <ObjectName>Processor Information</ObjectName>
          <InstanceName>_Total</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>10</Threshold>
          <Direction>greater</Direction>
          <NumSamples>5</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Avg. Disk sec/Read</CounterName>
          <ObjectName>PhysicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
          <Frequency>60</Frequency>
          <Threshold>0.04</Threshold>
          <Direction>greater</Direction>
          <NumSamples>15</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Avg. Disk sec/Transfer</CounterName>
          <ObjectName>PhysicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
          <Frequency>60</Frequency>
          <Threshold>0.04</Threshold>
          <Direction>greater</Direction>
          <NumSamples>15</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Avg. Disk sec/Write</CounterName>
          <ObjectName>PhysicalDisk</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.PhysicalDisk"]/PerfmonInstance$</InstanceName>
          <Frequency>60</Frequency>
          <Threshold>0.04</Threshold>
          <Direction>greater</Direction>
          <NumSamples>15</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.Processor.CPUUtilization" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor" ParentMonitorID="Microsoft.Windows.Server.10.0.Processor.PerformanceRollup" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.Processor.Monitortype" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="OverThreshold" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="UnderThreshold" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <CounterName>% Processor Time</CounterName>
          <ObjectName>Processor</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.Processor"]/PerfmonInstance$</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>95</Threshold>
          <NumSamples>5</NumSamples>
          <TimeoutSeconds>300</TimeoutSeconds>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor" ParentMonitorID="Microsoft.Windows.Server.10.0.Processor.PerformanceRollup" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.Processor.Monitortype" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="OverThreshold" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="UnderThreshold" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <CounterName>% DPC Time</CounterName>
          <ObjectName>Processor</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.Processor"]/PerfmonInstance$</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>15</Threshold>
          <NumSamples>5</NumSamples>
          <TimeoutSeconds>300</TimeoutSeconds>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor" ParentMonitorID="Microsoft.Windows.Server.10.0.Processor.PerformanceRollup" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.Processor.Monitortype" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="OverThreshold" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="UnderThreshold" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <CounterName>% Interrupt Time</CounterName>
          <ObjectName>Processor</ObjectName>
          <InstanceName>$Target/Property[Type="WindowsServer!Microsoft.Windows.Server.Processor"]/PerfmonInstance$</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>10</Threshold>
          <NumSamples>5</NumSamples>
          <TimeoutSeconds>300</TimeoutSeconds>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalProcessor.CPUUtilization" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% Processor Time</CounterName>
          <ObjectName>Processor</ObjectName>
          <InstanceName>$Target/Property[Type="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor"]/PerfmonInstance$</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>95</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>5</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% DPC Time</CounterName>
          <ObjectName>Processor</ObjectName>
          <InstanceName>$Target/Property[Type="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor"]/PerfmonInstance$</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>15</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>5</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>% Interrupt Time</CounterName>
          <ObjectName>Processor</ObjectName>
          <InstanceName>$Target/Property[Type="ServervNext!Microsoft.Windows.Server.10.0.LogicalProcessor"]/PerfmonInstance$</InstanceName>
          <Frequency>120</Frequency>
          <Threshold>10</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>5</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpaceMonitorRollup" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" ConfirmDelivery="true">
        <Category>Custom</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter2>
            <AlertParameter3>$Data/Context/SampleValue$</AlertParameter3>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderWarningThresholds" MonitorTypeStateID="UnderWarningThresholds" HealthState="Success" />
          <OperationalState ID="OverWarningUnderErrorThresholds" MonitorTypeStateID="OverWarningUnderErrorThresholds" HealthState="Warning" />
          <OperationalState ID="OverErrorThresholds" MonitorTypeStateID="OverErrorThresholds" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <DiskLabel>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</DiskLabel>
          <CounterName>MbFree</CounterName>
          <IntervalSeconds>900</IntervalSeconds>
          <NumSamples>4</NumSamples>
          <SystemDriveWarningThreshold>500</SystemDriveWarningThreshold>
          <SystemDriveErrorThreshold>300</SystemDriveErrorThreshold>
          <NonSystemDriveWarningThreshold>2000</NonSystemDriveWarningThreshold>
          <NonSystemDriveErrorThreshold>1000</NonSystemDriveErrorThreshold>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpaceMonitorRollup" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" ConfirmDelivery="true">
        <Category>Custom</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter2>
            <AlertParameter3>$Data/Context/SampleValue$</AlertParameter3>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderWarningThresholds" MonitorTypeStateID="UnderWarningThresholds" HealthState="Success" />
          <OperationalState ID="OverWarningUnderErrorThresholds" MonitorTypeStateID="OverWarningUnderErrorThresholds" HealthState="Warning" />
          <OperationalState ID="OverErrorThresholds" MonitorTypeStateID="OverErrorThresholds" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <DiskLabel>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</DiskLabel>
          <CounterName>PercentFree</CounterName>
          <IntervalSeconds>900</IntervalSeconds>
          <NumSamples>4</NumSamples>
          <SystemDriveWarningThreshold>10</SystemDriveWarningThreshold>
          <SystemDriveErrorThreshold>5</SystemDriveErrorThreshold>
          <NonSystemDriveWarningThreshold>10</NonSystemDriveWarningThreshold>
          <NonSystemDriveErrorThreshold>5</NonSystemDriveErrorThreshold>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" ConfirmDelivery="false">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter2>
            <AlertParameter3>$Data/Context/Property[@Name='PctFree']$</AlertParameter3>
            <AlertParameter4>$Data/Context/Property[@Name='MbFree']$</AlertParameter4>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="UnderWarningThresholds" MonitorTypeStateID="UnderWarningThresholds" HealthState="Success" />
          <OperationalState ID="OverWarningUnderErrorThresholds" MonitorTypeStateID="OverWarningUnderErrorThresholds" HealthState="Warning" />
          <OperationalState ID="OverErrorThresholds" MonitorTypeStateID="OverErrorThresholds" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>3600</IntervalSeconds>
          <TargetComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</TargetComputerName>
          <SystemDriveWarningMBytesThreshold>500</SystemDriveWarningMBytesThreshold>
          <SystemDriveWarningPercentThreshold>10</SystemDriveWarningPercentThreshold>
          <SystemDriveErrorMBytesThreshold>300</SystemDriveErrorMBytesThreshold>
          <SystemDriveErrorPercentThreshold>5</SystemDriveErrorPercentThreshold>
          <NonSystemDriveWarningMBytesThreshold>2000</NonSystemDriveWarningMBytesThreshold>
          <NonSystemDriveWarningPercentThreshold>10</NonSystemDriveWarningPercentThreshold>
          <NonSystemDriveErrorMBytesThreshold>1000</NonSystemDriveErrorMBytesThreshold>
          <NonSystemDriveErrorPercentThreshold>5</NonSystemDriveErrorPercentThreshold>
          <DiskLabel>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</DiskLabel>
          <TimeoutSeconds>360</TimeoutSeconds>
          <DebugFlag>false</DebugFlag>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='TimeOffset']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="TimeOffsetHigh" HealthState="Error" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="TimeOffsetNormal" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>600</IntervalSeconds>
          <TimeoutSeconds>120</TimeoutSeconds>
          <TargetComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</TargetComputerName>
          <Threshold>60000</Threshold>
          <NumSamples>4</NumSamples>
          <CounterName>Computed Time Offset</CounterName>
          <ObjectName>Windows Time Service</ObjectName>
          <InstanceName />
          <AllInstances>false</AllInstances>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Segments Retransmitted/sec</CounterName>
          <ObjectName>TCPv4</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>10</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Segments Received/sec</CounterName>
          <ObjectName>TCPv4</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>100</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Segments Sent/sec</CounterName>
          <ObjectName>TCPv4</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>100</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Segments Retransmitted/sec</CounterName>
          <ObjectName>TCPv6</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>10</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Segments Received/sec</CounterName>
          <ObjectName>TCPv6</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>100</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" TypeID="SystemPerf!System.Performance.ConsecutiveSamplesThreshold" ConfirmDelivery="false">
        <Category>PerformanceHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters></AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="OverThreshold" MonitorTypeStateID="ConditionTrue" HealthState="Warning" />
          <OperationalState ID="UnderThreshold" MonitorTypeStateID="ConditionFalse" HealthState="Success" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <CounterName>Segments Sent/sec</CounterName>
          <ObjectName>TCPv6</ObjectName>
          <InstanceName />
          <Frequency>300</Frequency>
          <Threshold>100</Threshold>
          <Direction>greaterequal</Direction>
          <NumSamples>12</NumSamples>
        </Configuration>
      </UnitMonitor>
      <DependencyMonitor ID="Microsoft.Windows.Server.10.0.DiskPartition.LogicalDiskAvailabilityRollup" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.DiskPartition" ParentMonitorID="SystemHealth!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="ServervNext!Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk" MemberMonitor="SystemHealth!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
      <DependencyMonitor ID="Microsoft.Windows.Server.10.0.DiskPartition.LogicalDiskPerformanceRollup" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.DiskPartition" ParentMonitorID="SystemHealth!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="ServervNext!Microsoft.Windows.Server.10.0.DiskPartitionContainsLogicalDisk" MemberMonitor="SystemHealth!System.Health.PerformanceState">
        <Category>StateCollection</Category>
        <Algorithm>WorstOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
      <DependencyMonitor ID="Microsoft.Windows.Server.10.0.Processor.LogicalProcessorPerformanceRollup" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor" ParentMonitorID="Microsoft.Windows.Server.10.0.Processor.PerformanceRollup" Remotable="true" Priority="Normal" RelationshipType="ServervNext!Microsoft.Windows.Server.10.0.ProcessorHostsLogicalProcessor" MemberMonitor="SystemHealth!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>BestOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
    </Monitors>
    <Diagnostics>
      <Diagnostic ID="Microsoft.Windows.Server.10.0.OperatingSystem.TopCPUUsage.Diagnostic" Comment="List Top CPU Consuming processes." Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Monitor="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="WindowsServer!Microsoft.Windows.Server.TopCPUUsage.ProbeAction.PowerShell">
          <IntervalMilliseconds>2000</IntervalMilliseconds>
          <NumSamples>5</NumSamples>
        </ProbeAction>
      </Diagnostic>
      <Diagnostic ID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Diagnostic" Accessibility="Public" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Monitor="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor" ExecuteOnState="Warning" Remotable="true" Timeout="300">
        <Category>ConfigurationHealth</Category>
        <ProbeAction ID="Probe" TypeID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.ModuleType">
          <IncludeCompliant>true</IncludeCompliant>
        </ProbeAction>
      </Diagnostic>
      <Diagnostic ID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Diagnostic" Comment="List all Max Concurrent API. performance data" Accessibility="Public" Enabled="true" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Monitor="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Maintenance</Category>
        <ProbeAction ID="PA" TypeID="WindowsServer!Microsoft.Windows.Server.MaxConcurrentAPI.Probe">
          <DiagnosticMode>1</DiagnosticMode>
          <TimeoutSeconds>300</TimeoutSeconds>
          <ThresholdWaiters>50</ThresholdWaiters>
          <ThresholdTimeouts>2000</ThresholdTimeouts>
        </ProbeAction>
      </Diagnostic>
    </Diagnostics>
    <Recoveries>
      <Recovery ID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Recovery" Accessibility="Internal" Enabled="false" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Monitor="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis" ResetMonitor="true" ExecuteOnState="Warning" Remotable="true" Timeout="3600">
        <Category>Maintenance</Category>
        <WriteAction ID="Defrag" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
          <ScriptName>Microsoft.Windows.Server.LogicalDisk.Defrag.ps1</ScriptName>
          <ScriptBody>
                  
  param ($TargetComputer, $DiskLabel)
  
$ErrorActionPreference = "Stop"

# Event type constants
$EVENT_TYPE_LOG = 0
$EVENT_TYPE_ERROR = 1
$EVENT_TYPE_WARNING = 2
$EVENT_TYPE_INFORMATION = 4

# Typed property bag constants
$PROPERTY_TYPE_ALERT = 0
$PROPERTY_TYPE_EVENT = 1
$PROPERTY_TYPE_PERFORMANCE = 2
$PROPERTY_TYPE_STATE = 3

# State type constants
$STATE_SUCCESS = "Success"
$STATE_WARNING = "Warning"
$STATE_ERROR = "Error"

$momAPI = New-Object -ComObject Mom.ScriptAPI 
if ($null -eq $momAPI)
{
   exit -1
}

Function Load-CimModules
{
	$ErrorActionPreference = 'SilentlyContinue' 
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets

	}
}

Load-CimModules
# WMI Constant
$wbemCimtypeUseDefault        = 0   #Use Default Type CIM type - Custom
$wbemCimtypeSint16            = 2   #Signed 16-bit integer 
$wbemCimtypeSint32            = 3   #Signed 32-bit integer 
$wbemCimtypeReal32            = 4   #32-bit real number 
$wbemCimtypeReal64            = 5   #64-bit real number 
$wbemCimtypeString            = 8   #String 
$wbemCimtypeBoolean           = 11  #Boolean value 
$wbemCimtypeObject            = 13  #CIM object 
$wbemCimtypeSint8             = 16  #Signed 8-bit integer 
$wbemCimtypeUint8             = 17  #Unsigned 8-bit integer 
$wbemCimtypeUint16            = 18  #Unsigned 16-bit integer 
$wbemCimtypeUint32            = 19  #Unsigned 32-bit integer 
$wbemCimtypeSint64            = 20  #Signed 64-bit integer  
$wbemCimtypeUint64            = 21  #Unsigned 64-bit integer 
$wbemCimtypeDatetime          = 101 #Date/time value 
$wbemCimtypeReference         = 102 #Reference to a CIM object 
$wbemCimtypeChar16            = 103 #16-bit character 

$ErrAction_None               = 0
$ErrAction_Trace              = 1
$ErrAction_ThrowError         = 16
$ErrAction_Abort              = 32
$ErrAction_ThrowErrorAndAbort = 48

$DISKSIZE_BYTES_IN_MB = 1048576

$g_ErrorEventNumber = 4001
$g_TraceEventNumber = 4002
$g_DebugFlag = $false

#---------------------------------------------------------------------------
# Returns WMI Instance requested. Tries to execute WMI query a N times.
#---------------------------------------------------------------------------
Function WMIGetInstanceExTryN
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery, 
           [int]$N)

    for ($i = 0; $i -lt $N; $i++)
    {
        $error.Clear();
        
		Load-CimModules
		try
        {
		    $cimSessionOption = New-CimSessionOption -Protocol DCOM
		    $cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
            $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
        }
        catch
        {
             $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
        }
        Finally
        {
            Get-CimSession | Remove-CimSession
		    $cimsession =$null
		    $cimSessionOption = $null 
        }

        if ($error.Count -gt 0)
        {
            if ($i -eq ($N-1))
            {
                ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
            }
        }
        else
        {
            break;
        }
        sleep -m 1000
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceEx
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    $error.Clear();

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
            $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The class name '" + $sInstanceQuery + "' returned no instances.  Please check to see if this is a valid WMI class name.") $error[0]
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Connect to WMI.
#---------------------------------------------------------------------------
Function WMIConnect
{
    param ([string]$sTargetComputer,
           [string]$sNamespace)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
    
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg $error[0]
    }
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstance
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)

    WMIConnect $sTargetComputer $sNamespace
    $oInstance = WMIGetInstanceEx $sTargetComputer $sNamespace $sInstanceQuery
    return $oInstance
}

#---------------------------------------------------------------------------
# Returns WMI Instance requested.
#---------------------------------------------------------------------------
Function WMIGetInstanceNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sInstanceQuery)


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oInstance = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue
    }
    catch
    {
        $oInstance = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query ("Select * from "+$sInstanceQuery) -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oInstance
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set.
#---------------------------------------------------------------------------
Function WMIExecQuery
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)

    $error.Clear()

    # !!! Refactoring comment: 
    # Original VBScript only tries to connect to the namespace. Piping to get only the first one saves time. 
	Load-CimModules
	try
	{
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
		$oWMI = Get-CimClass -CimSession $cimsession -Namespace $sNamespace -ErrorAction SilentlyContinue | select -First 1
	}
	Finally
	{
		Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
	}
    if ($error.Count -gt 0)
    {
        $msg = "Unable to open WMI Namespace 'winmgmts:\\" + $sTargetComputer + "\" + $sNamespace + "'. Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists."
        ThrowScriptError $msg, $error[0]
    }


	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    if ($error.Count -gt 0)
    {
        ThrowScriptError ("The Query '" + $sQuery + "' returned an invalid result set.  Please check to see if this is a valid WMI Query.") $error[0]
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Executes the WMI query and returns the result set, no abort version.
#---------------------------------------------------------------------------
Function WMIExecQueryNoAbort
{
    param ([string]$sTargetComputer,
           [string]$sNamespace,
           [string]$sQuery)    
    

	Load-CimModules
	try
    {
		$cimSessionOption = New-CimSessionOption -Protocol DCOM
		$cimsession = New-CimSession -ComputerName $sTargetComputer -SessionOption $cimSessionOption 
        $oQuery = Get-CimInstance -CimSession $cimsession -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue
    }
    catch
    {
        $oQuery = Get-WMIObject -ComputerName $sTargetComputer -Namespace $sNamespace -Query $sQuery -ErrorAction SilentlyContinue 
    }
    Finally
    {
        Get-CimSession | Remove-CimSession
		$cimsession =$null
		$cimSessionOption = $null 
    }

    return $oQuery
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptErrorNoAbort
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    # Retrieve the name of this (running) script
    $ScriptFileName = $MyInvocation.ScriptName
    
    if ($oErr -ne $null)
    {
        $sMessage = $sMessage + ". " + $oErr.ErrorDetails
    }
    
    $momAPI.LogScriptEvent($ScriptFileName, $g_ErrorEventNumber, $EVENT_TYPE_ERROR, $sMessage)
    
    Write-Host $sMessage
}

#---------------------------------------------------------------------------
# Creates an event and sends it back to the mom server.
#---------------------------------------------------------------------------
Function ThrowScriptError
{
    param ([string]$sMessage, 
           [System.Management.Automation.ErrorRecord]$oErr)
    ThrowScriptErrorNoAbort $sMessage $oErr
    exit
}

#---------------------------------------------------------------------------
# Verifies that number of arguments is correct
#---------------------------------------------------------------------------
Function VerifyNumberOfArguments
{
    param ($NumberOfArguments)

    if ($args.Length -ne $NumberOfArguments)
    {
       $sArgs = ""
       foreach ($argument in $args)
       {
           $sArgs += " {" + $argument + "}"
       }
       ThrowScriptError ("Invalid number of arguments (" + $args.Length + " instead of " + $NumberOfArguments + "). Arguments:" + $sArgs) $null
    }
}

#---------------------------------------------------------------------------
# Outputs to file and echo for debugging purposes
#---------------------------------------------------------------------------
Function TraceLogMessage
{
    param ([string]$sMessage)

    Write-Host $sMessage
    
    If ($g_DebugFlag -eq $true)
    {
        # Retrieve the name of this (running) script
        $ScriptFileName = $MyInvocation.ScriptName
        
        $momAPI.LogScriptEvent($ScriptFileName, $g_TraceEventNumber, $EVENT_TYPE_INFORMATION, $sMessage)
    }
}

#---------------------------------------------------------------------------
# Verifies the expression. If equals to False then generates an error and quits the script
#   Usage:
#     Verify Not WMISet Is Nothing, "WMISet is invalid!"
#     Verify WMISet.Count = 1, "Invalid quantity of services with name 'Server' (qty = " &amp; WMISet.Count &amp; ")."
#---------------------------------------------------------------------------
Function Verify
{
    param ([bool]$bBool, 
           [string]$sMessage)

    If ($bBool -eq $false)
    {
        ThrowScriptError $sMessage $null
    }
}

Function GetRegistryKeyValue
{
    param ([string]$keyPath, 
           [string]$key)

    $error.Clear()

    $strKeyValue = Get-ItemProperty -Path $keyPath -Name $key -ErrorAction SilentlyContinue
    if ($error.Count -gt 0)
    {
        ThrowScriptError ("An error occurred while reading the registry: '" + $keyPath + $key + "'") $error[0]
    }
    return $strKeyValue.$key
}


#---------------------------------------------------------------------------
# Function: ExpressedInMB
#   Usage:
#     Parameter (SizeInBytes) 
#     Returns the Size Expressed in MBytes
#---------------------------------------------------------------------------
Function ExpressedInMB
{
    param ($SizeInBytes)

    $NumberSizeExpInMB = [math]::Round($SizeInBytes / $DISKSIZE_BYTES_IN_MB, 0)
    return $NumberSizeExpInMB
}

Function Is_Win32_Volume_Supported($TargetComputer)
{
    $blnRet = $false
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = Is_NanoServer
	
	if ($true -eq $IsNano)
	{
		return $blnRet #NanoServer does not support Win32_Volume
	}

    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        if ([int]$objWMIOS.BuildNumber -ge 3624) 
		{
			 $blnRet = $true 
		}
    }

    return $blnRet
}

Function Get_System_Drive($TargetComputer)
{
    $objWMISet = WMIGetInstance $TargetComputer "root\cimv2" "Win32_OperatingSystem"
    foreach ($objWMIOS in $objWMISet)
    {
        return $objWMIOS.SystemDirectory.SubString(0,2)
    }
}

Function Is_NanoServer
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()
	$IsNano = (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels").GetValue("NanoServer")
	
	$IsNano = $IsNano -eq 1

	$error.Clear()

	return $IsNano

}

#---------------------------------------------------------------------------
# Function: StripEndChar
#   Usage:
#     Parameter (sName) 
#     Returns the sName without last special Character "\"
#---------------------------------------------------------------------------
Function StripEndChar([string]$sName)
{
    if ([string]::IsNullOrEmpty($sName))
    { 
        return [string]::Empty
    }
    else
    {
        return $sName.Substring(0, $sName.Length-1)
    }
}

Function Load-Module ([string] $ModuleName)
{
	if ([string]::IsNullOrEmpty($ModuleName) )
	{
		return $false
	}

	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$retval = $false
	$cim = Get-Module -Name $ModuleName

	########Check for powershell 1.0
	if ($error.Count -ne 0)
	{
	   $type = $error[0].Exception.GetType()
	   if ([System.Management.Automation.CommandNotFoundException] -eq $type)
	   {
		   $error.Clear()
		   return $retval
	   }

       $error.Clear()
	}

	if ($null -eq $cim)
	{
			Import-Module $ModuleName
		    if ($error.Count -eq 0)
		    {
				$retval = $true
			}
			
		   $error.Clear()
	}
	else
	    {
			$retval = $true
		}

	return $retval


}

Function Get-Volumes([bool]$IsNano,[bool]$IsVolumeSupported,[string] $TargetComputer)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	$oVolumes = $null

	if ($true -eq $IsNano)
	{
		$bLoadModule = Load-Module -ModuleName "Storage"
		if($false -eq $bLoadModule)
        {
			return $null
		} 

		$oVolumes =  Get-Volume | where {$_.DriveType -eq "Fixed" -and $false -eq [string]::IsNullOrEmpty($_.FileSystem )}
	}
	else 
		{
			if ($true -eq $IsVolumeSupported)
			{
				 $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_Volume where (DriveType=3) and FileSystem!=null" 
			}
			else
			   {
				   $oVolumes = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_LogicalDisk where (DriveType=3) and FileSystem!=null"  
			   }
		}

	return $oVolumes
} 

Function Get-VolumeId([bool]$IsNano,[bool]$IsVolumeSupported,$Volume)
{
	$ErrorActionPreference="SilentlyContinue"
	$error.Clear()

	if ($null -eq $Volume)
	{
		return $null
	}

	if ($true -eq $IsVolumeSupported)
	{
		$VolumeId = $Volume.DriveLetter
		if([string]::IsNullOrEmpty($VolumeId) )
		{
			$VolumeId = StripEndChar -sName $Volume.Name 
		}
	}
	else
	    {
			if ($true -eq $IsNano )
			{
				$VolumeId = $Volume.DriveLetter
				if([string]::IsNullOrEmpty($VolumeId) )
				{
					$VolumeId = StripEndChar -sName $Volume.UniqueId 
				}
				else
				{
					if (1 -eq $VolumeId.Length)
					{
						$VolumeId = $VolumeId + ":" 
					}
				}
			}
			else
			    {
					$VolumeId = $Volume.DeviceId
				}
			
		}

	return $VolumeId
} 

Function CreatePerformanceCounterData($strObjectName, $strCounterName, $strInstanceName, $varValue)
{

									return @{ "PerfObject"  = $strObjectName;
                                             "PerfCounter"  = $strCounterName;
                                             "PerfInstance" = $strInstanceName;
                                             "PerfValue"     =  $varValue;
                                             }
}

Function Create-PerformancePropertyBag ($strObjectName, $strCounterName, $strInstanceName, $varValue,$objMomScriptAPI)
{
				$ErrorActionPreference = "SilentlyContinue"
				$error.Clear()

				if ([string]::IsNullOrEmpty($varValue))
	            {
					$varValue = 0
				}	

	            if ($null -eq $objMomScriptAPI)
				{
					return
				}

				$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

				$objTypedPropertyBag.AddValue("PerfObject"   ,$strObjectName)
				$objTypedPropertyBag.AddValue("PerfCounter"  ,$strCounterName)
				$objTypedPropertyBag.AddValue("PerfInstance" ,$strInstanceName)
				$objTypedPropertyBag.AddValue("PerfValue"    ,$varValue)
				$objTypedPropertyBag

     
}

Function Create-EmptyPerfData ($objMomScriptAPI)
{
	 if ($null -eq $objMomScriptAPI)
  	 {
		return
 
	 }

		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()
		$objTypedPropertyBag = $objMomScriptAPI.CreateTypedPropertyBag($PROPERTY_TYPE_PERFORMANCE)

		$objTypedPropertyBag.AddValue("PerfObject"   ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfCounter"  ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfInstance" ,"EMPTY")
		$objTypedPropertyBag.AddValue("PerfValue"    ,"EMPTY")

		#Add the property bag to the script#s XML output
		$objTypedPropertyBag
	   
	   $error.Clear()
}

Function Convert-ToBoolean([string] $sBool)
 {
    [bool] $result  = $false
    [bool] $iresult = $false

    if ($false -eq [string]::IsNullOrEmpty($sBool) )
    {
       $result  = $sBool.Equals("true",[System.StringComparison]::InvariantCultureIgnoreCase)
       $iresult = $sBool.Equals("1",[System.StringComparison]::InvariantCultureIgnoreCase)
       $result  = $result -or $iresult
    }
    
    return $result
 }

 Function Unload-Module([string]$ModuleName)
 {
		$ErrorActionPreference = 'SilentlyContinue' # Scoped only to function
		$error.Clear()

	    if ([string]::IsNullOrEmpty($ModuleName))
		{
			return
		}

	    $module = Get-Module $ModuleName  
	    if ($null -eq $module)
		{
		   return
		}

		Remove-Module -Name $ModuleName -Force 
 }

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
#Copyright (c) Microsoft Corporation. All rights reserved.
                      
# Parameters that should be passed to this script
# 0 Computer (FQDN)
# 1 Logical Drive Letter

Function Main()
{   
    # Fragmentation analysis requires lots of time and consumes lots of CPU.
    # So it is important to trace such activity in events log in order to be able
    # to understand what is going on.
    $g_DebugFlag = $true

	$IsMsftVolumeSupported = Is_MSFT_Volume_Supported_On_NanoServer $TargetComputer
	$IsVolumeInfoSupported = Is_Win32_Volume_Supported $TargetComputer

	if ($IsMsftVolumeSupported -eq $true) # Win32_Volume is not supported on NanoServer
	{
		Start-DefragOnNano -TargetComputer $TargetComputer -DiskLabel $DiskLabel
	}
	else
       {
		   if ($false -eq $IsVolumeInfoSupported)
			{ 
				TraceLogMessage ("This Operating System doesn't support volumes WMI class.")
				return
			}
           
		    Start-Defrag -TargetComputer $TargetComputer -DiskLabel $DiskLabel
	   }
   
    Unload-Module -ModuleName "CimCmdLets"
}



Function Is_MSFT_Volume_Supported_On_NanoServer($TargetComputer)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$bRet = $false
	$IsNano = Is_NanoServer 
	if ($true -eq $IsNano)
	{
		Load-CimModules
		try
		{
	 		$cimSessionOption = New-CimSessionOption -Protocol DCOM
	 		$cimsession = New-CimSession -SessionOption $cimSessionOption 
	 		$oWMI = Get-CimClass -CimSession $cimsession -NameSpace "root\microsoft\windows\storage" MSFT_Volume -ErrorAction SilentlyContinue
		}
		Finally
		{
	 		Get-CimSession | Remove-CimSession
	 		$cimsession =$null
	 		$cimSessionOption = $null 
		}
		if ($oWMI -ne $null)
		{
	 		$bRet = $true
		}
	}

	return $bRet
}

Function Start-DefragOnNano($TargetComputer,$DiskLabel)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$IsDiskFound = $false

		$oWmiDiskSet = WMIGetInstanceNoAbort $TargetComputer "root\microsoft\windows\storage" "MSFT_Volume WHERE (DriveType=3 or DriveType=6) and FileSystem!=null"
		foreach ($oWmiDisk in $oWmiDiskSet)
		{
			$sDriveLetter = $oWmiDisk.DriveLetter
			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				$sDriveLetter = $oWmiDisk.UniqueId
			}
			else
				{
				   $sDriveLetter = $oWmiDisk.DriveLetter + ":" # MSFT_Volume only has "C" instead of "C:" as DriveLetter
				}

			if ($sDriveLetter -ieq $DiskLabel)
			{
					TraceLogMessage ("Perform Defragmentation (disk: " + $DiskLabel + "; computer: " + $TargetComputer + ").")
					$error.Clear()
					Load-CimModules
					try
					{
						$cimSessionOption = New-CimSessionOption -Protocol DCOM
						$cimsession = New-CimSession -SessionOption $cimSessionOption 
						$ret = Invoke-CimMethod -CimSession $cimsession -CimInstance $oWmiDisk -MethodName Optimize -Arguments @{ReTrim=$false;Analyze=$false;Defrag=$true;SlabConsolidate=$false;TierOptimize=$false} -ErrorAction SilentlyContinue
					}
					Finally
					{
						Get-CimSession | Remove-CimSession
						$cimsession =$null
						$cimSessionOption = $null 
					}
					TraceLogMessage ("Defragmentation completed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + ").")
            
					If ($ret.ReturnValue -ne 0 -or $error.Count -ne 0)
					{
							ThrowScriptError ("Defrag failed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). Return code: " + $ret.ReturnValue + ".") $error[0]
					}

					$IsDiskFound = $true
					break
		   }
 
		}

        if ($false -eq $IsDiskFound)
		{
		   		TraceLogMessage ("ERROR: Could not find a disk (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). In cluster environment this might occur when disk does not belong to current computer anymore.")
		}

		return

}

Function Start-Defrag($TargetComputer,$DiskLabel)
{
	$ErrorActionPreference = "SilentlyContinue"
	$error.Clear()
	$IsDiskFound = $false

    $oWmiDiskSet = WMIGetInstanceNoAbort $TargetComputer "root\cimv2" "Win32_Volume WHERE (DriveType=3 or DriveType=6) and FileSystem!=null"

		foreach ($oWmiDisk in $oWmiDiskSet)
		{
			$sDriveLetter = $oWmiDisk.DriveLetter
			if ([string]::IsNullOrEmpty($sDriveLetter))
			{
				            $sDriveLetter = $oWmiDisk.Name
							$sDriveLetter = StripEndChar -sName $sDriveLetter
			}

			if ($sDriveLetter -ieq $DiskLabel)
			{
					TraceLogMessage ("Perform Defragmentation (disk: " + $DiskLabel + "; computer: " + $TargetComputer + ").")
					$error.Clear()
					Load-CimModules
					try
					{
						$cimSessionOption = New-CimSessionOption -Protocol DCOM
						$cimsession = New-CimSession -SessionOption $cimSessionOption 
						$ret = Invoke-CimMethod -CimSession $cimsession -CimInstance $oWmiDisk -MethodName Defrag -Arguments @{Force=$false} -ErrorAction SilentlyContinue
					}
					Finally
					{
						Get-CimSession | Remove-CimSession
						$cimsession =$null
						$cimSessionOption = $null 
					}
		            TraceLogMessage ("Defragmentation completed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "): FilePercentFragmentation = " + $ret.DefragAnalysis.FilePercentFragmentation + ".")
            
					If ($ret.ReturnValue -ne 0 -or $error.Count -ne 0)
					{
							ThrowScriptError ("Defrag failed (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). Return code: " + $ret.ReturnValue + ".") $error[0]
					}

					$IsDiskFound = $true
					break
		   }
 
		}

        if ($false -eq $IsDiskFound)
		{
		   		TraceLogMessage ("ERROR: Could not find a disk (disk: " + $DiskLabel + "; computer: " + $TargetComputer + "). In cluster environment this might occur when disk does not belong to current computer anymore.")
		}

		return

}

Function Load-CimModules
{
	$error.Clear()

	$CimModule = Get-Module CimCmdlets

	if ($null -eq $CimModule)
	{
			Import-Module CimCmdlets
			$error.Clear()
	}
}
Main
</ScriptBody>
          <Parameters>
            <Parameter>
              <Name>TargetComputer</Name>
              <Value>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Value>
            </Parameter>
            <Parameter>
              <Name>DiskLabel</Name>
              <Value>$Target/Property[Type="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Value>
            </Parameter>
          </Parameters>
          <TimeoutSeconds>3600</TimeoutSeconds>
        </WriteAction>
      </Recovery>
    </Recoveries>
  </Monitoring>
  <PresentationTypes>
    <UIPageSets>
      <UIPageSet ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet" TypeDefinitionID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype">
        <UIPageReferences>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference1" PageID="SystemHealth!System.Health.MonitorGeneralPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference2" PageID="System!System.SimpleSchedulerPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="SimpleReccuringSchedule">
                    <xsl:element name="Interval">
                      <xsl:value-of select="IntervalSeconds" />
                    </xsl:element>
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference3" PageID="SystemPerf!System.Performance.ThresholdPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="Threshold">
                    <xsl:value-of select="CPUPercentageThreshold" />
                  </xsl:element>
                  <xsl:element name="Direction">greaterthan</xsl:element>
                  <xsl:copy-of select="NumSamples" />
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
            <TabName ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference3.TabName" />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference4" PageID="SystemPerf!System.Performance.ThresholdComparisonPage">
            <InputParameters>
              <ValidOperators>
                <Operator>greater</Operator>
                <Operator>greaterequal</Operator>
                <Operator>less</Operator>
                <Operator>lessequal</Operator>
              </ValidOperators>
            </InputParameters>
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="Threshold">
                    <xsl:value-of select="CPUQueueLengthThreshold" />
                  </xsl:element>
                  <xsl:element name="Operator">greater</xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
            <TabName ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference4.TabName" />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference5" PageID="SystemHealth!System.Health.OperationalStatesConfigPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference6" PageID="SystemHealth!System.Health.AlertingPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference7" PageID="SystemHealth!System.Health.DiagnosticAndRecoveryPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference8" PageID="SystemHealth!System.Health.ProductKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference9" PageID="SystemHealth!System.Health.CompanyKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
        </UIPageReferences>
      </UIPageSet>
      <UIPageSet ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet" TypeDefinitionID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype">
        <UIPageReferences>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference1" PageID="SystemHealth!System.Health.MonitorGeneralPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference2" PageID="System!System.SimpleSchedulerPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="SimpleReccuringSchedule">
                    <xsl:element name="Interval">
                      <xsl:value-of select="IntervalSeconds" />
                    </xsl:element>
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference3" PageID="SystemPerf!System.Performance.DoubleThresholdPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="Threshold1">
                    <xsl:value-of select="SystemDriveErrorPercentThreshold" />
                  </xsl:element>
                  <xsl:element name="Threshold2">
                    <xsl:value-of select="SystemDriveWarningPercentThreshold" />
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
            <TabName ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference3.TabName" />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference4" PageID="SystemPerf!System.Performance.DoubleThresholdPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="Threshold1">
                    <xsl:value-of select="SystemDriveErrorMBytesThreshold" />
                  </xsl:element>
                  <xsl:element name="Threshold2">
                    <xsl:value-of select="SystemDriveWarningMBytesThreshold" />
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
            <TabName ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference4.TabName" />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference5" PageID="SystemPerf!System.Performance.DoubleThresholdPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="Threshold1">
                    <xsl:value-of select="NonSystemDriveErrorPercentThreshold" />
                  </xsl:element>
                  <xsl:element name="Threshold2">
                    <xsl:value-of select="NonSystemDriveWarningPercentThreshold" />
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
            <TabName ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference5.TabName" />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference6" PageID="SystemPerf!System.Performance.DoubleThresholdPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="Threshold1">
                    <xsl:value-of select="NonSystemDriveErrorMBytesThreshold" />
                  </xsl:element>
                  <xsl:element name="Threshold2">
                    <xsl:value-of select="NonSystemDriveWarningMBytesThreshold" />
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
            <TabName ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference6.TabName" />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference7" PageID="SystemHealth!System.Health.OperationalStatesConfigPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference8" PageID="SystemHealth!System.Health.AlertingPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference9" PageID="SystemHealth!System.Health.DiagnosticAndRecoveryPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference10" PageID="SystemHealth!System.Health.ProductKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference11" PageID="SystemHealth!System.Health.CompanyKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
        </UIPageReferences>
      </UIPageSet>
      <UIPageSet ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet" TypeDefinitionID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype">
        <UIPageReferences>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet.PageReference1" PageID="SystemHealth!System.Health.MonitorGeneralPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet.PageReference2" PageID="System!System.SimpleSchedulerPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="SimpleReccuringSchedule">
                    <xsl:element name="Interval">
                      <xsl:value-of select="IntervalSeconds" />
                    </xsl:element>
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet.PageReference5" PageID="SystemHealth!System.Health.OperationalStatesConfigPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet.PageReference6" PageID="SystemHealth!System.Health.AlertingPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet.PageReference7" PageID="SystemHealth!System.Health.DiagnosticAndRecoveryPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet.PageReference8" PageID="SystemHealth!System.Health.ProductKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype.PageSet.PageReference9" PageID="SystemHealth!System.Health.CompanyKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
        </UIPageReferences>
      </UIPageSet>
      <UIPageSet ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet" TypeDefinitionID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype">
        <UIPageReferences>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference1" PageID="SystemHealth!System.Health.MonitorGeneralPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference2" PageID="System!System.SimpleSchedulerPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:element name="SimpleReccuringSchedule">
                    <xsl:element name="Interval">
                      <xsl:value-of select="IntervalSeconds" />
                    </xsl:element>
                  </xsl:element>
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference3" PageID="SystemPerf!System.Performance.NumSamplesPage">
            <InputParameters />
            <InputTransform>
              <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
                <xsl:output method="xml" indent="yes" omit-xml-declaration="yes" />
                <xsl:template match="/">
                  <xsl:copy-of select="NumSamples" />
                </xsl:template>
              </xsl:stylesheet>
            </InputTransform>
            <TabName ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference3.TabName" />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference4" PageID="SystemHealth!System.Health.OperationalStatesConfigPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference5" PageID="SystemHealth!System.Health.AlertingPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference6" PageID="SystemHealth!System.Health.DiagnosticAndRecoveryPage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference7" PageID="SystemHealth!System.Health.ProductKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
          <UIPageReference ID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference8" PageID="SystemHealth!System.Health.CompanyKnowledgePage">
            <InputParameters />
            <InputTransform />
          </UIPageReference>
        </UIPageReferences>
      </UIPageSet>
    </UIPageSets>
  </PresentationTypes>
  <Presentation>
    <ConsoleTasks>
      <ConsoleTask ID="Microsoft.Windows.Server.10.0.DiskPartition.ComputerManagement.Task" Accessibility="Public" Target="ServervNext!Microsoft.Windows.Server.10.0.DiskPartition" RequireOutput="false" Category="MonitoringObject">
        <Application>%windir%\system32\mmc.exe</Application>
        <Parameters>
          <Parameter>%windir%\system32\compmgmt.msc</Parameter>
          <Parameter>/computer:$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Parameter>
        </Parameters>
        <WorkingDirectory />
      </ConsoleTask>
      <ConsoleTask ID="Microsoft.Windows.Server.10.0.LogicalDisk.ComputerManagement.Task" Accessibility="Public" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" RequireOutput="false" Category="MonitoringObject">
        <Application>%windir%\system32\mmc.exe</Application>
        <Parameters>
          <Parameter>%windir%\system32\compmgmt.msc</Parameter>
          <Parameter>/computer:$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Parameter>
        </Parameters>
        <WorkingDirectory />
      </ConsoleTask>
      <ConsoleTask ID="Microsoft.Windows.Server.10.0.NetworkAdapter.ComputerManagement.Task" Accessibility="Public" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" RequireOutput="false" Category="MonitoringObject">
        <Application>%windir%\system32\mmc.exe</Application>
        <Parameters>
          <Parameter>%windir%\system32\compmgmt.msc</Parameter>
          <Parameter>/computer:$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Parameter>
        </Parameters>
        <WorkingDirectory />
      </ConsoleTask>
      <ConsoleTask ID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task" Accessibility="Public" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" RequireOutput="false" Category="MonitoringObject">
        <Application>%windir%\system32\mmc.exe</Application>
        <Parameters>
          <Parameter>%windir%\system32\compmgmt.msc</Parameter>
          <Parameter>/computer:$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Parameter>
        </Parameters>
        <WorkingDirectory />
      </ConsoleTask>
      <ConsoleTask ID="Microsoft.Windows.Server.10.0.PhysicalDisk.ComputerManagement.Task" Accessibility="Public" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk" RequireOutput="false" Category="MonitoringObject">
        <Application>%windir%\system32\mmc.exe</Application>
        <Parameters>
          <Parameter>%windir%\system32\compmgmt.msc</Parameter>
          <Parameter>/computer:$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Parameter>
        </Parameters>
        <WorkingDirectory />
      </ConsoleTask>
      <ConsoleTask ID="Microsoft.Windows.Server.10.0.Processor.ComputerManagement.Task" Accessibility="Public" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor" RequireOutput="false" Category="MonitoringObject">
        <Application>%windir%\system32\mmc.exe</Application>
        <Parameters>
          <Parameter>%windir%\system32\compmgmt.msc</Parameter>
          <Parameter>/computer:$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</Parameter>
        </Parameters>
        <WorkingDirectory />
      </ConsoleTask>
    </ConsoleTasks>
    <Views>
      <View ID="Microsoft.Windows.Server.10.0.NetworkAdapterUtilization.Dashboard.View" Accessibility="Public" Enabled="true" Target="System!System.Entity" TypeID="SC!Microsoft.SystemCenter.DashboardViewType" Visible="true">
        <Category>Operations</Category>
        <PanelConfiguration Columns="2" Rows="2">
          <Cell Column="1" Row="1" ViewID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesReceivedsec.View" />
          <Cell Column="2" Row="1" ViewID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesSentsec.View" />
          <Cell Column="1" Row="2" ColumnSpan="2" ViewID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesTotalsec.View" />
        </PanelConfiguration>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.DiskPartition.State.DetailsView" Target="ServervNext!Microsoft.Windows.Server.10.0.DiskPartition" TypeID="SC!Microsoft.SystemCenter.StateDetailDefinitionViewType" Visible="true" Accessibility="Internal">
        <Category>Operations</Category>
        <Monitors>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.PerformanceState"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.DiskPartition.LogicalDiskPerformanceRollup"]$</Monitor>
        </Monitors>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.LogicalDisk.State.DetailsView" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" TypeID="SC!Microsoft.SystemCenter.StateDetailDefinitionViewType" Visible="true" Accessibility="Internal">
        <Category>Operations</Category>
        <Monitors>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.AvailabilityState"]$</Monitor>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.PerformanceState"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer"]$</Monitor>
        </Monitors>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.NetworkAdapter.State.DetailsView" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" TypeID="SC!Microsoft.SystemCenter.StateDetailDefinitionViewType" Visible="true" Accessibility="Internal">
        <Category>Operations</Category>
        <Monitors>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.AvailabilityState"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth"]$</Monitor>
        </Monitors>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.OperatingSystem.State.DetailsView" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" TypeID="SC!Microsoft.SystemCenter.StateDetailDefinitionViewType" Visible="true" Accessibility="Internal">
        <Category>Operations</Category>
        <Monitors>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.AvailabilityState"]$</Monitor>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.ConfigurationState"]$</Monitor>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.PerformanceState"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization"]$</Monitor>
        </Monitors>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.PhysicalDisk.State.DetailsView" Target="ServervNext!Microsoft.Windows.Server.10.0.PhysicalDisk" TypeID="SC!Microsoft.SystemCenter.StateDetailDefinitionViewType" Visible="true" Accessibility="Internal">
        <Category>Operations</Category>
        <Monitors>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.PerformanceState"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer"]$</Monitor>
        </Monitors>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.Processor.State.DetailsView" Target="ServervNext!Microsoft.Windows.Server.10.0.Processor" TypeID="SC!Microsoft.SystemCenter.StateDetailDefinitionViewType" Visible="true" Accessibility="Internal">
        <Category>Operations</Category>
        <Monitors>
          <Monitor>$MPElement[Name="SystemHealth!System.Health.PerformanceState"]$</Monitor>
          <Monitor>$MPElement[Name="Microsoft.Windows.Server.10.0.Processor.CPUUtilization"]$</Monitor>
        </Monitors>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesReceivedsec.View" TypeID="SC!Microsoft.SystemCenter.PerformanceViewType" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" Visible="true" Accessibility="Public">
        <Category>Operations</Category>
        <Criteria>
          <Object>Network Adapter</Object>
          <Instance />
          <Counter>Bytes Received/sec</Counter>
        </Criteria>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesSentsec.View" TypeID="SC!Microsoft.SystemCenter.PerformanceViewType" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" Visible="true" Accessibility="Public">
        <Category>Operations</Category>
        <Criteria>
          <Object>Network Adapter</Object>
          <Instance />
          <Counter>Bytes Sent/sec</Counter>
        </Criteria>
      </View>
      <View ID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesTotalsec.View" TypeID="SC!Microsoft.SystemCenter.PerformanceViewType" Target="ServervNext!Microsoft.Windows.Server.10.0.NetworkAdapter" Visible="true" Accessibility="Public">
        <Category>Operations</Category>
        <Criteria>
          <Object>Network Adapter</Object>
          <Instance />
          <Counter>Bytes Total/sec</Counter>
        </Criteria>
      </View>
    </Views>
    <FolderItems>
      <FolderItem ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterUtilization.Dashboard.View" Folder="WindowsServer!Microsoft.Windows.Server.ViewFolder.Performance" />
    </FolderItems>
    <StringResources>
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogFull.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.IPAddressConflict.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.LDMCantReadDisk.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSDelayedWriteLost.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSFileSystemCorrupt.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.PerfCounterDataRequestTimeOut.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.PerformanceRegistryCorruption.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceConfiguration.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceEnteredUnpredictableState.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceMisconfigured.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpaceMonitorRollup.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.LogicalDisk.NTFSFileSystemCorrupt.Alert.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec.AlertMessage" />
    </StringResources>
  </Presentation>
  <Reporting>
    <LinkedReports>
      <LinkedReport ID="Report.Windows.Server.10.0.DiskPerformanceAnalysis" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
          &lt;Data&gt;
            &lt;Chart ObjectJoin="ChartPerObject"&gt;
              &lt;Series&gt;
                &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskQueueLength.Collection"]$&lt;/Rule&gt;
                &lt;Scale&gt;100&lt;/Scale&gt;
                &lt;Type&gt;Line&lt;/Type&gt;
                &lt;Color&gt;63, 63, 255&lt;/Color&gt;
              &lt;/Series&gt;
              &lt;Series&gt;
                &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.DiskReadsPerSec.Collection"]$&lt;/Rule&gt;
                &lt;Scale&gt;1&lt;/Scale&gt;
                &lt;Type&gt;Line&lt;/Type&gt;
                &lt;Color&gt;0,159,0&lt;/Color&gt;
              &lt;/Series&gt;
              &lt;Series&gt;
                &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.DiskWritesPerSec.Collection"]$&lt;/Rule&gt;
                &lt;Scale&gt;1&lt;/Scale&gt;
                &lt;Type&gt;Line&lt;/Type&gt;
                &lt;Color&gt;255,31,31&lt;/Color&gt;
              &lt;/Series&gt;
              &lt;Series&gt;
                &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer.Collection"]$&lt;/Rule&gt;
                &lt;Scale&gt;1000&lt;/Scale&gt;
                &lt;Type&gt;Line&lt;/Type&gt;
                &lt;Color&gt;255,221,0&lt;/Color&gt;
              &lt;/Series&gt;
              &lt;Series&gt;
                &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.DiskBytesPerSec.Collection"]$&lt;/Rule&gt;
                &lt;Scale&gt;1&lt;/Scale&gt;
                &lt;Type&gt;Line&lt;/Type&gt;
                &lt;Color&gt;0,0,0&lt;/Color&gt;
              &lt;/Series&gt;
            &lt;/Chart&gt;
          &lt;/Data&gt;   
                              
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.LogicalDisk</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>0</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.OperatingSystemConfiguration" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.CustomConfiguration">
        <ParameterBlock columns="4" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control columnSpan="1" rowSpan="2" type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.RelativeDateTimePicker">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
              </ReportParameters>
            </Control>
            <Control columnSpan="2" rowSpan="2" type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.MonitoringObjectXmlPicker">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="Properties">
            <Value>
                            
        &lt;Data&gt;
        &lt;Columns&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/LogicalProcessors$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/PhysicalMemory$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/BuildNumber$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/ServicePackVersion$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/InstallDate$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/CSDVersion$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/OSVersionDisplayName$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/SerialNumber$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/SystemDrive$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.OperatingSystem"]/WindowsDirectory$&lt;/ID&gt;
	        &lt;/Column&gt;
        &lt;/Columns&gt;
        &lt;/Data&gt;
                        
                        </Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.OperatingSystemPerformance" Target="ServervNext!Microsoft.Windows.Server.10.0.OperatingSystem" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ValueTemplate">
                  <Value>
                                        
        &lt;Data&gt;
          &lt;Chart ObjectJoin="ChartPerObject"&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentProcessorTime.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;63, 63, 255&lt;/Color&gt;
            &lt;/Series&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.SystemProcessorQueueLength.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;0,159,0&lt;/Color&gt;
            &lt;/Series&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;255,31,31&lt;/Color&gt;
            &lt;/Series&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSec.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;255,221,0&lt;/Color&gt;
            &lt;/Series&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;0,0,0&lt;/Color&gt;
            &lt;/Series&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;63,255,63&lt;/Color&gt;
            &lt;/Series&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;255,127,63&lt;/Color&gt;
            &lt;/Series&gt;
          &lt;/Chart&gt;
        &lt;/Data&gt;                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>0</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.OperatingSystemStorageConfiguration" Target="ServervNext!Microsoft.Windows.Server.10.0.LogicalDisk" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.CustomConfiguration">
        <ParameterBlock columns="4" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control columnSpan="1" rowSpan="2" type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.RelativeDateTimePicker">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
              </ReportParameters>
            </Control>
            <Control columnSpan="2" rowSpan="2" type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.MonitoringObjectXmlPicker">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.LogicalDisk</Value>
                </Property>
              </Properties>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="Properties">
            <Value>
                            
        &lt;Data&gt;
        &lt;Columns&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/Name$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="WindowsServer!Microsoft.Windows.Server.LogicalDisk"]/FileSystem$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/Description$&lt;/ID&gt;
	        &lt;/Column&gt;
	        &lt;Column Visible ="True"&gt;
		        &lt;ID&gt;$MPElement[Name="WindowsServer!Microsoft.Windows.Server.LogicalDisk"]/Size$&lt;/ID&gt;
	        &lt;/Column&gt;
        &lt;/Columns&gt;
        &lt;/Data&gt;
                        
                        </Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistory" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
                        &lt;Data&gt;
                            &lt;Chart ObjectJoin="ChartPerObject"&gt;
                                &lt;Series&gt;
                                    &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentProcessorTime.Collection"]$&lt;/Rule&gt;
                                    &lt;Scale&gt;1&lt;/Scale&gt;
                                    &lt;Type&gt;Line&lt;/Type&gt;
                                    &lt;Color&gt;63, 63, 255&lt;/Color&gt;
                                &lt;/Series&gt;
                            &lt;/Chart&gt;
                        &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryContextSwitchesPerSec" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.SystemContextSwitchesPerSec.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;255,31,31&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryMemory.AvailableMB" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
        &lt;Data&gt;
          &lt;Chart ObjectJoin="ChartPerObject"&gt;
            &lt;Series&gt;
              &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.Collection"]$&lt;/Rule&gt;
              &lt;Scale&gt;1&lt;/Scale&gt;
              &lt;Type&gt;Line&lt;/Type&gt;
              &lt;Color&gt;0,0,0&lt;/Color&gt;
            &lt;/Series&gt;
          &lt;/Chart&gt;
        &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PageReadsPerSec" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageReadsPerSec.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;0,0,0&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PagesPerSec" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSec.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;0,0,0&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PageWritesPerSec" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageWritesPerSec.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;0,0,0&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryPagingFile.PercentageUsage" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.PageFilePercentUsage.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Area&lt;/Type&gt;
            &lt;Color&gt;63,63,255&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryPercentInterruptTime" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;255,31,31&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryPercentProcessorTime" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentProcessorTime.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;255,31,31&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryPhysicalDisk.AvgDiskQueueLength" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskQueueLength.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;255,31,31&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.PhysicalDisk</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryPoolNonpagedBytes" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolNonPagedBytes.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;0,0,0&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryPoolPagedBytes" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolPagedBytes.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;0,0,0&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
      <LinkedReport ID="Report.Windows.Server.10.0.PerformanceHistoryProcessorQueueLength" Target="ServervNext!Microsoft.Windows.Server.10.0.Computer" Accessibility="Public" Visible="true" Base="ReportLibrary!Microsoft.SystemCenter.DataWarehouse.Report.Performance">
        <ParameterBlock columns="3" xmlns="http://schemas.microsoft.com/mom/reporting/2007/ReportParameterSettings">
          <Controls>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.ComboBox" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="DataAggregation">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.DataAggregation</Prompt>
                </ReportParameter>
              </ReportParameters>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.LinkedPerformanceChartObjectPicker" columnSpan="2" rowSpan="2">
              <ReportParameters>
                <ReportParameter name="ObjectList">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.ObjectList</Prompt>
                </ReportParameter>
                <ReportParameter name="ManagementGroupId" binding="GroupList" />
              </ReportParameters>
              <Properties>
                <Property name="ContextObjectBinding">
                  <Value>Containment</Value>
                </Property>
                <Property name="ValueTemplate">
                  <Value>
                                        
      &lt;Data&gt;
        &lt;Chart ObjectJoin="ChartPerObject"&gt;
          &lt;Series&gt;
            &lt;Rule&gt;$MPElement[Name="Microsoft.Windows.Server.10.0.OperatingSystem.SystemProcessorQueueLength.Collection"]$&lt;/Rule&gt;
            &lt;Scale&gt;1&lt;/Scale&gt;
            &lt;Type&gt;Line&lt;/Type&gt;
            &lt;Color&gt;255,31,31&lt;/Color&gt;
          &lt;/Series&gt;
        &lt;/Chart&gt;
      &lt;/Data&gt;
                        
                                    </Value>
                </Property>
                <Property name="TypeFilter">
                  <Value>Microsoft.Windows.Server.10.0.OperatingSystem</Value>
                </Property>
              </Properties>
            </Control>
            <Control type="Microsoft.SystemCenter.DataWarehouse.Report.ParameterControl.BusinessRelativeDateTimePicker" columnSpan="1">
              <ReportParameters>
                <ReportParameter name="TimeZone" binding="TimeZone">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.TimeZone</Prompt>
                </ReportParameter>
                <ReportParameter name="TimeZoneName" binding="TimeZoneName" />
                <ReportParameter name="StartDate_BaseType" binding="StartDate_BaseType" />
                <ReportParameter name="StartDate_BaseValue" binding="StartDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.StartDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="StartDate_OffsetType" binding="StartDate_OffsetType" />
                <ReportParameter name="StartDate_OffsetValue" binding="StartDate_OffsetValue" />
                <ReportParameter name="EndDate_BaseType" binding="EndDate_BaseType" />
                <ReportParameter name="EndDate_BaseValue" binding="EndDate_BaseValue">
                  <Prompt>Microsoft.SystemCenter.DataWarehouse.Report.Library!Microsoft.SystemCenter.DataWarehouse.Report.ParameterPrompt.EndDateTime</Prompt>
                </ReportParameter>
                <ReportParameter name="EndDate_OffsetType" binding="EndDate_OffsetType" />
                <ReportParameter name="EndDate_OffsetValue" binding="EndDate_OffsetValue" />
                <ReportParameter name="TimeType" binding="TimeType" />
                <ReportParameter name="TimeWeekMap" binding="TimeWeekMap" />
              </ReportParameters>
            </Control>
          </Controls>
        </ParameterBlock>
        <Parameters>
          <Parameter Name="AggregationType">
            <Value>3</Value>
          </Parameter>
        </Parameters>
      </LinkedReport>
    </LinkedReports>
  </Reporting>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="true">
      <DisplayStrings>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.ModuleType">
          <Name>Percent Memory Used Module Type</Name>
          <Description>Data Source module type for collecting amount of used physical memory.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.Collection">
          <Name>Percent Memory Used</Name>
          <Description>This rule collects data about used physical memory.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.ModuleType" SubElementID="Frequency">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.ModuleType" SubElementID="Tolerance">
          <Name>Tolerance</Name>
          <Description>Tolerance</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.ModuleType" SubElementID="NumOfSamples">
          <Name>Number of Samples</Name>
          <Description>Number of Samples</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime">
          <Name>Logical Disk Percent Idle Time</Name>
          <Description>Monitor the performance counter LogicalDisk\% Idle Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime" SubElementID="OverThreshold">
          <Name>Disk Idle time percentage Low</Name>
          <Description>Disk Idle time percentage is too Low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime" SubElementID="UnderThreshold">
          <Name>Disk Idle time percentage OK</Name>
          <Description>Disk Idle time percentage OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime.AlertMessage">
          <Name>Logical disk idle time percentage is too low</Name>
          <Description>The threshold for the Logical Disk\% Idle Time performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength">
          <Name>Current Disk Queue Length (Logical Disk)</Name>
          <Description>Monitor the performance counter LogicalDisk\Current Disk Queue Length</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength" SubElementID="OverThreshold">
          <Name>Current Disk Queue Length High</Name>
          <Description>The disk current queue length High.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength" SubElementID="UnderThreshold">
          <Name>Current Disk Queue Length OK</Name>
          <Description>The disk current queue length OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength.AlertMessage">
          <Name>Logical disk current queue length is too high</Name>
          <Description>The threshold for the Logical Disk\Current Disk Queue Length performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime">
          <Name>Physical Disk Percent Idle Time</Name>
          <Description>Monitor the performance counter PhysicalDisk\% Idle Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime" SubElementID="OverThreshold">
          <Name>Disk Idle time percentage Low</Name>
          <Description>Disk Idle time percentage is too Low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime" SubElementID="UnderThreshold">
          <Name>Disk Idle time percentage OK</Name>
          <Description>Disk Idle time percentage OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime.AlertMessage">
          <Name>Physical disk idle time percentage is too low</Name>
          <Description>The threshold for the Physical Disk\% Idle Time performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength">
          <Name>Current Disk Queue Length (Physical Disk)</Name>
          <Description>Monitor the performance counter PhysicalDisk\Current Disk Queue Length</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength" SubElementID="OverThreshold">
          <Name>Current Disk Queue Length High</Name>
          <Description>The disk current queue length High.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength" SubElementID="UnderThreshold">
          <Name>Current Disk Queue Length OK</Name>
          <Description>The disk current queue length OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength.AlertMessage">
          <Name>Physical disk current queue length is too high</Name>
          <Description>The threshold for the Physical Disk\Current Disk Queue Length performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries">
          <Name>Free System Page Table Entries</Name>
          <Description>Monitor the performance counter Memory\Free System Page Table Entries</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries" SubElementID="OverThreshold">
          <Name>Free System Page Table Entries Low</Name>
          <Description>Memory Free System Page Table Entries Low.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries" SubElementID="UnderThreshold">
          <Name>Free System Page Table Entries OK</Name>
          <Description>Memory Free System Page Table Entries OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries.AlertMessage">
          <Name>Free System Page Table Entries is too Low.</Name>
          <Description>The threshold for the Memory\Free System Page Table Entries performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond">
          <Name>Memory Pages Per Second</Name>
          <Description>Monitor the performance counter Memory\MemoryPagesPerSecond</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond" SubElementID="OverThreshold">
          <Name>Pages Per Second High</Name>
          <Description>Memory Memory Pages Per Second High.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond" SubElementID="UnderThreshold">
          <Name>Pages Per Second OK</Name>
          <Description>Memory Pages Per Second OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond.AlertMessage">
          <Name>Memory Pages Per Second is too High.</Name>
          <Description>The threshold for the Memory\Pages\sec performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ConditionDetection.ModuleType">
          <Name>Network Adapter Bandwidth Used Expression Module Type</Name>
          <Description>Condition detection module type which filters data according to monitoring object name and values delta.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ModuleType">
          <Name>Network Adapter Bandwidth Used Module Type</Name>
          <Description>Data Source module type for network adapter bandwidth used counters.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BandwidthUsed.ModuleType" SubElementID="Interval">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads">
          <Name>Percent Bandwidth Used Read</Name>
          <Description>This monitor checks percentage of used network adapter read bandwidth.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads" SubElementID="OverThreshold">
          <Name>Warning State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads" SubElementID="UnderThreshold">
          <Name>Healthy State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads.Collection">
          <Name>Percent Bandwidth Used Read</Name>
          <Description>Rule collects Bandwidth Used Read counter for network adapters.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType">
          <Name>Percent of Used Bandwidth Monitor Type</Name>
          <Description>Monitor type to check percentage of used network adapter bandwidth.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType" SubElementID="Threshold">
          <Name>Threshold (percentage)</Name>
          <Description>The threshold (in percentage) over which the monitor will change state.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsed.MonitorType" SubElementID="NumOfSamples">
          <Name>Number of samples</Name>
          <Description>The number of consecutive samples that need to be over the threshold before the monitor will change state.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads.Alert.AlertMessage">
          <Name>Used read bandwidth is over threshold</Name>
          <Description>Percentage of used network adapter read bandwidth is over threshold.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal.Collection">
          <Name>Percent Bandwidth Used Total</Name>
          <Description>Rule collects Bandwidth Used Total counter for network adapters.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites.Collection">
          <Name>Percent Bandwidth Used Write</Name>
          <Description>Rule collects Bandwidth Used Write counter for network adapters.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal">
          <Name>Percent Bandwidth Used Total</Name>
          <Description>This monitor checks percentage of total used network adapter bandwidth..</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal" SubElementID="UnderThreshold">
          <Name>Healthy State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal" SubElementID="OverThreshold">
          <Name>Warning State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal.Alert.AlertMessage">
          <Name>Used total bandwidth is over threshold</Name>
          <Description>Percentage of used network adapter total bandwidth is over threshold.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites">
          <Name>Percent Bandwidth Used Write</Name>
          <Description>This monitor checks percentage of used network adapter write bandwidth.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites" SubElementID="OverThreshold">
          <Name>Warning State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites" SubElementID="UnderThreshold">
          <Name>Healthy State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites.Alert.AlertMessage">
          <Name>Used write bandwidth is over threshold</Name>
          <Description>Percentage of used network adapter write bandwidth is over threshold.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.ActiveConnections.Task">
          <Name>Display Active Connections</Name>
          <Description>Execute the NETSTAT command line tool to display a list of active connections.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.IPConfig.Task">
          <Name>IPConfig</Name>
          <Description>Run ipconfig /all on the server</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.LocalUsersQuery.Task">
          <Name>Display Local Users</Name>
          <Description>Query and display a list of local users on the server</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.NetStatisticsServer.Task">
          <Name>Display Server Statistics</Name>
          <Description>Display a list of all the network statistics for the Server service of the server.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.NetStatisticsWorkstation.Task">
          <Name>Display Workstation Statistics</Name>
          <Description>Display a list of all the network statistics for the Workstation service of the server.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.NetworkShareQuery.Task">
          <Name>Display Network Shares</Name>
          <Description>Query and display a list of local network shares</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.ProcessList.Task">
          <Name>List Processes</Name>
          <Description>Query and display a list of currently running processes.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.RoutePrint.Task">
          <Name>Route Print</Name>
          <Description>Execute the Route tool using it's Print command.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.ServicesQuery.Task">
          <Name>List Services</Name>
          <Description>List running services on the server</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.SessionQuery.Task">
          <Name>Display Active Sessions</Name>
          <Description>Display a list of all the sessions on the server.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Computer.UserAccountSettingsQuery.Task">
          <Name>Display Account Settings</Name>
          <Description>Query and display the current settings, password requirements and the server role for a server</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.ModuleType">
          <Name>Windows CPU Utilization Data Source Module</Name>
          <Description>Monitor CPU utilization of individual CPUs on Windows Servers</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.ModuleType" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.ModuleType" SubElementID="NumSamples">
          <Name>Num Samples</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype">
          <Name>Windows CPU Utilization Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" SubElementID="CPUPercentageThreshold">
          <Name>CPU Percentage Utilization Threshold</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" SubElementID="CPUQueueLengthThreshold">
          <Name>CPU Queue Length Threshold</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" SubElementID="CPUUtilizationHigh">
          <Name>CPU Utilization Too High</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" SubElementID="CPUUtilizationNormal">
          <Name>CPU Utilization OK</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" SubElementID="NumSamples">
          <Name>Number of Samples</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference3" SubElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference3.TabName">
          <Name>CPU Utilization Threshold</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference4" SubElementID="Microsoft.Windows.Server.10.0.CPUUtilization.Monitortype.PageSet.PageReference4.TabName">
          <Name>CPU Queue Threshold</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartition.ComputerManagement.Task">
          <Name>Start Computer Management Console</Name>
          <Description>This task starts the Computer Management console.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartition.LogicalDiskAvailabilityRollup">
          <Name>Logical Disk Availability Rollup</Name>
          <Description>This monitor rolls up the availability of Logical Disk</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartition.LogicalDiskPerformanceRollup">
          <Name>Logical Disk Performance Rollup</Name>
          <Description>This monitor roles up the performance of Logical Disk</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.LogicalProcessorPerformanceRollup">
          <Name>Logical Processors Performance Rollup</Name>
          <Description>This monitor roles up the performance of Logical Processor</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskPartition.State.DetailsView">
          <Name>Windows Server 2016 and above Disk Partition State Detail View</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype">
          <Name>Windows Logical Disk Free Space Data Source Module</Name>
          <Description>Monitor the Logical Disk Free Space on Windows Servers</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype">
          <Name>Windows Logical Disk Free Space Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="IntervalSeconds">
          <Name>Interval Seconds</Name>
          <Description>Interval in seconds</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="NonSystemDriveErrorMBytesThreshold">
          <Name>Error Mbytes Threshold for Non-System Drives</Name>
          <Description>Error Mbytes Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="NonSystemDriveErrorPercentThreshold">
          <Name>Error % Threshold for Non-System Drives</Name>
          <Description>Error % Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="NonSystemDriveWarningMBytesThreshold">
          <Name>Warning threshold in MBytes for the non-system drives</Name>
          <Description>Warning threshold in MBytes for the non system drives.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="NonSystemDriveWarningPercentThreshold">
          <Name>Warning % Threshold for Non-System Drives</Name>
          <Description>Warning % Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="SystemDriveErrorMBytesThreshold">
          <Name>Error MBytes Threshold for System Drives</Name>
          <Description>Error MBytes Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="SystemDriveErrorPercentThreshold">
          <Name>Error %Threshold for System Drives</Name>
          <Description>Error % Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="SystemDriveWarningMBytesTheshold">
          <Name>Warning MBytes Threshold for System Drives</Name>
          <Description>Warning MBytes Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="SystemDriveWarningPercentThreshold">
          <Name>Warning % Threshold for System Drives</Name>
          <Description>Warning % Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="Interval">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="NonSystemDriveErrorMBytesThreshold">
          <Name>Error MBytes Threshold for Non-System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="NonSystemDriveErrorPercentThreshold">
          <Name>Error % Threshold for Non-System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="NonSystemDriveWarningMBytesThreshold">
          <Name>Warning MBytes Threshold for Non-System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="NonSystemDriveWarningPercentThreshold">
          <Name>Warning % Threshold for Non-System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="OverErrorThresholds">
          <Name>Over Error Threshold</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="OverWarningUnderErrorThresholds">
          <Name>Over Warning and Under Error Thresholds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="SystemDriveErrorMBytesThreshold">
          <Name>Error MBytes Threshold for System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="SystemDriveErrorPercentThreshold">
          <Name>Error % Threshold for System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="SystemDriveWarningMBytesThreshold">
          <Name>Warning MBytes Threshold for System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Moduletype" SubElementID="SystemDriveWarningPercentThreshold">
          <Name>Warning % Threshold for System Drives</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype" SubElementID="UnderWarningThresholds">
          <Name>Under Warning Threshold</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference3" SubElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference3.TabName">
          <Name>System Drive %</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference4" SubElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference4.TabName">
          <Name>System Drive MBytes</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference5" SubElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference5.TabName">
          <Name>Non-System Drive %</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference6" SubElementID="Microsoft.Windows.Server.10.0.FreeSpace.Monitortype.PageSet.PageReference6.TabName">
          <Name>Non-System Drive MBytes</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Monitortype">
          <Name>Windows Processor Performance Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PerformanceRollup">
          <Name>Windows Server 2016 and above Processor Performance Rollup Monitor</Name>
          <Description>This monitor aggregates the performance monitors for Processor.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Monitortype" SubElementID="Frequency">
          <Name>Frequency seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Monitortype" SubElementID="Threshold">
          <Name>Threshold (percentage)</Name>
          <Description>The threshold (in percentage) over which the monitor will change state.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Monitortype" SubElementID="NumSamples">
          <Name>Number of Samples</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Monitortype" SubElementID="TimeoutSeconds">
          <Name>Timeout (seconds)</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Monitortype" SubElementID="UnderThreshold">
          <Name>Healthy State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Monitortype" SubElementID="OverThreshold">
          <Name>Critical State</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType">
          <Name>Windows Processor Utilization Data Source Module</Name>
          <Description>Monitor Processor utilization of individual Processors(Socket) on Windows Servers</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType" SubElementID="Frequency">
          <Name>Frequency seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.Performance.ModuleType" SubElementID="TimeoutSeconds">
          <Name>Timeout seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe">
          <Name>Windows PowerShell Property Bag Probe Action Library Module</Name>
          <Description>This module starts PowerShell script based probe action module.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PowerShellPropertyBagProbe" SubElementID="TimeoutSeconds">
          <Name>Timeout seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.BPA.PowerShellPropertyBagProbe">
          <Name>Windows PowerShell BPA Property Bag Probe Action Library Module</Name>
          <Description>Collect BPA Scan results.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.BPA.PowerShellPropertyBagProbe" SubElementID="TimeoutSeconds">
          <Name>Timeout seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PowerShellPerformanceProbe">
          <Name>Windows PowerShell Performance Probe Action Library Module</Name>
          <Description>This module collects performance counter based on PowerShell script.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PowerShellPerformanceProbe" SubElementID="TimeoutSeconds">
          <Name>Timeout seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth">
          <Name>File system error or corruption</Name>
          <Description>Monitors whether the file system has reported an error with the file system or corruption on the logical disk.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth" SubElementID="Availabile">
          <Name>File system available</Name>
          <Description>The file system is available</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth" SubElementID="NotAvailabile">
          <Name>File system is in error or corrupt</Name>
          <Description>The file system has reported an error or is corrupt</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth.AlertMessage">
          <Name>NTFS reported the logical disk is in error or corrupt.</Name>
          <Description>NTFS on the logical disk {0} has reported that some portion of the file system is in error or is corrupted.  This dirty bit has been set for the logical disk.  In most cases running the CHKDSK utility will address the problem.  Refer to the product knowledge for more complete guidance.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskQueueLength.Collection">
          <Name>Collection Rule for the Average Disk Queue Length Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Avg Disk Queue Length</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead">
          <Name>Average Logical Disk Seconds Per Read</Name>
          <Description>Monitor the performance counter LogicalDisk\Avg Disk Sec Per Read</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead" SubElementID="OverThreshold">
          <Name>Average Disk Seconds Per Read High</Name>
          <Description>The disk read latency is too high.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead" SubElementID="UnderThreshold">
          <Name>Average Disk Seconds Per Read  OK</Name>
          <Description>The disk read latency is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead.AlertMessage">
          <Name>Disk read latency  is too high</Name>
          <Description>The threshold for the Logical Disk\Avg. Disk sec/Read performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead.Collection">
          <Name>Collection Rule for Average Disk Seconds Per Read Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Avg Disk Sec Per Read</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer">
          <Name>Average Logical Disk Seconds Per Transfer</Name>
          <Description>Monitor the performance counter LogicalDisk\Avg Disk Sec Per Transfer</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer" SubElementID="OverThreshold">
          <Name>Average Disk Seconds Per Transfer High</Name>
          <Description>The disk transfer latency is too high.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer" SubElementID="UnderThreshold">
          <Name>Average Disk Seconds Per Transfer OK</Name>
          <Description>The disk transfer latency is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer.AlertMessage">
          <Name>Logical disk transfer (reads and writes) latency  is too high</Name>
          <Description>The threshold for the Logical Disk\Avg. Disk sec/Transfer performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer.Collection">
          <Name>Collection Rule for Average Disk Seconds Per Transfer Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Avg Disk Sec Per Transfer</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite">
          <Name>Average Disk Seconds Per Write (Logical Disk)</Name>
          <Description>Monitor the performance counter LogicalDisk\Avg Disk Sec Per Write</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite" SubElementID="OverThreshold">
          <Name>Average Disk Seconds Per Write High</Name>
          <Description>The disk write latency is too high.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite" SubElementID="UnderThreshold">
          <Name>Average Disk Seconds Per Write OK</Name>
          <Description>The disk write latency is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite.AlertMessage">
          <Name>Disk write latency  is too high</Name>
          <Description>The threshold for the Logical Disk\Avg. Disk sec/Write performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite.Collection">
          <Name>Collection Rule for Average Disk Seconds Per Write Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Avg Disk Sec Per Write</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Task">
          <Name>Run Chkdsk</Name>
          <Description>Execute a chkdsk against the logical disk and display the results</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkntfs.Task">
          <Name>Run Chkntfs</Name>
          <Description>Execute a chkntfs command against the logical disk and display the results.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.ComputerManagement.Task">
          <Name>Start Computer Management Console</Name>
          <Description>This task starts the Computer Management console.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength.Collection">
          <Name>Collection rule for Current Disk Queue Length Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Current Disk Queue Length</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskBytesPerSec.Collection">
          <Name>Collection Rule for Disk Bytes Per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Disk Bytes Per Second</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskReadsPerSec.Collection">
          <Name>Collection Rule for Disk Reads Per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Disk Reads Per Second</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskWritesPerSec.Collection">
          <Name>Collection Rule for Disk Writes Per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter LogicalDisk\Disk Writes Per Second</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeMB.Collection">
          <Name>Logical Disk Free Megabytes Windows Server 2016 and above</Name>
          <Description>The space in megabytes on the logical disk that is unallocated</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace">
          <Name>[Deprecated] Logical Disk Free Space</Name>
          <Description>Monitors the percentage free space and number of free MBytes remaining on a logical disk. Only when both the low percentage free space and low number of free MBytes thresholds are reached, the disk is flagged as having low disk free space.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace" SubElementID="OverErrorThresholds">
          <Name>Free Space Critically Low</Name>
          <Description>Disk free space is very low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace" SubElementID="OverWarningUnderErrorThresholds">
          <Name>Free Space Low</Name>
          <Description>Disk free space is low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace" SubElementID="UnderWarningThresholds">
          <Name>Free Space Acceptable</Name>
          <Description>Disk free space is OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace.AlertMessage">
          <Name>Logical Disk Free Space is running low</Name>
          <Description>The disk {0} on computer {1} is running out of disk space.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis">
          <Name>Logical Disk Fragmentation Level</Name>
          <Description>This monitor runs on a periodic basis (Every Saturday  at 3 a.m. by default) to check the fragmentation levels of all logical drives.  If fragmentation levels are found to be above threshold then by default the state of the monitor will change to "Warning" and an alert will be generated.  There is a recovery named "Logical Disk Defragmentation"  targeted to this monitor, which is disabled by default.  If the recovery is enabled then the state change will automatically kick off a task to defragment the logical drive.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis" SubElementID="UnderThreshold">
          <Name>Fragmentation Level High</Name>
          <Description>Disk fragmentation level is high</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis" SubElementID="OverThreshold">
          <Name>Fragmentation Level Low</Name>
          <Description>Disk fragmentation level is low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Recovery">
          <Name>Logical Disk Defragmentation</Name>
          <Description>Performs defragmentation of the logical disk.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Task">
          <Name>Logical Disk Defragmentation</Name>
          <Description>Performs defragmentation of the logical disk.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.AlertMessage">
          <Name>Logical Disk Fragmentation Level is high</Name>
          <Description>The disk {0} on computer {1} has high fragmentation level. File Percent Fragmentation value is {2}%. Defragmentation recommended: {3}.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace.Collection">
          <Name>% Logical Disk Free Space Windows Server 2016 and above</Name>
          <Description>The percentage of total usable space on the logical disk that is unallocated</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdle.Collection">
          <Name>% Logical Disk Idle Time Windows Server 2016 and above</Name>
          <Description>The percentage of time during the sample interval that the disk was idle.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskReadBytesPerSec.Collection">
          <Name>Disk Read Bytes Per Second Windows Server 2016 and above (Logical Disk)</Name>
          <Description>The rate at which bytes are transferred from the disk during read operations.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskWriteBytesPerSec.Collection">
          <Name>Logical Disk Write Bytes Per Second Windows Server 2016 and above</Name>
          <Description>The rate at which bytes are transferred from the disk during write operations.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AverageDiskReadQueueLength.Collection">
          <Name>Average Logical Disk Read Queue Length Windows Server 2016 and above</Name>
          <Description>The average number of read requests that were queued for the selected disk during the sample interval.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AverageDiskWriteQueueLength.Collection">
          <Name>Average Disk Write Queue Length Windows Server 2016 and above (Logical Disk)</Name>
          <Description>The average number of write requests that were queued for the selected disk during the sample interval.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.SplitIOPerSec.Collection">
          <Name>Logical Disk Split I/O Per Second Windows Server 2016 and above</Name>
          <Description>The rate at which I/Os to the disk were split into multiple I/Os.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.ModuleType">
          <Name>Logical Disk Data Source Module</Name>
          <Description>Logical Disk Data Source Module</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.ModuleType" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.ModuleType" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype">
          <Name>Logical Disk Availability Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype" SubElementID="Bad">
          <Name>Logical Disk Not Available</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype" SubElementID="Good">
          <Name>Logical Disk Available</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Monitortype" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype">
          <Name>Logical Disk Fragmentation Level Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" SubElementID="SchedulerStart">
          <Name>Start time</Name>
          <Description>The time of the day (HH:MM) that the fragmentation check should be run</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" SubElementID="SchedulerDaysOfWeekMask">
          <Name>Days Of Week mask</Name>
          <Description>The day(s) that the fragmentation check should be run. The values for the days are Sunday (1), Monday (2), Tuesday (4), Wednesday (8), Thursday (16), Friday (32) and Saturday (64).  To specify multiple days, add the values for the days together.  For example, for Monday, Wednesday, and Friday, specify 42 (2+8+32).</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" SubElementID="FilePercentFragmentationThreshold">
          <Name>File Percent Fragmentation Threshold</Name>
          <Description>If the "Use OS Recommendation" is set to "False" then this value will be used as the threshold for fragmentation levels.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" SubElementID="UseOSRecommendation">
          <Name>Use OS Recommendation</Name>
          <Description>This parameter determines whether the fragmentation level check will use the default threshold determined by the operating system or not.  If this parameter is set to "False" then the value from "File Percent Fragmentation Threshold" will be used.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" SubElementID="Warning">
          <Name>Warning</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Monitortype" SubElementID="Success">
          <Name>Success</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.State.DetailsView">
          <Name>Windows Server 2016 and above Logical Disk State Detail View</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.VolumeInfo.Task">
          <Name>Volume Information</Name>
          <Description>Run fsutil to obtain information about this volume</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.ModuleType">
          <Name>Windows Memory Available MBytes Data Source Module</Name>
          <Description>Windows Memory Available MBytes Data Source Module</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.ModuleType" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.ModuleType" SubElementID="NumSamples">
          <Name>Num Samples</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype">
          <Name>Windows Memory Available MBytes Utilization Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" SubElementID="MemoryAvailableMBytesLow">
          <Name>Low Available Memory </Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" SubElementID="MemoryAvailableMBytesNormal">
          <Name>Normal Available Memory</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" SubElementID="MemoryThreshold">
          <Name>Available Memory Threshold (MBytes)</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" SubElementID="NumSamples">
          <Name>Number of Samples</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference3" SubElementID="Microsoft.Windows.Server.10.0.MemoryAvailableMBytes.Monitortype.PageSet.PageReference3.TabName">
          <Name>Number of Samples</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Monitoring">
          <Name>Windows Server 2016 and above Operating Systems (Monitoring)</Name>
          <Description>Microsoft Windows Server 2016 and above Operating System Management Pack: this management pack monitors Windows Server 2016 and above operating systems.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesReceivedPerSec.Collection">
          <Name>Network Adapter Bytes Received per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Network Interface\Bytes Received/sec</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesSentPerSec.Collection">
          <Name>Network Adapter Bytes Sent per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Network Interface\Bytes Sent/sec</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesTotalPerSec.Collection">
          <Name>Network Adapter Bytes Total per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Network Interface/Bytes Total/sec</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.ComputerManagement.Task">
          <Name>Start Computer Management Console</Name>
          <Description>This task starts the Computer Management console.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype">
          <Name>Network Adapter Connection Health Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" SubElementID="MonitorDisconnection">
          <Name>Network Adapter Connection Health Monitor Type</Name>
          <Description>This monitor type is used as the basis for the monitor which detects the connection health of network adapters.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" SubElementID="MonitorHardwareMalfunction">
          <Name>Monitor Network Adapter Hardware Malfunction</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" SubElementID="MonitorMediaDisconnection">
          <Name>Monitor Network Adapter Media Disconnection</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" SubElementID="Good">
          <Name>Good</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.Monitortype" SubElementID="Bad">
          <Name>Bad</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth">
          <Name>Network Adapter Connection Health</Name>
          <Description>Monitors the network adapter connection's health.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth" SubElementID="Connected">
          <Name>Network Adapter Connected</Name>
          <Description>Network adapter is connected to the network</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth" SubElementID="Disconnected">
          <Name>Network Adapter Disconnected</Name>
          <Description>Network adapter is disconnected from the network</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth.AlertMessage">
          <Name>Network Adapter Disconnected</Name>
          <Description>The network adapter named {0} is disconnected from the network</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.State.DetailsView">
          <Name>Windows Server 2016 and above Network Adapter State Detail View</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.CheckingFileSystemOccuredOnStartup.Collection">
          <Name>Collection Rule for Checking the File System Occurred on Startup</Name>
          <Description>This rule collects the events indicates that the system ran a chkdsk on startup</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.CleanShutdown.Collection">
          <Name>Collection Rule for Windows Clean Restart Events</Name>
          <Description>This rule collects the events indicating a clean Windows shutdown.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth">
          <Name>Computer Browser Service Health</Name>
          <Description>Monitors the health of the Windows service for the Computer Browser. Please note that this monitor is not running on Nano Server (the state of the monitor will be always "Healthy").</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>Computer Browser Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>Computer Browser Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth.AlertMessage">
          <Name>Computer Browser Service Stopped</Name>
          <Description>The Computer Browser service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task">
          <Name>Start Computer Management Console</Name>
          <Description>This task starts the Computer Management console.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup">
          <Name>Core Windows Services Rollup</Name>
          <Description>The rollup monitor for all health related to critical Windows services.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth">
          <Name>DHCP Client Service Health</Name>
          <Description>Monitors the health of the Windows service for the DHCP Client</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>DHCP Client Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>DHCP Client Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth.AlertMessage">
          <Name>DHCP Service Stopped</Name>
          <Description>The DHCP service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DirtyShutdown.Collection">
          <Name>Collection Rule for Windows Dirty Shutdown Events</Name>
          <Description>This rule collects events indicating a dirty Windows shutdown.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth">
          <Name>DNS Client Service Health</Name>
          <Description>Monitors the health of the Windows service for the DNS Client</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>DNS Client Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>DNS Client Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth.AlertMessage">
          <Name>DNS Client Service Stopped</Name>
          <Description>The DNS client service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogFull.Alert">
          <Name>Event Log File is Full</Name>
          <Description>The event log file is full.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogFull.Alert.AlertMessage">
          <Name>Event log is full</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth">
          <Name>Windows Event Log Service Health</Name>
          <Description>Monitors the health of the Windows service for the Windows Event Log</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>The Event Log service is not running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>The Event Log service is running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth.AlertMessage">
          <Name>Windows Event Log Service Stopped</Name>
          <Description>The Windows Event Log service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.IPAddressConflict.Alert">
          <Name>Duplicate IP Address has been Detected</Name>
          <Description>A duplicate IP address has been detected on the network</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.IPAddressConflict.Alert.AlertMessage">
          <Name>IP address conflict</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.LDMCantReadDisk.Alert">
          <Name>Disk can not be read</Name>
          <Description>Logical Disk Manager reports that the disk can not be read</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.LDMCantReadDisk.Alert.AlertMessage">
          <Name>LDM - Can't Read Disk</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes">
          <Name>Available Megabytes of Memory</Name>
          <Description>Monitors the available memory level.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes" SubElementID="OverThreshold">
          <Name>Available Memory OK</Name>
          <Description>Available Memory OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes" SubElementID="UnderThreshold">
          <Name>Available Memory Critical</Name>
          <Description>Available Memory Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.AlertMessage">
          <Name>Available Megabytes of Memory is too low</Name>
          <Description>The threshold for the Memory\Available MBytes performance counter has been exceeded. The value that exceeded the threshold is: {0}.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.Collection">
          <Name>Memory Available Megabytes Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Memory\Available MBytes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageReadsPerSec.Collection">
          <Name>Memory Page Reads per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Memory\Page Reads/Sec.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSec.Collection">
          <Name>Memory Pages per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Memory\Pages Reads/Sec.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageWritesPerSec.Collection">
          <Name>Memory Page Writes per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Memory\Page Writes/Sec.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPercentCommittedBytesInUse.Collection">
          <Name>Memory % Committed Bytes in Use Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Memory\% Committed Bytes in Use</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolNonPagedBytes.Collection">
          <Name>Memory Pool Non-paged Bytes Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Memory\Pool Nonpaged Bytes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolPagedBytes.Collection">
          <Name>Memory Pool Paged Bytes Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Memory\Pool Paged Bytes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NetworkAdapterDisconnected.Collection">
          <Name>Collection rule for Network Adapter was Disconnected from the Network</Name>
          <Description>Collection rule for events indicating the network adapter was disconnected from the network.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSDelayedWriteLost.Alert">
          <Name>NTFS - Delayed Write Lost</Name>
          <Description>NT file system reports a delayed write was lost.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSDelayedWriteLost.Alert.AlertMessage">
          <Name>NTFS - Delayed Write Lost</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSFileSystemCorrupt.Alert">
          <Name>NTFS - File System Corrupt</Name>
          <Description>NT file system indicates a corrupt file system.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSFileSystemCorrupt.Alert.AlertMessage">
          <Name>NTFS - File System Corrupt</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSQuotaThresholdLimitReached.Collection">
          <Name>Collection rule for NTFS Quota Threshold Limit Reached</Name>
          <Description>An NTFS disk quota threshold limit was reached.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSQuotaThresholdReached.Collection">
          <Name>Collection rule for NTFS Quota Threshold Reached</Name>
          <Description>An NTFS disk quota threshold was reached.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PageFilePercentUsage.Collection">
          <Name>Page File Percentage Use Windows Server 2016 and above</Name>
          <Description>Collection rule for the performance counter Paging File\% Usage</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse">
          <Name>Percentage of Committed Memory in Use</Name>
          <Description>Monitor the performance counter Memory\% Committed Bytes in Use</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse" SubElementID="OverThreshold">
          <Name>Percent Committed Bytes Critical</Name>
          <Description>The percent committed bytes is high enough to indicate a likely performance problem.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse" SubElementID="UnderThreshold">
          <Name>Percent Committed Bytes OK</Name>
          <Description>The percent committed bytes is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse.AlertMessage">
          <Name>Percentage of Committed Memory in Use is too high</Name>
          <Description>The threshold for the Memory\% Committed Bytes In Use performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PerfCounterDataRequestTimeOut.Alert">
          <Name>Too many requests for performance counter data have failed</Name>
          <Description>Too many requests for performance counter data have timed out and failed.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PerfCounterDataRequestTimeOut.Alert.AlertMessage">
          <Name>Too many requests for performance counter data have timed out</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PerformanceRegistryCorruption.Alert">
          <Name>Performance registry corruption</Name>
          <Description>Corruption was detected in the registry related to performance counters.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PerformanceRegistryCorruption.Alert.AlertMessage">
          <Name>Performance registry corruption</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth">
          <Name>Plug and Play Service Health</Name>
          <Description>Monitors the health of the Windows service for Plug and Play</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>Plug and Play Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>Plug and Play Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth.AlertMessage">
          <Name>Plug and Play Service Stopped</Name>
          <Description>The Plug and Play service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RebootFromBugCheck.Collection">
          <Name>Collection Rule for Windows Restart Events (restarted from bug check)</Name>
          <Description>Collection rule for events indicating Windows restarted from bug check</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RestartEvent.Collection">
          <Name>Collection Rule for Windows Restarted Events</Name>
          <Description>This rule collects events indicating Windows has restarted</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth">
          <Name>RPC Service Health</Name>
          <Description>Monitors the health of the Windows service for RPC</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>RPC Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>RPC Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth.AlertMessage">
          <Name>RPC Service Stopped</Name>
          <Description>The RPC service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceConfiguration.Rule">
          <Name>Server Service Configuration Health Rule</Name>
          <Description>Server Service Configuration Health Rule</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceConfiguration.Rule.AlertMessage">
          <Name>Server Service is misconfigured</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth">
          <Name>Server Service Health</Name>
          <Description>Monitors the health of the Windows service for the Server</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth.AlertMessage">
          <Name>Windows Server Service Stopped</Name>
          <Description>The Windows Server service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceEnteredUnpredictableState.Alert">
          <Name>A Service has Entered into an Unpredictable State</Name>
          <Description>A service has entered an unpredictable state.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceEnteredUnpredictableState.Alert.AlertMessage">
          <Name>Service entered unpredictable state</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceMisconfigured.Alert">
          <Name>A Service is misconfigured</Name>
          <Description>A service has been detected as misconfigured.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceMisconfigured.Alert.AlertMessage">
          <Name>Service is misconfigured</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Alert">
          <Name>A Service or Driver Failed to Start</Name>
          <Description>An event was detected indicating a service or driver failed to start.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Alert.AlertMessage">
          <Name>Service or driver failed to start</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Collection">
          <Name>Collection rule for Service or Driver Failed to Start events</Name>
          <Description>Collection rule for events indicating a service or driver has failed to start.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Alert">
          <Name>A Service Terminated Unexpectedly</Name>
          <Description>An event was collected indicating an unexpected service termination.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Alert.AlertMessage">
          <Name>Service terminated unexpectedly</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Collection">
          <Name>Collection rule for unexpected service terminations</Name>
          <Description>Collection rule for events indicating unexpected service terminations.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Alert">
          <Name>A Share Configuration is Invalid</Name>
          <Description>A share was detected as having invalid configuration.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Alert.AlertMessage">
          <Name>Share configuration is invalid</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Collection">
          <Name>Collection rule for invalid Share Configuration Detected</Name>
          <Description>Collection rule for events indicating that a share has invalid configuration.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Alert">
          <Name>A Software Update Installation Failed</Name>
          <Description>A failed software update installation was detected.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Alert.AlertMessage">
          <Name>Software update installation failed</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Collection">
          <Name>Collection Rule for Software Update Installation Failed</Name>
          <Description>Collection rule for events indicating a failed software update installation.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdatesInstalled.Collection">
          <Name>Collection Rule for Software Updates Installation Events</Name>
          <Description>Collection rule for events indicating that new software updates were installed.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdatesScheduledForInstallation.Collection">
          <Name>Collection Rule for Software Updates Scheduled Installation Events</Name>
          <Description>Collection rule for events indicating new software updates are scheduled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.StartServerService.Task">
          <Name>Start the Server service</Name>
          <Description>Start the Server service on the server.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.State.DetailsView">
          <Name>Windows Server 2016 and above Operating System State Detail View</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SystemContextSwitchesPerSec.Collection">
          <Name>System Context Switches per Second Windows Server 2016 and above</Name>
          <Description>Collection rule for the performance counter System\Context Switches/sec</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SystemProcessorQueueLength.Collection">
          <Name>System Processor Queue Length Windows Server 2016 and above</Name>
          <Description>Collection rule for the performance counter System\Processor Queue Length.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth">
          <Name>TCP/IP NetBIOS Service Health</Name>
          <Description>Monitors the health of the Windows service for TCP/IP NetBIOS</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth.AlertMessage">
          <Name>TCP/IP NetBIOS Service Stopped</Name>
          <Description>The TCP/IP NetBIOS service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TopCPUUsage.Task">
          <Name>List Top CPU Consuming processes</Name>
          <Description>List Top CPU Consuming processes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TopCPUUsage.Diagnostic">
          <Name>List Top CPU Consuming processes</Name>
          <Description>List Top CPU Consuming processes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization">
          <Name>Total CPU Utilization Percentage</Name>
          <Description>Monitors the total CPU utilization of this server by correlating the Processor Information\% Processor Time\_Total and the System\Processor Queue Length performance counters.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization" SubElementID="OverThreshold">
          <Name>CPU Utilization Critical</Name>
          <Description>CPU Utilization Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization" SubElementID="UnderThreshold">
          <Name>CPU Utilization Acceptable</Name>
          <Description>CPU Utilization Acceptable</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization.AlertMessage">
          <Name>Total CPU Utilization Percentage is too high</Name>
          <Description>The threshold for the Processor Information\% Processor Time\_Total performance counter has been exceeded. The values that exceeded the threshold are: {0}% CPU and a processor queue length of {1}.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime">
          <Name>Total DPC Time Percentage</Name>
          <Description>Monitors the DPC Time Percentage.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime" SubElementID="OverThreshold">
          <Name>DPC Time Critical</Name>
          <Description>DPC Time Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime" SubElementID="UnderThreshold">
          <Name>DPC Time Acceptable</Name>
          <Description>DPC Time Acceptable</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime.AlertMessage">
          <Name>Total DPC Time Percentage is too high</Name>
          <Description>The threshold for the Processor Information\% DPC Time\_Total performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentDPCTime.Collection">
          <Name>Total Processor % DPC Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor\% DPC Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime">
          <Name>Total Percentage Interrupt Time</Name>
          <Description>Monitors the Percentage Interrupt Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime" SubElementID="OverThreshold">
          <Name>Interrupt Time Critical</Name>
          <Description>Interrupt Time Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime" SubElementID="UnderThreshold">
          <Name>Interrupt Time Acceptable</Name>
          <Description>Interrupt Time Acceptable</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime.AlertMessage">
          <Name>Total Percentage Interrupt Time is too high</Name>
          <Description>The threshold for the Processor Information\% Interrupt Time\_Total performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime.Collection">
          <Name>Total Processor Information % Interrupt Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor Information\% Interrupt Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentProcessorTime.Collection">
          <Name>Processor % Processor Time Total Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor\% Processor Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation">
          <Name>Reserved</Name>
          <Description>Reserved</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation" SubElementID="Activated">
          <Name>Windows Activated</Name>
          <Description>Windows Activated</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation" SubElementID="NeedsActivated15Days">
          <Name>Requires Activation within 15 days</Name>
          <Description>Requires Activation within 15 days</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation" SubElementID="NeedsActivated6Days">
          <Name>Requires Activation within 6 days</Name>
          <Description>Requires Activation within 6 days</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation.AlertMessage">
          <Name>Windows Required Activation</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth">
          <Name>Workstation Service Health</Name>
          <Description>Monitors the health of the Workstation service</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>Workstation Service Not Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>Workstation Service Running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth.AlertMessage">
          <Name>Windows Workstation Service Stopped</Name>
          <Description>The Windows Workstation service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskQueueLength.Collection">
          <Name>Physical Disk Average Disk Queue Length Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Avg. Disk Queue Length</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead">
          <Name>Average Physical Disk Seconds Per Read</Name>
          <Description>Monitors the average seconds per read operation to disk.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead" SubElementID="OverThreshold">
          <Name>Average Disk Seconds Per Read High</Name>
          <Description>Average Disk Seconds Per Read High</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead" SubElementID="UnderThreshold">
          <Name>Average Disk Seconds Per Read  OK</Name>
          <Description>Average Disk Seconds Per Read OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead.AlertMessage">
          <Name>Disk read latency is too high</Name>
          <Description>The threshold for the Physical Disk\Avg. Disk sec/Read performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead.Collection">
          <Name>Physical Disk Average Disk Seconds per Read Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Avg. Disk sec/Read</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer">
          <Name>Average Physical Disk Seconds Per Transfer</Name>
          <Description>Monitors the disk read and write latency (average disk seconds per transfer).</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer" SubElementID="OverThreshold">
          <Name>Average Disk Seconds Per Transfer High</Name>
          <Description>Average Disk Seconds Per Transfer High</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer" SubElementID="UnderThreshold">
          <Name>Average Disk Seconds Per Transfer OK</Name>
          <Description>Average Disk Seconds Per Transfer OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer.AlertMessage">
          <Name>Physical disk transfer (reads and writes) latency  is too high</Name>
          <Description>The threshold for the Physical Disk\Avg. Disk sec/Transfer performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer.Collection">
          <Name>Physical Disk Average Disk Seconds per Transfer Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Avg. Disk sec/Transfer.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite">
          <Name>Average Disk Seconds Per Write (Physical Disk)</Name>
          <Description>Monitors the disk write latency (average disk seconds per write)</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite" SubElementID="OverThreshold">
          <Name>Average Disk Seconds Per Write High</Name>
          <Description>Average Disk Seconds Per Write High</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite" SubElementID="UnderThreshold">
          <Name>Average Disk Seconds Per Write OK</Name>
          <Description>Average Disk Seconds Per Write OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite.AlertMessage">
          <Name>Disk write latency is too high</Name>
          <Description>The threshold for the Physical Disk\Avg. Disk sec/Write performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite.Collection">
          <Name>Physical Disk Average Disk Seconds per Write Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Avg. Disk sec/Write.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.ComputerManagement.Task">
          <Name>Start Computer Management Console</Name>
          <Description>This task starts the Computer Management console.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength.Collection">
          <Name>Physical Disk Current Disk Queue Length Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Current Disk Queue Length</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskBytesPerSec.Collection">
          <Name>Physical Disk Disk Bytes per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Disk Bytes/sec.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskReadsPerSec.Collection">
          <Name>Physical Disk Reads per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Disk Reads/sec</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskWritesPerSec.Collection">
          <Name>Physical Disk Writes per Second Windows Server 2016 and above</Name>
          <Description>Collects the performance counter PhysicalDisk\Disk Writes/sec.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdle.Collection">
          <Name>% Physical Disk Idle Time Windows Server 2016 and above</Name>
          <Description>The percentage of time during the sample interval that the disk was idle.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskReadBytesPerSec.Collection">
          <Name>Disk Read Bytes Per Second Windows Server 2016 and above (Physical Disk)</Name>
          <Description>The rate at which bytes are transferred from the disk during read operations.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskWriteBytesPerSec.Collection">
          <Name>Physical Disk Write Bytes Per Second Windows Server 2016 and above</Name>
          <Description>The rate at which bytes are transferred from the disk during write operations.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AverageDiskReadQueueLength.Collection">
          <Name>Average Physical Disk Read Queue Length Windows Server 2016 and above</Name>
          <Description>The average number of read requests that were queued for the selected disk during the sample interval.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AverageDiskWriteQueueLength.Collection">
          <Name>Average Disk Write Queue Length Windows Server 2016 and above (Physical Disk)</Name>
          <Description>The average number of write requests that were queued for the selected disk during the sample interval.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.SplitIOPerSec.Collection">
          <Name>Physical Disk Split I/O Per Second Windows Server 2016 and above</Name>
          <Description>The rate at which I/Os to the disk were split into multiple I/Os.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.State.DetailsView">
          <Name>Windows Server 2016 and above Physical Disk State Detail View</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.ComputerManagement.Task">
          <Name>Start Computer Management Console</Name>
          <Description>This task starts the Computer Management console.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.CPUUtilization">
          <Name>CPU Percentage Utilization</Name>
          <Description>Monitors total CPU (Processor Information) utilization.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.CPUUtilization" SubElementID="OverThreshold">
          <Name>CPU Utilization High</Name>
          <Description>CPU Utilization High</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.CPUUtilization" SubElementID="UnderThreshold">
          <Name>CPU Utilization OK</Name>
          <Description>CPU Utilization OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime">
          <Name>CPU DPC Time Percentage</Name>
          <Description>Monitors the Percent DPC Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime" SubElementID="OverThreshold">
          <Name>DPC Time Critical</Name>
          <Description>DPC Time Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime" SubElementID="UnderThreshold">
          <Name>DPC Time OK</Name>
          <Description>DPC Time OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime">
          <Name>CPU Percentage Interrupt Time</Name>
          <Description>Monitors the CPU Percentage Interrupt Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime" SubElementID="OverThreshold">
          <Name>Interrupt Time Critical</Name>
          <Description>Interrupt Time Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime" SubElementID="UnderThreshold">
          <Name>Interrupt Time OK</Name>
          <Description>Interrupt Time OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime">
          <Name>Logical CPU Percentage Interrupt Time</Name>
          <Description>Monitors the Logical CPU Percentage Interrupt Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime" SubElementID="OverThreshold">
          <Name>Interrupt Time Critical</Name>
          <Description>Interrupt Time Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime" SubElementID="UnderThreshold">
          <Name>Interrupt Time OK</Name>
          <Description>Interrupt Time OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.CPUUtilization">
          <Name>Logical CPU Percentage Utilization</Name>
          <Description>Monitors total Logical CPU utilization.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.CPUUtilization" SubElementID="OverThreshold">
          <Name>Logical CPU Utilization High</Name>
          <Description>Logical CPU Utilization High</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.CPUUtilization" SubElementID="UnderThreshold">
          <Name>Logical CPU Utilization OK</Name>
          <Description>Logical CPU Utilization OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime">
          <Name>Logical CPU DPC Time Percentage</Name>
          <Description>Monitors the Percent DPC Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime" SubElementID="OverThreshold">
          <Name>DPC Time Critical</Name>
          <Description>DPC Time Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime" SubElementID="UnderThreshold">
          <Name>DPC Time OK</Name>
          <Description>DPC Time OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime.Collection">
          <Name>Processor Information % DPC Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor Information\% DPC Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime.Collection">
          <Name>Processor Information % Interrupt Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor Information\% Interrupt Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.PercentProcessorTime.Collection">
          <Name>Processor % Processor Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor\% Processor Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime.Collection">
          <Name>Logical Processor Information % Interrupt Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor Information\% Interrupt Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentProcessorTime.Collection">
          <Name>Logical Processor % Processor Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor\% Processor Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime.Collection">
          <Name>Logical Processor % DPC Time Windows Server 2016 and above</Name>
          <Description>Collects the performance counter Processor\%  DPC Time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Processor.State.DetailsView">
          <Name>Windows Server 2016 and above Processor State Detail View</Name>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.DiskPerformanceAnalysis">
          <Name>Disk Performance Analysis</Name>
          <Description>Disk Performance Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.OperatingSystemConfiguration">
          <Name>Operating System Configuration</Name>
          <Description>Microsoft Windows Operating System Configuration Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.OperatingSystemPerformance">
          <Name>Operating System Performance</Name>
          <Description>Operating System Performance Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.OperatingSystemStorageConfiguration">
          <Name>Operating System Storage Configuration</Name>
          <Description>Microsoft Windows Operating System Storage Configuration Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistory">
          <Name>Performance History</Name>
          <Description>Performance History Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryContextSwitchesPerSec">
          <Name>Performance History (Context Switches per Sec)</Name>
          <Description>Performance History Context Switches per Sec Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.AvailableMB">
          <Name>Memory Performance History (Available MB)</Name>
          <Description>Memory Performance History  - available MB Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PageReadsPerSec">
          <Name>Memory Performance History (Page Reads per Sec)</Name>
          <Description>Performance History Memory - Page Reads Per Sec Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PagesPerSec">
          <Name>Memory Performance History (Pages per Sec)</Name>
          <Description>Performance History Memory - Pages Per Sec Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PageWritesPerSec">
          <Name>Memory Performance History (Page Writes per Sec)</Name>
          <Description>Performance History Memory - Page Writes Per Sec Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryPagingFile.PercentageUsage">
          <Name>Paging File Performance History (Percentage Usage)</Name>
          <Description>Performance History Paging File - Percentage Usage Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryPercentInterruptTime">
          <Name>Performance History (Percent Interrupt Time)</Name>
          <Description>Performance History Percent Interrupt Time Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryPercentProcessorTime">
          <Name>Performance History (Percent Processor Time)</Name>
          <Description>Performance History Percent Processor Time Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryPhysicalDisk.AvgDiskQueueLength">
          <Name>Physical Disk Performance History (Avg Disk Queue Length)</Name>
          <Description>Performance History Physical Disk - Avg Disk Queue Length Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryPoolNonpagedBytes">
          <Name>Pool Performance History (Non paged Bytes)</Name>
          <Description>Performance History Pool Non paged Bytes Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryPoolPagedBytes">
          <Name>Pool Performance History (Paged Bytes)</Name>
          <Description>Performance History Pool Paged Bytes Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Report.Windows.Server.10.0.PerformanceHistoryProcessorQueueLength">
          <Name>Performance History (Processor Queue Length)</Name>
          <Description>Performance History Processor Queue Length Analysis Report</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MemoryFreeSystemPageTableEntries.Collection">
          <Name>Free System Page Table Entries</Name>
          <Description>Collects the performance counter Memory\Free System Page Table Entries</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCacheBytes.Collection">
          <Name>Cache Bytes</Name>
          <Description>Collects the performance counter Memory\Cache Bytes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCommittedBytes.Collection">
          <Name>Committed Bytes</Name>
          <Description>Collects the performance counter Memory\Committed Bytes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesOutputPerSec.Collection">
          <Name>Pages Output Per Second</Name>
          <Description>Collects the performance counter Memory\Pages Output/sec</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesInputPerSec.Collection">
          <Name>Pages Input Per Second</Name>
          <Description>Collects the performance counter Memory\Pages Input/sec</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCommitLimit.Collection">
          <Name>Commit Limit</Name>
          <Description>Collects the performance counter Memory\Commit limit</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolPagedResidentBytes.Collection">
          <Name>Pool Paged Resident Bytes</Name>
          <Description>Collects the performance counter Memory\Pool Paged Resident Bytes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemorySystemCacheResidentBytes.Collection">
          <Name>System Cache Resident Bytes</Name>
          <Description>Collects the performance counter Memory\System Cache Resident Bytes</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.CacheDataMapHitsPercent.Collection">
          <Name>Cache Data Map Hits Percent</Name>
          <Description>Collects the performance counter Memory\Data Map Hits %</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.CurrentBandwidth.Collection">
          <Name>Current Bandwidth</Name>
          <Description>Rule collects Network Interface\Current Bandwidth counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.OutputQueueLength.Collection">
          <Name>Output Queue Length</Name>
          <Description>Rule collects Network Interface\Output Queue Length counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionsEstablished.Collection">
          <Name>TCPv4 Connections Established</Name>
          <Description>This rule collects TCPv4\Connections Established performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionsEstablished.Collection">
          <Name>TCPv6 Connections Established</Name>
          <Description>The rule collects TCPv6\Connections Established performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionFailures.Collection">
          <Name>TCPv4 Connection Failures</Name>
          <Description>The rule collects TCPv4\Connection Failures performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionFailures.Collection">
          <Name>TCPv6 Connection Failures</Name>
          <Description>The rule collects TCPv6\Connection Failures performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionsReset.Collection">
          <Name>TCPv4 Connections Reset</Name>
          <Description>The rule collects TCPv4\Connections Reset performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionsReset.Collection">
          <Name>TCPv6 Connections Reset</Name>
          <Description>The rule collects TCPv6\Connections Reset performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec.Collection">
          <Name>TCPv4 Segments Retransmitted Per Second</Name>
          <Description>The rule collects TCPv4\Segments Retransmitted/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec">
          <Name>TCPv4 Segments Retransmitted Per Second</Name>
          <Description>Monitors the TCPv4\Segments Retransmitted/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec" SubElementID="OverThreshold">
          <Name>Segments Retransmitted/sec Warning</Name>
          <Description>The segments retransmitted/sec is high enough to indicate a likely performance problem.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec" SubElementID="UnderThreshold">
          <Name>Segments Retransmitted/sec OK</Name>
          <Description>The segments retransmitted/sec is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec.AlertMessage">
          <Name>TCPv4 Segments Retransmitted Per Second is too high</Name>
          <Description>The threshold for the TCPv4\Segments Retransmitted/sec performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec.Collection">
          <Name>TCPv6 Segments Retransmitted Per Second</Name>
          <Description>The rule collects TCPv6\Segments Retransmitted/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec">
          <Name>TCPv6 Segments Retransmitted Per Second</Name>
          <Description>Monitors the TCPv6\Segments Retransmitted/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec" SubElementID="OverThreshold">
          <Name>Segments Retransmitted/sec Warning</Name>
          <Description>The segments retransmitted/sec is high enough to indicate a likely performance problem.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec" SubElementID="UnderThreshold">
          <Name>Segments Retransmitted/sec OK</Name>
          <Description>The segments retransmitted/sec is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec.AlertMessage">
          <Name>TCPv6 Segments Retransmitted Per Second is too high</Name>
          <Description>The threshold for the TCPv6\Segments Retransmitted/sec performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec.Collection">
          <Name>TCPv4 Segments Received Per Second</Name>
          <Description>The rule collects TCPv4\Segments Received/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec">
          <Name>TCPv4 Segments Received Per Second</Name>
          <Description>Monitors the TCPv4\Segments Received/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec" SubElementID="OverThreshold">
          <Name>Segments Received/sec Warning</Name>
          <Description>The segments received/sec is high enough to indicate a likely performance problem.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec" SubElementID="UnderThreshold">
          <Name>Segments Received/sec OK</Name>
          <Description>The segments received/sec is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec.AlertMessage">
          <Name>TCPv4 Segments Received Per Second is too high</Name>
          <Description>The threshold for the TCPv4\Segments Received/sec performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec.Collection">
          <Name>TCPv6 Segments Received Per Second</Name>
          <Description>The rule collects TCPv6\Segments Received/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec">
          <Name>TCPv6 Segments Received Per Second</Name>
          <Description>Monitors the TCPv6\Segments Received/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec" SubElementID="OverThreshold">
          <Name>Segments Received/sec Warning</Name>
          <Description>The segments received/sec is high enough to indicate a likely performance problem.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec" SubElementID="UnderThreshold">
          <Name>Segments Received/sec OK</Name>
          <Description>The segments received/sec is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec.AlertMessage">
          <Name>TCPv6 Segments Received Per Second is too high</Name>
          <Description>The threshold for the TCPv6\Segments Received/sec performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec.Collection">
          <Name>TCPv4 Segments Sent Per Second</Name>
          <Description>The rule collects TCPv4\Segments Sent/sec counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec">
          <Name>TCPv4 Segments Sent Per Second</Name>
          <Description>Monitors the TCPv4\Segments Sent/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec" SubElementID="OverThreshold">
          <Name>Segments Sent/sec Warning</Name>
          <Description>The segments sent/sec is high enough to indicate a likely performance problem.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec" SubElementID="UnderThreshold">
          <Name>Segments Sent/sec OK</Name>
          <Description>The segments sent/sec is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec.AlertMessage">
          <Name>TCPv4 Segments Sent Per Second is too high.</Name>
          <Description>The threshold for the TCPv4\Segments Sent/sec performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec.Collection">
          <Name>TCPv6 Segments Sent Per Second</Name>
          <Description>The rule collects TCPv6\Segments Sent/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec">
          <Name>TCPv6 Segments Sent Per Second</Name>
          <Description>Monitors the TCPv6\Segments Sent/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec" SubElementID="OverThreshold">
          <Name>Segments Sent/sec Warning</Name>
          <Description>The segments sent/sec is high enough to indicate a likely performance problem.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec" SubElementID="UnderThreshold">
          <Name>Segments Sent/sec OK</Name>
          <Description>The segments sent/sec is OK.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec.AlertMessage">
          <Name>TCPv6 Segments Sent Per Second is too high</Name>
          <Description>The threshold for the TCPv6\Segments Sent/sec performance counter has been exceeded.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.MonitorType">
          <Name>BPA Monitor Type</Name>
          <Description>Windows Server 2016 and above operating systems Monitor Type</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.MonitorType" SubElementID="Interval">
          <Name>Interval</Name>
          <Description>Interval in seconds</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.CheckBPAResult.Task">
          <Name>View Best Practices Analyzer compliance results</Name>
          <Description>This task shows compliance results of the Best Practices Analyzer. Note that BPA monitor should be enabled for the task working on Windows Server 2016 and above operating systems. As long as Windows Nano Server does not support cmd module, the task will not work, and the monitor will always be displayed as "Healthy".</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Diagnostic">
          <Name>Best Practices Analyzer Compliance Results</Name>
          <Description>This task shows compliance results of the Best Practices Analyzer rules.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor">
          <Name>Operating System BPA Monitor</Name>
          <Description>Monitors compliance of Windows Server 2016 and above operating systems with Best Practices Analyzer rules. As long as Windows Nano Server does not support BPA PowerShell cmdlets, the monitor will always be displayed as "Healthy".</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor" SubElementID="MonitorWarningState">
          <Name>Warning</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor" SubElementID="MonitorHealthyState">
          <Name>Healthy</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor" SubElementID="MonitorErrorState">
          <Name>Error</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor.AlertMessage">
          <Name>Operating System is not compliant with Best Practices Analyzer</Name>
          <Description>{0} For more information on the BPA issues detected, view the diagnostic output in the State Change Events tab for the Operating System BPA Monitor in Health Explorer.  Alternately, the View Best Practices Analyzer compliance results task can be manually executed to have the results returned.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.ModuleType">
          <Name>Microsoft Windows Server 2016 and above BPA Monitoring Task Module Type</Name>
          <Description>This module type is used to show Best Practices Analyzer compliance results.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.ModuleType" SubElementID="IncludeCompliant">
          <Name>Include Compliant rules.</Name>
          <Description>This parameter defines whether to show compliant BPA rules or not.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.WA.ModuleType">
          <Name>Microsoft Windows Server 2016 and above BPA Monitoring Write Action Module Type</Name>
          <Description>This module type is used to show Best Practices Analyzer compliance results.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.Task.WA.ModuleType" SubElementID="IncludeCompliant">
          <Name>Include Compliant rules.</Name>
          <Description>This parameter defines whether to show compliant BPA rules or not.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.PSScriptWriteAction">
          <Name>Microsoft Windows Server Powershell Write Action Module Type</Name>
          <Description>This module type is used to start PowerShell Script.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.PSScriptWriteAction" SubElementID="Arguments">
          <Name>Arguments</Name>
          <Description>PowerShell Script Arguments</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.PSScriptWriteAction" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
          <Description>PowerShell Script Timeout Seconds</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Cmd.Probe.Nano">
          <Name>Nano Server Command Line Probe Module Type</Name>
          <Description>This module type is used to show command line task results.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Cmd.Probe.Nano" SubElementID="TimeoutSeconds">
          <Name>Timeout in seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Cmd.Probe">
          <Name>Microsoft Windows Server 2016 and above Command Line Probe Module Type</Name>
          <Description>This module type is used to show command line task results.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Cmd.Probe" SubElementID="TimeoutSeconds">
          <Name>Timeout in seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.DS.Moduletype">
          <Name>Windows Logical Disk State Data Source Module</Name>
          <Description>Monitor the Logical Disk State on Windows Servers</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.DS.Moduletype" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.Monitortype">
          <Name>Windows Logical Disk State Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" SubElementID="IntervalSeconds">
          <Name>Interval Seconds</Name>
          <Description>Interval in seconds</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" SubElementID="NumSamples">
          <Name>Number of samples</Name>
          <Description>Number of samples the monitor has to be above the threshold before alerting.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" SubElementID="SystemDriveWarningThreshold">
          <Name>Warning Threshold for System Drives</Name>
          <Description>Warning Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" SubElementID="SystemDriveErrorThreshold">
          <Name>Error Threshold for System Drives</Name>
          <Description>Error Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" SubElementID="NonSystemDriveWarningThreshold">
          <Name>Warning Threshold for Non-System Drives</Name>
          <Description>Warning Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.DiskState.Monitortype" SubElementID="NonSystemDriveErrorThreshold">
          <Name>Error Threshold for Non-System Drives</Name>
          <Description>Error Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace">
          <Name>Logical Disk Free Space (MB) Low</Name>
          <Description>Monitor the number of free MBytes remaining on a logical disk.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace" SubElementID="OverErrorThresholds">
          <Name>Disk Free Space Critically Low</Name>
          <Description>Disk free space is very low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace" SubElementID="OverWarningUnderErrorThresholds">
          <Name>Disk Free Space Low</Name>
          <Description>Disk free space is low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace" SubElementID="UnderWarningThresholds">
          <Name>Disk Free Space Acceptable</Name>
          <Description>Disk free space is OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace.AlertMessage">
          <Name>Logical Disk Free Space in MBytes is low</Name>
          <Description>The disk {0} on computer {1} is running out of disk space. The value that exceeded the threshold is {2} free Mbytes.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace">
          <Name>Logical Disk Free Space (%) Low</Name>
          <Description>Monitor the percentage of free space remaining on a logical disk.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace" SubElementID="OverErrorThresholds">
          <Name>Disk Free Space Critically Low</Name>
          <Description>Disk free space is very low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace" SubElementID="OverWarningUnderErrorThresholds">
          <Name>Disk Free Space Low</Name>
          <Description>Disk free space is low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace" SubElementID="UnderWarningThresholds">
          <Name>Disk Free Space Acceptable</Name>
          <Description>Disk free space is OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace.AlertMessage">
          <Name>Percentage Logical Disk Free Space is low</Name>
          <Description>The disk {0} on computer {1} is running out of disk space. The value that exceeded the threshold is {2}% free space.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpaceMonitorRollup">
          <Name>Logical Disk - Free Space Rollup Monitor</Name>
          <Description>This monitor aggregates the free space monitors for cluster disks.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpaceMonitorRollup.AlertMessage">
          <Name>Free Space Is Low On Logical Disk</Name>
          <Description>{0}: The Logical Disk {1} Named as {2} is running out of disk space. Use the health explorer for viewing details. (Description: {3}).</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.NTFSFileSystemCorrupt.Alert">
          <Name>Windows Server 2016 and above NTFS File System Corrupt Rule</Name>
          <Description>This rule generates alerts base on system events that indicates a NTFS File System Corruption.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.NTFSFileSystemCorrupt.Alert.AlertMessage">
          <Name>Windows Server 2016 and above NTFS File System Corrupt</Name>
          <Description>The Drive {1} of the Device Named as {2} reports a Corruption Action State of {3}. Event Description: {0}.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Scan.Task">
          <Name>Run Chkdsk with Scan option</Name>
          <Description>Execute a online scan of the volumen against the logical disk and display the results</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.SpotFix.Task">
          <Name>Run Chkdsk with Spot Fix option</Name>
          <Description>Execute a spot fixing against the logical disk and display the results</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Full.Task">
          <Name>Run Chkdsk with Full option</Name>
          <Description>Execute a chkdsk against the logical disk, fix errors and display the results</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FsUtil.RepairState.Task">
          <Name>Run fsutil with repair state option</Name>
          <Description>Execute a fsutil against the logical disk, to display the repair state</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor">
          <Name>Max Concurrent API Monitor</Name>
          <Description>This monitor alerts when Max Concurrent API condition is reached.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor" SubElementID="MaxConcurrentAPIAvailable">
          <Name>Max Concurrent API Available</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor" SubElementID="MaxConcurrentAPIReached">
          <Name>Max Concurrent API Reached</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor.AlertMessage">
          <Name>Max Concurrent API Reached alert</Name>
          <Description>Max Concurrent API reached in Server {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Diagnostic">
          <Name>List All Max Concurrent API Performance Data</Name>
          <Description>List All Max Concurrent API Performance Data from Secure Channels.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterUtilization.Dashboard.View">
          <Name>Windows Server 2016 and above Network Adapter Utilization</Name>
          <Description>This dashboard view displays Network Adapter related performance data in Windows Server 2016.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesReceivedsec.View">
          <Name>Network Adapter\Bytes Received/sec Performance</Name>
          <Description>This view displays performance data for the Network Adapter\Bytes Received/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesSentsec.View">
          <Name>Network Adapter\Bytes Sent/sec Performance</Name>
          <Description>This view displays performance data for the Network Adapter\Bytes Sent/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.NetworkAdapterBytesTotalsec.View">
          <Name>Network Adapter\Bytes Total/sec Performance</Name>
          <Description>This view displays performance data for the Network Adapter\Bytes Total/sec performance counter.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth">
          <Name>Windows Firewall Service Health</Name>
          <Description>Monitors the health of the Windows service for the Windows Firewall</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>The Firewall service is not running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>The Firewall service is running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth.AlertMessage">
          <Name>Windows Firewall Service Stopped</Name>
          <Description>The Windows Firewall service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.StartFirewallService.Task">
          <Name>Start the Firewall service</Name>
          <Description>Start the Firewall service on the server.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth">
          <Name>Windows Remote Management Service Health</Name>
          <Description>Monitors the health of the Windows service for the Windows Remote Management</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth" SubElementID="NotRunning">
          <Name>Service Not Running</Name>
          <Description>The Windows Remote Management service is not running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth" SubElementID="Running">
          <Name>Service Running</Name>
          <Description>The Windows Remote Management service is running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth.AlertMessage">
          <Name>Windows Remote Management Service Stopped</Name>
          <Description>The Windows Remote Management service on server {0} has stopped running</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.StartWindowsRemoteManagementService.Task">
          <Name>Start the Windows Remote Management service</Name>
          <Description>Start the Windows Remote Management service on the server.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.ModuleType">
          <Name>Windows Server 2016 and above Logical Disk Free Space Data Source Module</Name>
          <Description>Monitor the Logical Disk Free Space on Windows Server 2016 and above operating systems.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.ModuleType" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.ModuleType" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
          <Description>Number of seconds that the script is allowed to run before it will be forced to stop.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.ModuleType" SubElementID="DebugFlag">
          <Name>Debug Flag</Name>
          <Description>This setting enables the script to log different events at running time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype">
          <Name>Logical Disk Free Space Monitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="IntervalSeconds">
          <Name>Interval Seconds</Name>
          <Description>Interval in seconds</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="SystemDriveWarningMBytesThreshold">
          <Name>Warning MBytes Threshold for System Drives</Name>
          <Description>Warning MBytes Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="SystemDriveWarningPercentThreshold">
          <Name>Warning % Threshold for System Drives</Name>
          <Description>Warning % Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="SystemDriveErrorMBytesThreshold">
          <Name>Error MBytes Threshold for System Drives</Name>
          <Description>Error MBytes Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="SystemDriveErrorPercentThreshold">
          <Name>Error %Threshold for System Drives</Name>
          <Description>Error % Threshold for System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="NonSystemDriveWarningMBytesThreshold">
          <Name>Warning threshold in MBytes for the non-system drives</Name>
          <Description>Warning threshold in MBytes for the non system drives.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="NonSystemDriveWarningPercentThreshold">
          <Name>Warning % Threshold for Non-System Drives</Name>
          <Description>Warning % Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="NonSystemDriveErrorMBytesThreshold">
          <Name>Error Mbytes Threshold for Non-System Drives</Name>
          <Description>Error Mbytes Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="NonSystemDriveErrorPercentThreshold">
          <Name>Error % Threshold for Non-System Drives</Name>
          <Description>Error % Threshold for Non-System Drives</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
          <Description>Number of seconds that the module is allowed to run before it will be forced to stop.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" SubElementID="DebugFlag">
          <Name>Debug Flag</Name>
          <Description>This setting enables the module to log different events at running time</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor">
          <Name>Logical Disk Free Space Monitor</Name>
          <Description>Monitors the percentage free space and number of free MBytes remaining on a logical disk. Only when both the low percentage free space and low number of free MBytes thresholds are reached, the disk is flagged as having low disk free space.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" SubElementID="OverErrorThresholds">
          <Name>Free Space Critically Low</Name>
          <Description>Disk free space is very low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" SubElementID="OverWarningUnderErrorThresholds">
          <Name>Free Space Low</Name>
          <Description>Disk free space is low</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" SubElementID="UnderWarningThresholds">
          <Name>Free Space Acceptable</Name>
          <Description>Disk free space is OK</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor.AlertMessage">
          <Name>Logical Disk Free Space is low</Name>
          <Description>The disk {0} on computer {1} is running out of disk space. The values that exceeded the threshold are {2}% free space and {3} free Mbytes.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor">
          <Name>Storport Miniport Driver Timed Out Monitor</Name>
          <Description>The monitor alerts when the Storport miniport driver times out a request</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" SubElementID="EventRaised">
          <Name>Event Raised</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" SubElementID="TimerEventRaised">
          <Name>Timer Event Raised</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor.AlertMessage">
          <Name>Windows Storport Miniport Driver has timed out a request</Name>
          <Description>The Windows Storport Miniport Driver has timed out a request on the server {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset">
          <Name>Time Accuracy Out of Range</Name>
          <Description>Monitors the total Time Offset of this server</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset" SubElementID="OverThreshold">
          <Name>Time Offset Critical</Name>
          <Description>Time Offset Critical</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset" SubElementID="UnderThreshold">
          <Name>Time Offset Acceptable</Name>
          <Description>Time Offset Acceptable</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset.AlertMessage">
          <Name>Time Accuracy Out of Range Alert</Name>
          <Description>Time Accuracy varies above {0}.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype">
          <Name>Windows Time OffsetMonitor Type</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" SubElementID="Threshold">
          <Name>Threshold in MilliSeconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" SubElementID="TimeOffsetHigh">
          <Name>Time Offset Too High</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" SubElementID="TimeOffsetNormal">
          <Name>Time Offset OK</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" SubElementID="NumSamples">
          <Name>Number of Samples</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.Monitortype" SubElementID="TimeoutSeconds">
          <Name>Timeout Seconds</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.ModuleType">
          <Name>Windows Time Offset Data Source Module</Name>
          <Description>Monitor Time Offset of Windows Server 2016 and above operating systems.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.ModuleType" SubElementID="IntervalSeconds">
          <Name>Interval seconds</Name>
          <Description>How frequently (in seconds) the value should be sampled.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.10.0.TimeOffset.ModuleType" SubElementID="NumSamples">
          <Name>Number of Samples</Name>
        </DisplayString>
      </DisplayStrings>
      <KnowledgeArticles>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdleTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The logical disk has a lot of activity occurring on it and as a result the percentage of the idle time has fallen below the threshold value for multiple consecutive samples.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either the logical disk has recently experienced a significant increase in activity, and this spike has resulted in exceeding the threshold, or logical disks utilization has been steadily increasing over time and has finally reached a point of going over the threshold.</maml:para>
              <maml:para>The other possibility is that some portion of the underlying physical disks or the disk subsystem is malfunctioning or misconfigured, impairing the performance of the logical disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To further investigate the issue consider the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Review the System event log on the system, to see if there are any error indicating problems with the logical disk, physical disks or the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the history of idle time for this logical disk using either performance views or reports in Operations Manager or the performance monitor.  This will help in determining if the issue has started recently or if the activity has been steadily increasing over a longer period of time.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the other performance counters for the logical disk such as % Disk Read Time, % Disk Write Time, Disk Reads/sec and Disk Writes/sec to understand what types of I/O are driving the overall disk utilization.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the Process performance counters such as IO Data Operations/sec to identify which processes are contributing most significantly to the overall I/O on the system.  Once the top processes are identified the IO Read Operations/sec and IO Write Operations/sec counters will help in further in determining the type of I/O that the process is doing.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation, resolutions may vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Address any issues with the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the rate of I/O occurring on the system or distribute the workload across more logical disks.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Upgrade the drives or storage sub-system to handle the increased load.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If the increased load is acceptable then the threshold of the monitor can be changed to be less restrictive.  Likewise the number of consecutive samples can be increased to force the monitor to only change state when utilization is sustained over longer periods of time.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The logical disk has had a consistently high value for the Current Queue Length counter over multiple consecutive samples.  As a result, I/O requests latency will most likely increase on this logical disk.</maml:para>
              <maml:para>Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected.  This means that the logical disk is not able to honor I/O requests as fast as they are being made.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either the logical disk has recently experienced a significant increase in activity, and this spike has resulted in exceeding the threshold, or logical disks utilization has been steadily increasing over time and has finally reached a point of going over the threshold.</maml:para>
              <maml:para>The other possibility is that some portion of the underlying physical disks or the disk subsystem is malfunctioning or misconfigured, impairing the performance of the logical disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To further investigate the issue consider the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Review the System event log on the system, to see if there are any error indicating problems with the logical disk, physical disks or the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the history of current queue length for this logical disk using either performance views or reports in Operations Manager or the performance monitor.  This will help in determining if the issue has started recently or if the activity has been steadily increasing over a longer period of time.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the other performance counters for the logical disk such as Disk Bytes/sec, Disk Reads/sec and Disk Writes/sec to understand what types of I/O are driving the overall disk utilization.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the Process performance counters such as IO Data Operations/sec to identify which processes are contributing most significantly to the overall I/O on the system.  Once the top processes are identified the IO Read Operations/sec and IO Write Operations/sec counters will help in further in determining the type of I/O that the process is doing.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation, resolutions may vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Address any issues or misconfigurations with the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the rate of I/O occurring on the system or distribute the workload across more logical disks.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Upgrade the drives or storage sub-system to handle the increased load.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If the increased load is acceptable then the threshold of the monitor can be changed to be less restrictive.  Likewise the number of consecutive samples can be increased to force the monitor to only change state when utilization is sustained over longer periods of time.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdleTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The physical disk has a lot of activity occurring on it and as a result the percentage of the idle time has fallen below the threshold value for multiple consecutive samples.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either the physical disk has recently experienced a significant increase in activity, and this spike has resulted in exceeding the threshold, or physical disks utilization has been steadily increasing over time and has finally reached a point of going over the threshold.</maml:para>
              <maml:para>The other possibility is that some portion of the underlying physical disks or the disk subsystem is malfunctioning or misconfigured, impairing the performance of the physical disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To further investigate the issue consider the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Review the System event log on the system, to see if there are any error indicating problems with the physical disk, physical disks or the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the history of idle time for this physical disk using either performance views or reports in Operations Manager or the performance monitor.  This will help in determining if the issue has started recently or if the activity has been steadily increasing over a longer period of time.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the other performance counters for the physical disk such as % Disk Read Time, % Disk Write Time, Disk Reads/sec and Disk Writes/sec to understand what types of I/O are driving the overall disk utilization.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the Process performance counters such as IO Data Operations/sec to identify which processes are contributing most significantly to the overall I/O on the system.  Once the top processes are identified the IO Read Operations/sec and IO Write Operations/sec counters will help in further in determining the type of I/O that the process is doing.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation, resolutions may vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Address any issues with the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the rate of I/O occurring on the system or distribute the workload across more physical disks.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Upgrade the drives or storage sub-system to handle the increased load.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If the increased load is acceptable then the threshold of the monitor can be changed to be less restrictive.  Likewise the number of consecutive samples can be increased to force the monitor to only change state when utilization is sustained over longer periods of time.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The physical disk has had a consistently high value for the Current Queue Length counter over multiple consecutive samples.  As a result, I/O requests latency will most likely increase on this physical disk.</maml:para>
              <maml:para>Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected.  This means that the physical disk is not able to honor I/O requests as fast as they are being made.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either the physical disk has recently experienced a significant increase in activity, and this spike has resulted in exceeding the threshold, or physical disks utilization has been steadily increasing over time and has finally reached a point of going over the threshold.</maml:para>
              <maml:para>The other possibility is that some portion of the underlying physical disks or the disk subsystem is malfunctioning or misconfigured, impairing the performance of the physical disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To further investigate the issue consider the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Review the System event log on the system, to see if there are any error indicating problems with the physical disk, physical disks or the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the history of current queue length for this physical disk using either performance views or reports in Operations Manager or the performance monitor.  This will help in determining if the issue has started recently or if the activity has been steadily increasing over a longer period of time.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the other performance counters for the physical disk such as Disk Bytes/sec, Disk Reads/sec and Disk Writes/sec to understand what types of I/O are driving the overall disk utilization.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the Process performance counters such as IO Data Operations/sec to identify which processes are contributing most significantly to the overall I/O on the system.  Once the top processes are identified the IO Read Operations/sec and IO Write Operations/sec counters will help in further in determining the type of I/O that the process is doing.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation, resolutions may vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Address any issues or misconfigurations with the storage sub-system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the rate of I/O occurring on the system or distribute the workload across more physical disks.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Upgrade the drives or storage sub-system to handle the increased load.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If the increased load is acceptable then the threshold of the monitor can be changed to be less restrictive.  Likewise the number of consecutive samples can be increased to force the monitor to only change state when utilization is sustained over longer periods of time.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryFreeSystemPageTableEntries" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>A page table is the data structure used by the Windows Virtual Memory Manager (VMM) to store the mapping between virtual addresses and physical addresses in memory. The performance counter Free System Page Table Entries is the number of page table entries not currently used by the system.</maml:para>
              <maml:para>When a system starts running low on free page table entries applications or drivers might have requests for memory denied, or the computer may stop responding to network requests, seeming to disappear from the network.  Attempts to log onto the system may not be possible, because the server may not be able to respond.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Generally speaking, the issue is caused by high memory utilization.  The issue may be more common on 32 bit systems or systems using special boot switches to change the default memory management behaviors of the operating system.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Possible resolutions include the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Ensure that that the operating system, drivers and the significant applications on the server have the most recent patches applied.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Determine if any special boot switches are being used for the operating system in the BOOT.INI, which may impact how the system managed virtual memory.  If so, then ensure they are necessary and implemented in the best possible way.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    For very detailed instructions on how to diagnose issues with free system page table entries depletion refer to the document Detection, Analysis, and Corrective Actions for Low Page Table Entry Issues which can be downloaded from the Microsoft Download Center at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=201347</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=201347" /></maml:navigationLink>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If the issue continues and the system is 32 bit and/or running on an operating system prior to Windows Server 2016, consider upgrading to Microsoft Windows Server 2016 or beyond and/or moving the workload to a 64 bit system.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSecond" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rate at which the system is paging memory to and/or from disk is too high.  This monitoring is based on the Memory\Pages/sec counter, which is a primary indicator of the kinds of faults that cause system-wide delays.  Overall system performance may significantly diminish.</maml:para>
              <maml:para>Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>One or more applications are using memory heavily, and the system is having to page data to and from disk to meet the demand.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To identify which processes are driving up the overall memory utilization on the system, and the paging rates use the following counters from the Process object in performance monitor:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Page Faults/sec: Page Faults/sec is the rate at which page faults by the threads executing in this process are occurring.  A page fault occurs when a thread refers to a virtual memory page that is not in its working set in main memory. This may not cause the page to be fetched from disk if it is on the standby list and hence already in main memory, or if it is in use by another process with whom the page is shared.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Pool Non paged Bytes: Pool Non paged Bytes is the size, in bytes, of the non paged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process\\Pool Nonpaged Bytes\\_Total.  This counter displays the last observed value only; it is not an average.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process\\Pool Paged Bytes\\_Total. This counter displays the last observed value only; it is not an average.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation resolutions will vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Apply updates to the operating system or the applications to ensure that any known memory issues are fixed.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the number of applications running on the system, or the amount of load that the system is undertaking.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Add more RAM to the system.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the percent of the total network adapter bandwidth that is being used for read operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the percent of the total network adapter bandwidth that is being used for read and write operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the percent of the total network adapter bandwidth that is being used for write operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentMemoryUsed.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule calculates and collects the ratio of the Memory\Available Mbytes counter to the total physical memory available to the system, as a percentage.  This information is collected and exposed in views and reports.</maml:para>
              <maml:para>The Memory\Available Mbytes counter measures how much physical RAM is available to be used.  When Available Mbytes is low, the system will page out memory to disk more aggressively and when this is happening overall system performance may be negatively impacted.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>NTFS has reported that the logical disk is either corrupted or completely unavailable. Some data stored on the volume may be inaccessible.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A logical disk may become corrupted or inaccessible due to a number of reasons some of which include:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>A physical disk related to the logical disk has been removed or failed</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>A physical disk related to the logical disk has become corrupt (for example; bad sectors) or inoperable</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The disk driver may've encountered an issue</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Check the status of your hardware for any failures (for example, a disk, controller, cabling failure). In most cases, the system log contains additional events from the lower-level storage drivers that indicate the cause of the failure.</maml:para>
              <maml:para>After you have isolated and resolved the hardware problem:</maml:para>
              <maml:para>1.  Open the Disk Management snap-in.</maml:para>
              <maml:para>2.  Rescan the disks and then reactivate any disks with errors.</maml:para>
              <maml:para>Resynchronize or regenerate the volume as necessary if the disk was a member of a mirrored or RAID-5 volume.</maml:para>
              <maml:para>3.  Run chkdsk on any reactivated volumes.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Current Disk Queue Length performance counter.</maml:para>
              <maml:para>The Logical Disk\Avg. Disk Queue Length performance counter exposes the average number of both read and write requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Avg. Disk sec/Read (LogicalDisk\Avg. Disk sec/Read) for the logical disk has exceeded the threshold. The performance of applications that rely on this logical disk may be negatively impacted as the disk is taking an unusually long time to service read requests.</maml:para>
              <maml:para>The Avg. Disk sec/Read counter indicates how fast data is being read on average for a specific logical disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high Avg. Disk sec/Read performance counter value may occur due to a burst of disk read requests by either an operating system or application.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Logical Disk\Avg. Disk sec/Read performance counter you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Logical Disk Avg. Disk Sec/Reads Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDiskAvgDiskSecReads.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>To increase the available storage subsystem throughput for the logical disk, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Upgrade the controllers or disk drives.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Switch from just a bunch of disks (JBOD) to striped arrays.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Increase the number of actual spindles.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Be sure to set this threshold value appropriately for your specific storage hardware. The threshold value will vary according to the disks underlying storage subsystem. For example, the disk might be a single spindle or a large disk array.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>The Avg. Disk sec/Read counter is useful in gathering throughput data. If the average time is long enough, you can analyze a histogram of the arrays response to specific loads (queues, request sizes, and so on). If possible, you should observe workloads separately.</maml:para>
              <maml:para>You can use throughput metrics to determine:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The behavior of a workload running on a given host system. You can track the workload requirements for disk read requests over time. Characterization of workloads is an important part of performance analysis and capacity planning.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The peak and sustainable levels of performance that are provided by a given storage subsystem. A workload can either artificially or naturally be used to push a storage subsystem (in this case, a given logical disk) to its limits. Determining these limits provides useful configuration information for system designers and administrators.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>However, without thorough knowledge of the underlying storage subsystem of the logical disk (for example, knowing whether it is a single spindle or a massive disk array), it can be difficult to provide an optimized one size fits all threshold value.</maml:para>
              <maml:para>You must also consider the Avg. Disk sec/Read counter in conjunction with other read request characteristics (for example, request size and randomness/sequentially) and the equivalent counters for read disk requests.</maml:para>
              <maml:para>If the Avg. Disk sec/Read counter is tracked over time and if it increases with the intensity of the workloads that are driving the read requests, it is reasonable to suspect that the logical disk is saturated if throughput does not increase and overall system throughput starts to degrade.</maml:para>
              <maml:para>
                For more information about storage architecture and driver support, see the Storage - Architecture and Driver Support Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=26156</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=26156" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerRead.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Avg. Disk sec/Read performance counter.</maml:para>
              <maml:para>The Avg. Disk sec/Read counter indicates how fast data is being read on average for a specific logical disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Avg. Disk sec/Transfer (LogicalDisk\Avg. Disk sec/Transfer) for the logical disk has exceeded the threshold. The performance of applications that rely on this logical disk may be negatively impacted as the disk is taking an unusually long time to service read and write requests.</maml:para>
              <maml:para>The Avg. Disk sec/Transfer counter indicates how fast data is being read and written on average for a specific logical disk.</maml:para>
              <maml:para>The Avg. Disk sec/Transfer counter is made up from both read and write disk Transfer requests. To view recent disk average rate of read and write Transfer requests you can use the following views:</maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Logical Disk\Avg. Disk Sec/Reads Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDiskAvgDiskSecReads.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Logical Disk\Avg. Disk Sec/Writes Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDiskAvgDiskSecWrites.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high Avg. Disk sec/Transfer performance counter value may occur due to a burst of disk transfer requests by either an operating system or application.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To increase the available storage subsystem throughput for this logical disk, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Upgrade the controllers or disk drives.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Switch from RAID-5 to RAID-0+1.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Increase the number of actual spindles.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Be sure to set this threshold value appropriately for your specific storage hardware. The threshold value will vary according to the disks underlying storage subsystem. For example, the disk might be a single spindle or a large disk array. You can use MOM overrides to define exception thresholds, which can be applied to specific computers or entire computer groups.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>The Avg. Disk sec/Transfer counter is useful in gathering throughput data. If the average time is long enough, you can analyze a histogram of the arrays response to specific loads (queues, request sizes, and so on). If possible, you should observe workloads separately.</maml:para>
              <maml:para>You can use throughput metrics to determine:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The behavior of a workload running on a given host system. You can track the workload requirements for disk transfer requests over time. Characterization of workloads is an important part of performance analysis and capacity planning.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The peak and sustainable levels of performance that are provided by a given storage subsystem. A workload can either be used to artificially or naturally push a storage subsystem (in this case, a given logical disk) to its limits. Determining these limits provides useful configuration information for system designers and administrators.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>However, without thorough knowledge of the underlying storage subsystem of the logical disk (for example, knowing whether it is a single spindle or a massive disk array), it can be difficult to provide an optimized one size fits all threshold value.</maml:para>
              <maml:para>You must also consider the Avg. Disk sec/Transfer counter in conjunction with other transfer request characteristics (for example, request size and randomness/sequentially) and the equivalent counters for write disk requests.</maml:para>
              <maml:para>If the Avg. Disk sec/Transfers counter is tracked over time and if it increases with the intensity of the workloads that are driving the transfer requests, it is reasonable to suspect that the logical disk is saturated if throughput does not increase and the user experiences degraded system throughput.</maml:para>
              <maml:para>
                For more information about storage architecture and driver support, see the Storage - Architecture and Driver Support Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=26156</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=26156" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerTransfer.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Avg. Disk sec/Transfer performance counter.</maml:para>
              <maml:para>The Avg. Disk sec/Transfer counter indicates how fast data is being read and written on average for a specific logical disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Avg. Disk sec/Write (LogicalDisk\Avg. Disk sec/Write) for the logical disk has exceeded the threshold. The performance of applications that rely on this logical disk may be negatively impacted as the disk is taking an unusually long time to service write requests.</maml:para>
              <maml:para>The Avg. Disk sec/Write counter indicates how fast data is being written on average for a specific logical disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high Avg. Disk sec/Write performance counter value may occur due to a burst of disk write requests by either an operating system or application.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Logical Disk\Avg. Disk sec/Write performance counter you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Logical Disk Avg. Disk Sec/Writes Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.LogicalDiskAvgDiskSecWrites.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>To increase the available storage subsystem throughput for this logical disk, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Upgrade the controllers or disk drives.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Switch from RAID-5 to RAID-0+1.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Increase the number of actual spindles.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Be sure to set this threshold value appropriately for your specific storage hardware. The threshold value will vary according to the disks underlying storage subsystem. For example, the disk might be a single spindle or a large disk array. You can use MOM overrides to define exception thresholds, which can be applied to specific computers or entire computer groups.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>The Avg. Disk sec/Writes counter is useful in gathering throughput data. If the average time is long enough, you can analyze a histogram of the arrays response to specific loads (queues, request sizes, and so on). If possible, you should observe workloads separately.</maml:para>
              <maml:para>You can use throughput metrics to determine:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The behavior of a workload running on a given host system. You can track the workload requirements for disk write requests over time. Characterization of workloads is an important part of performance analysis and capacity planning.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The peak and sustainable levels of performance that are provided by a given storage subsystem. A workload can either be used to artificially or naturally push a storage subsystem (in this case, a given logical disk) to its limits. Determining these limits provides useful configuration information for system designers and administrators.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>However, without thorough knowledge of the underlying storage subsystem of the logical disk (for example, knowing whether it is a single spindle or a massive disk array), it can be difficult to provide an optimized one size fits all threshold value.</maml:para>
              <maml:para>You must also consider the Avg. Disk sec/Writes counter in conjunction with other write request characteristics (for example, request size and randomness/sequentially) and the equivalent counters for write disk requests.</maml:para>
              <maml:para>If the Avg. Disk sec/Writes counter is tracked over time and if it increases with the intensity of the workloads that are driving the write requests, it is reasonable to suspect that the logical disk is saturated if throughput does not increase and the user experiences degraded system throughput.</maml:para>
              <maml:para>
                For more information about storage architecture and driver support, see the Storage - Architecture and Driver Support Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=26156</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=26156" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AvgDiskSecPerWrite.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Avg. Disk sec/Write performance counter.</maml:para>
              <maml:para>The Avg. Disk sec/Write counter indicates how fast data is being written on average for a specific logical disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.CurrentDiskQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Current Queue Length performance counter.</maml:para>
              <maml:para>The Logical Disk\Current Queue Length performance counter exposes the current number of both read and write requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskBytesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Disk Bytes/sec performance counter.</maml:para>
              <maml:para>The Logical Disk\Disk Bytes/sec performance counter exposes the rate bytes are transferred to or from the disk during write or read operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskReadsPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Disk Reads/sec performance counter.</maml:para>
              <maml:para>The Logical Disk\Disk Read/sec performance counter exposes the rate of read operations on the disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskWritesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Disk Writes/sec performance counter.</maml:para>
              <maml:para>The Logical Disk\Disk Writes/sec performance counter exposes the rate of read operations on the disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeMB.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Free Megabytes performance counter.</maml:para>
              <maml:para>The Logical Disk\Free Megabytes performance counter exposes the volume of unallocated space, in megabytes, on the disk drive.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The amount of free disk space on the logical disk volume has fallen below threshold. System performance may be adversely affected and the ability to add or modify existing files on the logical disk volume may not be possible until additional free space is made available.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>The Logical Disk Free Space monitoring routine is a high configurable solution that enables Operators to set varying threshold values for system and non-system logical disk volumes. In addition separate threshold values can be set for Warning and Error states.</maml:para>
              <maml:para>Since logical disk volumes may vary in size from a few gigabytes to many terabytes or more the Logical Disk Free Space monitoring routine requires that an Operator indicate both the Megabyte and Percentage based threshold values that must be passed before the Warning and Error thresholds reached. This means that in order for the threshold to be reached both the Megabyte and Percentage based threshold values for the System or Non-System Drive must be breached.</maml:para>
              <maml:para>The default threshold values for the Logical Disk Free Space monitoring routine include:</maml:para>
              <maml:para>System Drive Free Space Thresholds (Defaults)</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Parameter</maml:ui>
                    </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Default Value</maml:ui>
                    </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Error Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>100</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Error Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>5</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Warning Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>200</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Warning Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>10</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para>Non-System Drive Free Space Thresholds (Defaults)</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Parameter</maml:ui>
                    </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Default Value</maml:ui>
                    </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Error Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>1000</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Error Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>5</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Warning Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>2000</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Warning Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>10</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para />
              <maml:para>Please note that Overrides can be used to change any of the threshold values that are defined above. In addition these thresholds can be applied to all logical disk volume instances in the management group or if needed separate threshold values can be defined for specific logical disk volume instances.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When existing files grow in size and the new files are added, the free space is taken up on a logical disk.  When the amount of free space on the logical disk falls below the threshold, the state for the logical disk will change.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To increase the amount of available disk space, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Run Disk Cleanup to gain more free space on the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Back up and remove files, or delete unnecessary files from the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Move files to another disk or to offline storage.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Purchase additional storage or switch to a larger disk.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>To view recent disk space history you can use the following view:</maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Disk Capacity View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.DiskCapacity.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpace.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\% Free Space performance counter.</maml:para>
              <maml:para>The Logical Disk\% Free Space performance counter exposes the percentage of total available free space on the selected logical disk drive.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentIdle.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\% Idle Time performance counter.</maml:para>
              <maml:para>The Logical Disk\% Idle Time performance counter exposes the percentage of time during the sample interval that the disk was idle.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskReadBytesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Disk Read Bytes/sec performance counter.</maml:para>
              <maml:para>The Logical Disk\Disk Read Bytes/sec performance counter exposes the rate at which bytes are transferred from the disk during read operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DiskWriteBytesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Disk Write Bytes/sec performance counter.</maml:para>
              <maml:para>The Logical Disk\Disk Write Bytes/sec performance counter exposes the rate at which bytes are transferred from the disk during write operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AverageDiskReadQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Avg. Disk Read Queue Length performance counter.</maml:para>
              <maml:para>The Logical Disk\Avg. Disk Read Queue Length performance counter exposes the average number of read requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.AverageDiskWriteQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Avg. Disk Write Queue Length performance counter.</maml:para>
              <maml:para>The Logical Disk\Avg. Disk Write Queue Length performance counter exposes the average number of write requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.SplitIOPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Logical Disk\Split IO/Sec performance counter.</maml:para>
              <maml:para>The Logical Disk\Split IO/Sec performance counter exposes the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.2016.Monitoring" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Microsoft Windows Server 2016 and above Operating System Management Pack monitors the availability and performance of Windows Server 2016 and above operating systems. By detecting, alerting, and automatically responding to critical events and performance indicators, the Management Pack helps identify, correct, and prevent possible outages related to Windows Server 2016 and above operating systems. As a result, this Management Pack can play an important role in ensuring that your Windows Server infrastructure and related components are available and working correctly.</maml:para>
              <maml:para>By using embedded expertise, this Management Pack highlights performance, health, and availability conditions that indicate problems. In some cases, it can even identify issues before they become critical thus providing you with a level of customer responsiveness that increases the overall availability and performance of your Windows Server infrastructure and related components. Therefore, this Management Pack will reduce the total cost of ownership (TOC) by enabling proactive management and reducing resolution times for the issues identified.</maml:para>
              <maml:para>The Microsoft Windows Server 2016 and above Operating System Management Pack includes the following features and capabilities:</maml:para>
              <maml:para>
                <maml:ui>Application Structure</maml:ui>
              </maml:para>
              <maml:para>A rich Application Structure is discovered by this Management pack.  This Application Structure exposes the relationships between all Windows components and logical devices. For instance, the relationships between the Computer, Operating System, Logical Disks, Partitions, and Physical Disks can all be discovered and viewed from diagram and topology surfaces.</maml:para>
              <maml:para>
                <maml:ui>Monitors and Rules</maml:ui>
              </maml:para>
              <maml:para>A complete set of Monitors and Rules have been provided to monitor Windows services, components, and infrastructure. The Management Pack includes monitoring capabilities for:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Service and Application Management</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Local Storage Management</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Performance Management</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Reliability Management</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>
                <maml:ui>Tasks</maml:ui>
              </maml:para>
              <maml:para>A set of commonly used Tasks have been provided to assist in the diagnosis and remediation of issues that affect the availability, performance, and configuration of Windows Server related services and components.</maml:para>
              <maml:para>
                <maml:ui>Knowledge</maml:ui>
              </maml:para>
              <maml:para>A complete set of Knowledge has been provided for all Monitors, Rules, and Discoveries.  For Alert generating Monitors and Rules, you will find Knowledge that will help expedite resolution process. Where applicable, Inline Tasks, Views, and Reports have been added to the Knowledge to enable quick diagnostics and the fastest possible resolution.</maml:para>
              <maml:para>
                <maml:ui>Reports</maml:ui>
              </maml:para>
              <maml:para>A series of reports have been provided for administrators to take a historical look at the environment of Windows Server 2016 and above operating systems.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>This Management Pack does not require any out-of-the-box configuration. Overrides may be applied to features to modify the out-of-the-box configuration (e.g. enable/disable monitors and rules, change thresholds, etc.).</maml:para>
              <maml:para>Note: This Management Pack depends on the Microsoft Windows Server Library. Therefore, this Management Packs must be imported during or after the import of the Windows Server Library Management Pack.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesReceivedPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Network Interface\Bytes Received/sec performance counter.</maml:para>
              <maml:para>The Network Interface\Bytes Received/sec performance counter exposes the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesSentPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Network Interface\Bytes Sent/sec performance counter.</maml:para>
              <maml:para>The Network Interface\Bytes Sent/sec performance counter exposes the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.BytesTotalPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Network Interface\Bytes Total/sec performance counter.</maml:para>
              <maml:para>The Network Interface\Bytes Total/sec performance counter exposes the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.NetworkAdapterConnectionHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor generates an alert when Windows detects that the network adapter has been disconnected from the network and no longer has network connectivity.</maml:para>
              <maml:para>If the computer has only a single network adapter, this alert arrives only after network connectivity has been reestablished. In this case, you can resolve the alert without taking any additional action.</maml:para>
              <maml:para>If the computer has multiple network adapters, the alert may arrive before network connectivity for the effected adapter has been reestablished. However, remote clients and applications may still have difficulty accessing resources on the computer despite the other adapter or adapters. In addition, the local computer may not be able to access some network resources.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Your computer's network adapter lost its connection to the network.</maml:para>
              <maml:para>The adapter's connection to the network can be lost if you remove a network cable from your network adapter or if you are roaming between wireless access points with a mobile system. Other possible causes include network issues, firewall issues, or a malfunction of the network adapter or its driver.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If your computer is connected to the network by cable, confirm that the cable is plugged in properly. If you have a wireless network connection, confirm that you have a signal and the proper credentials for the wireless network.</maml:para>
              <maml:para>If the network connection is working properly, check the following possible causes and take corrective action:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The network is down.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The firewall on your computer is blocking network broadcast traffic.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Your computer's network adapter or driver is not functioning correctly.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.CheckingFileSystemOccuredOnStartup.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a CHKDSK operation was execute during Operating System startup.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection Rule for Checking the File System Occurred on Startup is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Checking the File System Occurred on Startup" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.CleanShutdown.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a clean shutdown of the Operating system has occurred.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection Rule for Windows Clean Restart Events is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Windows Clean Restart Events" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ComputerbrowserServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Computer Browser service maintains a list of computer names that are on the network and supplies this list to clients. The service assists in the name resolution process and is used for non-Active Directory enabled networks and backward compatibility with client computers that are running Windows NT 4.0. If this service is stopped clients in non-Active Directory enabled networks and Windows NT 4.0 clients may not be able to reach computers by name.</maml:para>
              <maml:para>Please note that this monitor is not running on Nano Server (the state of the monitor will be always Healthy).</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service was stopped by an Administrator.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The service can be restarted using the Services snap-in which can be accessed through the Computer Management console task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Computer Management Console</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DHCPClientServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The DHCP Client service which manages network configuration by registering and updating IP addresses and DNS names is not running. Computers that depend on the DHCP will not be able to connect to network resources when the service is stopped.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service was stopped by an Administrator.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The service can be restarted using the Services snap-in which can be accessed through the Computer Management console task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Computer Management Console</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DirtyShutdown.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a dirty (for example; power off) shutdown of the Operating system has occurred.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection Rule for Windows Dirty Shutdown Events is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Windows Dirty Shutdown Events" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.DNSClientServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The DNS Client service resolves and caches Domain Name System (DNS) names. If this service is stopped, a computer will not be able to resolve DNS names and locate Active Directory domain controllers.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service was stopped by an Administrator.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The service can be restarted using the Computer Management Console Task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Computer Management Console</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogFull.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule generates an alert whenever an event log becomes full. Once an event log becomes full, new event instances are discarded. As a result, critical information is not collected and the systems health-related issues may go undetected.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>This rule will generate an alert when any of the following events occur in the System Event Log:</maml:para>
              <maml:para>The %1 log file is full.</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Source: Event log; Event ID: 6000 The %1 log file is full.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>The event log has reached capacity. The most-likely cause for this is that the log is configured with one of the following log size configurations:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Overwrite events older than N days</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Do not overwrite events (Clear log manually)</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve this Alert, perform the following procedures:</maml:para>
              <maml:para>
                <maml:ui>Save Log File and Clear</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open Event Viewer.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Right-click the appropriate event log and click <maml:ui>Properties</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Click the <maml:ui>Clear Log</maml:ui> button.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If appropriate, save the log file.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>
                <maml:ui>Update log file configuration</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open Event Viewer.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Right-click the appropriate event log and click <maml:ui>Properties</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Click <maml:ui>Overwrite as needed</maml:ui> or <maml:ui>Overwrite events older than N days</maml:ui>. In cases where <maml:ui>Overwrite events older than N days</maml:ui>  is clicked, you must adjust the days value so that grooming of the events can keep up with, or exceed, the addition of new events to the log.
                  </maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Event Log service enables event log messages issued by Windows-based programs and components to be viewed in Event Viewer. The service cant be stopped through administrative action and is required for the Operating System to function.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If this service is stopped, the Operating System should be restarted. If restarting the service doesnt resolve the issue and the Operating System is unable to boot in Normal Mode the configuration of the service may need to be updated in Safe Mode. Once in Safe Mode the service should be configured with a startup type of Automatic and the Log On configuration should be set to Local System.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.IPAddressConflict.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule generates an alert when Windows detects that he local machines IP address is in conflict with one or more identical IP addresses on the network.</maml:para>
              <maml:para>Until the IP address conflict is resolved, remote clients and applications may have difficulty accessing resources on any of the effected computers. Additionally, the local computer may not be able to access network resources.</maml:para>
              <maml:para />
              <maml:para>Related Events</maml:para>
              <maml:para>This rule generates an alert whenever the following events occur and are recorded in the System Event Log:</maml:para>
              <maml:para>The system detected an address conflict for IP address %2 with the system having network hardware address %3. The local interface has been disabled.</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Source: TCPIP; Event ID: 4198; The system detected an address conflict for IP address %2 with the system having network hardware address %3. The local interface has been disabled.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: TCPIP; Event ID: 4199; The system detected an address conflict for IP address %2 with the system having network hardware address %3. Network operations on this system may be disrupted as a result.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Another computer on the network is using the same IP address.</maml:para>
              <maml:para>There is a duplicate media access control (MAC) address on the network. Duplicate MAC addresses can occur if you are assigning locally administered addresses (LAA), usually in Token Ring adapter drivers.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If there is an IP address conflict and your network uses Dynamic Host Configuration Protocol (DHCP), DHCP can automatically supply a new IP address:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Go to the command line</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Type <maml:ui>ipconfig /release</maml:ui> and press ENTER
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Type i <maml:ui>pconfig /renew</maml:ui> and press ENTER
                  </maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>If there is an IP address conflict and your network uses static IP addresses, obtain an available unique IP address from your network administrator and replace the current IP address with the new IP address.</maml:para>
              <maml:para>If there is a duplicate MAC address on the network, you must determine which other computer on the network is using the same MAC address. To isolate the duplicate MAC address, perform the following steps from a working TCP/IP-based client:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>
                    From the command line, ping the IP address found in the event log entry by typing <maml:ui>PING</maml:ui><maml:ui>%IP Address%.</maml:ui></maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Verify that the devices MAC address is the duplicate of the address found in the event log by typing <maml:ui>ARP -a %IP Address%.</maml:ui></maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Retrieve the NetBIOS name of the duplicate computer by typing <maml:ui>NBTSTAT -a %IP Address%.</maml:ui></maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>A Host Not Found message indicates that the duplicate device is not NetBIOS-enabled. Examples of devices that are not NetBIOS-enabled include Novell and UNIX servers, routers, and printers directly attached to the network.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>After you locate the device with the duplicate address, you can either replace the network adapter or, if you are using LAA, change the address to one that is unique on the network.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>External</maml:title>
              <maml:para>
                For more information, see Microsoft Knowledge Base Article: 164903, How to Troubleshoot Duplicate Media Access Control Address Conflicts, at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=28866</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=28866" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.LDMCantReadDisk.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This event indicates that the Logical Disk Manager was unable to read data from or write data to a dynamic disk.</maml:para>
              <maml:para>This event could be caused by bad disk sectors, or could indicate a total failure of the disk.</maml:para>
              <maml:para>The data integrity of the volumes residing on the disk might be affected by the failures. Any applications using these volumes might experience errors.</maml:para>
              <maml:para>This event is posted to the system log by Dmio.sys. The system log might contain additional information from other storage drivers that indicates the cause of the failure.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>Event Type: Information</maml:para>
              <maml:para>Event Source: dmio</maml:para>
              <maml:para>Event Category: None</maml:para>
              <maml:para>Event ID: 29</maml:para>
              <maml:para>Date:  MM/DD/YYYY</maml:para>
              <maml:para>Time:  HH:MM:SS AM/PM</maml:para>
              <maml:para>User:  N/A</maml:para>
              <maml:para>Computer:       Computer_Name</maml:para>
              <maml:para>Description:</maml:para>
              <maml:para>dmio: Hard disk 9 read error at block 445136247: status 0xC000009A</maml:para>
              <maml:para>Event Type: Warning</maml:para>
              <maml:para>Event Source: dmio</maml:para>
              <maml:para>Event Category: None</maml:para>
              <maml:para>Event ID: 35</maml:para>
              <maml:para>Date:  MM/DD/YYYY</maml:para>
              <maml:para>Time:  HH:MM:SS AM/PM</maml:para>
              <maml:para>User:  N/A</maml:para>
              <maml:para>Computer:       Computer_Name</maml:para>
              <maml:para>Description:</maml:para>
              <maml:para>dmio: Disk Hard disk 9 block 445136247 (mount point F:): Uncorrectable read error</maml:para>
              <maml:para>Event Type: Information</maml:para>
              <maml:para>Event Source: dmio</maml:para>
              <maml:para>Event Category: None</maml:para>
              <maml:para>Event ID: 30</maml:para>
              <maml:para>Date:  MM/DD/YYYY</maml:para>
              <maml:para>Time:  HH:MM:SS AM/PM</maml:para>
              <maml:para>User:  N/A</maml:para>
              <maml:para>Computer:       Computer_Name</maml:para>
              <maml:para>Description:</maml:para>
              <maml:para>dmio: Hard disk 2 write error at block 411779656: status 0xC000009A</maml:para>
              <maml:para />
              <maml:para>Related Events</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Dmio: Event ID 29</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Dmio: Event ID 30</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Dmio: Event ID 31</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Dmio: Event ID 32</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>Other relevant status codes are:</maml:para>
              <maml:para>0xC000000E STATUS_NO_SUCH_DEVICE = A device which does not exist was specified.</maml:para>
              <maml:para>0xC0000185 STATUS_IO_DEVICE_ERROR = The I/O device reported an I/O error.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Possible causes include:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>A hardware failure that prevents communication with the disk (for example, a disk, controller, or cable failure).</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Uncorrectable bad sectors on the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>An unexpected removal of the disk.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Do one or more of the following:</maml:para>
              <maml:para>1. Open the Disk Management snap-in.</maml:para>
              <maml:para>2. Rescan the disks and then reactivate any disks with errors. Resynchronize or regenerate the volume as necessary if the disk was a member of a mirrored or RAID-5 volume.</maml:para>
              <maml:para>
                3. Run <maml:ui>chkdsk</maml:ui> on any reactivated volumes.
              </maml:para>
              <maml:para>Check the status of your hardware for any failures (for example, a disk, controller, cabling failure). In most cases, the system log contains additional events from the lower-level storage drivers that indicate the cause of the failure.</maml:para>
              <maml:para>After you have isolated and resolved the hardware problem:</maml:para>
              <maml:para>1. Open the Disk Management snap-in.</maml:para>
              <maml:para>2. Rescan the disks and then reactivate any disks with errors. Resynchronize or regenerate the volume as necessary if the disk was a member of a mirrored or RAID-5 volume.</maml:para>
              <maml:para>
                3. Run <maml:ui>chkdsk</maml:ui> on any reactivated volumes.
              </maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>External</maml:title>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>http://go.microsoft.com/fwlink/?LinkId=25824</maml:linkText>
                  <maml:uri href="http://go.microsoft.com/fwlink/?LinkId=25824" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Available MBytes (Memory\Available MBytes) for the system has fallen below threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>Available MBytes is the amount of physical memory that is available for use by applications and processes.</maml:para>
              <maml:para>The default memory threshold value is 100MB</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>The amount of available physical memory can become low under the following circumstances:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Too many applications are running simultaneously on the computer.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>An application may be leaking memory over time.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Memory\Available MBytes counter you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Memory Available MBytes Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.MemoryAvailableMBytes.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>To address a low physical memory condition an administrator may chose one or more of the following options:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Close or stop one or more applications, services, processes.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Add additional Physical Memory to the computer.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Move applications to one or more additional servers.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>If the system has been adequately provisioned with physical memory and application load but it continually exceeds the available physical memory threshold over time, it is possible that an application is leaking memory. To identify an application that is leaking memory, do the following:</maml:para>
              <maml:para />
              <maml:para>Open System Monitor and monitor the following system wide performance counters over time:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Paging File\% Usage</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Paging File\%</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Memory\Pool Nonpaged Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Memory\Pool Paged Bytes</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>If any one of these counters continually increase over time, it is possible that an application may be leaking memory.</maml:para>
              <maml:para>If the system appears to be leaking memory, the specific application can be identified by monitoring the following counters for each running process:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Process\Page File Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Pool Nonpaged Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Pool Paged Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Private Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Thread Count</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
              </maml:list>
              <maml:para>If you observe a consistent and significant increase in any of these counters, it may be necessary to contact the application vendor for support.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>
                For more information about monitoring memory counters, see the Microsoft Windows 2000 Server Documentation Web site at: <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27750</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27750" /></maml:navigationLink>.
              </maml:para>
              <maml:para />
              <maml:para>
                For more information about memory objects, see the MSDN Web site at: <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27751</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27751" /></maml:navigationLink>.
              </maml:para>
              <maml:para />
              <maml:para>
                For more information about evaluating memory and cache usage, see the Microsoft Windows 2000 Resource Kit Web site at: <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27681</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27681" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryAvailableMBytes.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Available Mbytes performance counter.</maml:para>
              <maml:para>The Physical Disk\Pages Writes/sec performance counter exposes the amount of physical memory available to processes running on the computer, in Megabytes, rather than bytes as reported in Memory\Available Bytes. It is calculated by adding the amount of space on the Zeroed, Free, and Stand by memory lists. Free memory is ready for use; Zeroed memory are pages of memory filled with zeros to prevent later processes from seeing data used by a previous process; Standby memory is memory removed from a process' working set (its physical memory) on route to disk, but is still available to be recalled.  This counter displays the last observed value only; it is not an average.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageReadsPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Page Reads/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Pages Reads/sec performance counter exposes the rate at which the disk was read to resolve hard page faults. It shows the number of reads operations, without regard to the number of pages retrieved in each operation. Hard page faults occur when a process references a page in virtual memory that is not in working set or elsewhere in physical memory, and must be retrieved from disk. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It includes read operations to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. Compare the value of Memory\Pages Reads/sec to the value of Memory\Pages Input/sec to determine the average number of pages read during each operation.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Pages/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Pages/sec performance counter exposes the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays.  It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec.  It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPageWritesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Page Writes/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Pages Writes/sec performance counter exposes the rate at which pages are written to disk to free up space in physical memory. Pages are written to disk only if they are changed while in physical memory, so they are likely to hold data, not code.  This counter shows write operations, without regard to the number of pages written in each operation.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPercentCommittedBytesInUse.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\% Committed Bytes In Use performance counter.</maml:para>
              <maml:para>The Physical Disk\% Committed Bytes In Use performance counter exposes the committed memory (physical memory) in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is determined by the size of the paging file.  If the paging file is enlarged, the commit limit increases, and the ratio is reduced). This counter displays the current percentage value only; it is not an average.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolNonPagedBytes.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Pool Nonpaged Bytes performance counter.</maml:para>
              <maml:para>The Physical Disk\Pool Nonpaged Bytes performance counter exposes the size, in bytes, of the non paged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\Pool Nonpaged Bytes is calculated differently than Process\Pool Nonpaged Bytes, so it might not equal Process\Pool Nonpaged Bytes\_Total.  This counter displays the last observed value only; it is not an average.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolPagedBytes.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Pool Paged Bytes performance counter.</maml:para>
              <maml:para>The Physical Disk\Pool Paged Bytes performance counter exposes the size, in bytes, of the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used.  Memory\Pool Paged Bytes is calculated differently than Process\Pool Paged Bytes, so it might not equal Process\Pool Paged Bytes\_Total. This counter displays the last observed value only; it is not an average.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NetworkAdapterDisconnected.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a network adapter has lost network connectivity.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection rule for Network Adapter was Disconnected from the Network is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection rule for Network Adapter was Disconnected from the Network" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSDelayedWriteLost.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>Microsoft Windows was unable to write the data cache from memory to the disk. This error might have been caused by a failure of your computer hardware or network connection.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Possible causes include:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>If you were writing to removable media (such as a floppy disk or CD-R), the media might have been taken away before the data cache could be cleared.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The disk resource that you were writing to went offline.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>You were writing to a remote disk and the network connection between your computer and the remote disk was severed.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Check the network connection.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Check the disk integrity. For disks that are formatted with the NTFS file system, you should examine the disk because it might be nearing failure.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Review the application log in Event Viewer for the file name.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Check the system or application logs for entries related to the disk stack. If there are entries in the logs related to the disk stack, it is likely that the event occurred because of a hardware failure.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>External</maml:title>
              <maml:para>
                For more information about Event ID 50, see Knowledge Base article 816004 Description of the Event ID 50 Error Message, at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=25977</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=25977" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSFileSystemCorrupt.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The file system on the volume might be corrupt due to one or more of the following reasons:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The disk might have bad sectors.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>I/O requests issued by the file system to the disk subsystem might not have been completed successfully.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:list>
                <maml:listItem>
                  <maml:para>The disk might have bad sectors.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>I/O requests issued by the file system to the disk subsystem might not have been completed successfully.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Check the state of the file system and repair it if necessary.</maml:para>
              <maml:para>
                <maml:ui>To check the state of the file system</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>
                    At a command prompt, type <maml:ui>chkntfs</maml:ui> %drive letter:%
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Check the message from <maml:ui>chkntfs</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    If <maml:ui>chkntfs</maml:ui> displays the message %drive letter%: is dirty, the volume is corrupt. In this case, repair the file system using the <maml:ui>chkdsk /r</maml:ui> command.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    If <maml:ui>chkntfs</maml:ui> displays the message %drive letter%: is not dirty, the volume is not corrupt and no further action is required.
                  </maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>
                <maml:ui>To repair the file system</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Save any unsaved data, close any open programs, and restart the computer.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Windows automatically runs <maml:ui>chkdsk /r</maml:ui> on dirty (corrupt) volumes to check and repair them.
                  </maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>
                You can also run <maml:ui>chkdsk</maml:ui> manually using the following steps.
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>
                    At a command prompt, type <maml:ui>chkdsk /x</maml:ui> %drive letter%:
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    <maml:ui>Chkdsk</maml:ui> runs and automatically repairs the volume.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    If <maml:ui>chkdsk</maml:ui> displays the following message, type <maml:ui>Y</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Cannot lock current drive. Chkdsk cannot run because the volume is in use by another process. Would you like to schedule this volume to be checked the next time the system restarts?</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Windows will automatically run <maml:ui>chkdsk</maml:ui> the next time the computer is started.
                  </maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>
                If you regularly see NTFS Event ID 41 or Event ID 55 in Event Viewer, run <maml:ui>chkdsk</maml:ui> using the <maml:ui>/r</maml:ui> option. This option allows <maml:ui>chkdsk</maml:ui> to locate bad sectors on the hard disk.
              </maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>External</maml:title>
              <maml:para>
                For more information about the chkdsk /c and /i switches, see Knowledge Base article 187941 An Explanation of CHKDSK and the New /C and /I Switches at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=25770</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=25770" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about NTFS recoverability, see Knowledge Base article 101670 Transaction Log Supports NTFS Recoverability, at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=25981</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=25981" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSQuotaThresholdLimitReached.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a NTFS Quota limit threshold has been reached on a operating system.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection rule for NTFS Quota Threshold Limit Reached is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection rule for NTFS Quota Threshold Limit Reached" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.NTFSQuotaThresholdReached.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a NTFS Quota threshold has been reached on a operating system.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection rule for NTFS Quota Threshold Reached is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection rule for NTFS Quota Threshold Reached" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PageFilePercentUsage.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Page File\% Usage performance counter.</maml:para>
              <maml:para>The Physical Disk\Pool Paged Bytes performance counter exposes the Page File instance in use in percent.  See also Process\Page File Bytes.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PercentCommittedBytesInUse" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The % Committed Bytes In Use (Memory\% Committed Bytes In Use) for the system has exceeded the threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>The % Committed Bytes In Use performance counter represents the ratio of Memory\Committed Bytes to the Memory\Commit Limit. Committed Bytes is the amount of committed virtual memory while Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s).</maml:para>
              <maml:para>When this performance threshold has been exceeded, it often indicates that the page file could not be expanded, or expanded fast enough, to satisfy application memory requirements.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>The amount of available physical memory can become low under the following circumstances:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Too many applications are running simultaneously on the computer.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>An application may be leaking memory over time.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To confirm whether excessive paging is occurring, add the Avg. Disk sec/Transfer (a physical disk counter) and Pages/sec counter values. If the product of these counters exceeds 0.1, paging is taking more than 10 percent of disk access time. If this occurs over a long period, you probably need more memory.</maml:para>
              <maml:para />
              <maml:para>Next, check for excessive paging due to running applications. If possible, stop the application with the highest working set value, and see if that dramatically changes the paging rate. If you suspect excessive paging, check the Pages/sec counter in System Monitor. This counter, which is part of the Memory object type, shows the number of pages that had to be read from disk because they were not in physical memory. (Notice the difference between this counter and Page Faults/sec, which indicates only that data was not immediately available in the specified working set in memory.)</maml:para>
              <maml:para />
              <maml:para>To address a low physical memory condition an administrator may chose one or more of the following options:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Close or stop one or more applications, services, processes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Add additional Physical Memory to the computer</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Move applications to one or more additional computers (applicable to Servers only)</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>If the system has been adequately provisioned with physical memory and application load but it continually exceeds the available physical memory threshold over time its possible that an application is leaking memory. To identify an application that is leaking memory an administrator can do the following:</maml:para>
              <maml:para>Open up System Monitor and monitor the following system wide performance counters over time:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Paging File\% Usage</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Paging File\%</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Memory\Pool Nonpaged Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Memory\Pool Paged Bytes</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>If any one of these counters continually increase over time it is possible that an application may be leaking memory. To view recent history for these performance counters you can use the following view:</maml:para>
              <maml:para />
              <maml:para>If the system appears to be leaking memory, the specific application can be identified by monitoring the following counters for each running process using System Monitor:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Process\Page File Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Pool Nonpaged Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Pool Paged Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Private Bytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Process\Thread Count</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>If a consistent and significant increase in any of these counters is observed it may be necessary to contact the application vendor for support.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PerfCounterDataRequestTimeOut.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The performance counter provider for this service was not able to return performance counter data within the specified collect time-out period. This period varies for each performance counter and can be changed.</maml:para>
              <maml:para>System health is not affected, only the ability to collect performance counter data. Until this problem is resolved, any rule that is monitoring this counter for alerts will not be activated.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>The time-out waiting for the performance data collection function CollectSysProcessObjectData in the Perfproc.dll library has expired. There may be a problem with this extensible counter or the service it is collecting data from or the system may have been very busy when this call was attempted.</maml:para>
              <maml:para />
              <maml:para>Related Events:</maml:para>
              <maml:para>Source: Perflib;</maml:para>
              <maml:para>Event ID: 1015</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either there is a problem with the performance counter provider or service it is collecting data from, or the system was too busy when the request was generated.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If you experience problems due to open or collect timeouts, you can change the default open or collect time-out period for the provider or service that is reporting the error.</maml:para>
              <maml:para>By default, the operating system uses the same collect or open time-out period of 10 seconds (measured in milliseconds) for all services. To override this time-out period for an individual service, change the Open Timeout or the Collect Timeout registry entry.</maml:para>
              <maml:para>The following procedure applies to the Collect Timeout entry but the same procedure can be applied to the Open Timeout entry.</maml:para>
              <maml:para>
                <maml:ui>Caution</maml:ui>
              </maml:para>
              <maml:para>Incorrectly editing the registry may severely damage your system. Before making changes to the registry, you should back up any valued data on the computer.</maml:para>
              <maml:para>
                <maml:ui>To change the Collect Timeout registry entry:</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>
                    On the <maml:ui>Start</maml:ui> menu, click <maml:ui>Run</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Type <maml:ui>regedit.exe</maml:ui>, and then click <maml:ui>OK</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    In the registry editor navigate to <maml:ui>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\%service-name%\Performance</maml:ui> . The performance counter provider service that was not able to return performance counter data within the specified collection period is identified as the %service-name%. For example, if the performance counter provider for the Telephony service was not able to return performance counter data within the specified collection period, you would navigate to <maml:ui>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Telephony\Performance</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    If the entry exists, double-click the <maml:ui>Collect Timeout</maml:ui> entry.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    In the <maml:ui>Edit DWORD Value</maml:ui> dialog box, change the length of time in the Value data box to a value greater than the present value. The default value is ten seconds.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If the entry does not exist, create the entry as follows:</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    a. In the registry editor, on the <maml:ui>Edit</maml:ui> menu, click <maml:ui>New</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    b. Click <maml:ui>DWORD Value</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    c. Type <maml:ui>Collect Timeout</maml:ui> for the value name.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    d. Double-click <maml:ui>Collect Timeout</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    e. In the <maml:ui>Edit DWORD Value</maml:ui> dialog box, enter a length of time in the <maml:ui>Value data</maml:ui> box which is a value greater than the present value. The default value is ten seconds.
                  </maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>External</maml:title>
              <maml:para>
                For more information about performance and reliability monitoring, see the Microsoft TechNet Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27756</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27756" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about performance counter unavailability, see Knowledge Base Article 275659, Corrupted Performance Counters May Disappear or Be Unavailable to Perfmon, at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27763</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27763" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about troubleshooting performance counters, see Microsoft Knowledge Base Article: 152513, Troubleshooting Performance Monitor Counter Problems, at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=30322</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=30322" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PerformanceRegistryCorruption.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>There were problems registering the Performance Counter provider specified in the event in the registry, or the integrity of the registry interface that is used to maintain performance counters has become corrupted.</maml:para>
              <maml:para>The performance counter infrastructure uses the registry interface to maintain a list of the performance counters that have been installed on the system for each localized language.</maml:para>
              <maml:para>Until the problem is resolved, applications that query performance counters will find that some or all of the counters specified in the event are not available.  One such application is Windows System Monitor.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Registry keys for the performance infrastructure have been manually edited and corrupted the integrity of the infrastructure.</maml:para>
              <maml:para>Another application that exposes performance counters have written over existing keys or incorrectly changed the values.</maml:para>
              <maml:para>The LODCTR tool provided by Microsoft and used to install performance counters failed to install the performance counter provider.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>
                On Windows Server 8 systems, the registry integrity can be restored by typing <maml:ui>Lodctr /R</maml:ui> at the command line.
              </maml:para>
              <maml:para>
                On earlier versions of Windows, you must rebuild the registry integrity. For more information about rebuilding performance counter library values, see KB article 300956, How to Manually Rebuild Performance Counter Library Values, at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=28515</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=28515" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>External</maml:title>
              <maml:para>
                For more information about troubleshooting performance counters, see Microsoft Knowledge Base Article: 152513, Troubleshooting Performance Monitor Counter Problems, at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=30322</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=30322" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.PlugandPlayServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Plug and Play service enables a computer to detect and configure new hardware devices. If this service is stopped new hardware that is installed will not be detected, configured, or available to the Windows Operating System.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service was stopped by an Administrator.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The service can be restarted using the Services snap-in which can be accessed through the Computer Management console task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Computer Management Console</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RebootFromBugCheck.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a Operating system crash has occurred.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>
                  The Collection Rule for Windows Restart Events (restarted from bug check) is disabled by default. Here is how to enable: </maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Windows Restart Events (restarted from bug check)" in the "Look for" and click on find now. </maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RestartEvent.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a restart of the Operating system has occurred.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection Rule for Windows Restarted Events is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Windows Restarted Events" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.RPCServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Remote Procedure Call (RPC) service is a protocol that applications can use to request a service from an application located on another computer.  The service cant be stopped through administrative action and is required for the Operating System to function.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If this service is stopped, the Operating System should be restarted. If restarting the service doesnt resolve the issue and the Operating System is unable to boot in Normal Mode the configuration of the service may need to be updated in Safe Mode. Once in Safe Mode the service should be configured with a startup type of Automatic and the Log On configuration should be set to Local System.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceConfiguration.Rule" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule will generate an alert any time a service attempts to start up with an invalid configuration. In this case, the alert has warning-level severity, denoting that while the services configuration was detected as invalid, the service was still able to start successfully. However, the service may not be running in the desired configuration.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>This alert occurs when the services configuration parameters in the registry are invalid. An invalid configuration may occur for the following reasons:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service itself experienced an error while updating the configuration settings.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The configuration value may have been incorrectly modified through manual administrative action.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Another application incorrectly modified the services configuration settings.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The first step in resolving this alert is to determine which service generated it.</maml:para>
              <maml:para>To determine the service name refer to the description of the alert. This description contains the following information:  The value named %1 in the server's registry key %2 was not valid and was ignored.</maml:para>
              <maml:para>The %1 and %2 parameters of the event listed above will be populated in the actual alert description. The first part of the second parameter (%2) is the name of the service.</maml:para>
              <maml:para>Once the service name has been determined, the parameter that is incorrectly configured can be determined through the first parameter (%1).</maml:para>
              <maml:para>After the service and parameter names are known, the support engineer should attempt to determine if the service configuration parameters can be modified through a user interface that the application provides. If so, this is the best way to fix the configuration. In some cases the configuration must be changed to an alternate configuration and then updated to the desired configuration before the correct settings can be configured.</maml:para>
              <maml:para>If a user interface is not provided, the support engineer may choose to modify the relevant parameter directly. This is performed in the following registry location and requires advanced knowledge of the parameter configuration options.</maml:para>
              <maml:para>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\%ServiceName\Parameters\%Parameter Name%</maml:para>
              <maml:para>If these options are unable to help resolve the issue, the application vendor may need to be contacted for support.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServerServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Server service enables Windows to perform file and print sharing over the network. If this service is stopped Windows will be unable to share file and print services.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service was stopped by an Administrator.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The service can be restarted using the following task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start the Server service</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.StartServerService.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceEnteredUnpredictableState.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule generates an alert when the Service Control Manager detects that a service has started with an invalid configuration. It is important to note that even though the Service Control Manager detected an invalid configuration, the service still started successfully.</maml:para>
              <maml:para>The service may not be running as expected and may behave in an unpredictable manner. Additionally, the service may not be able to be restarted until the issue is resolved.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>This rule generates an alert whenever any of the following events occur and are recorded in the System Event Log:</maml:para>
              <maml:para>The %1 service is marked as an interactive service.  However, the system is configured to not allow interactive services.  This service may not function properly.</maml:para>
              <maml:para>The Service Control Manager encountered an error that has undone a configuration change to the %1 service.  The service's %2 is currently in an unpredictable state. If you do not correct this configuration, you may not be able to restart the %1 service or you may encounter other errors. To ensure that the service is configured properly, use the Services snap-in in MMC.</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7030 The %1 service is marked as an interactive service.  However, the system is configured to not allow interactive services.  This service may not function properly.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7037 The Service Control Manager encountered an error that has undone a configuration change to the %1 service.  The service's %2 is currently in an unpredictable state. If you do not correct this configuration, you may not be able to restart the %1 service or you may encounter other errors. To ensure that the service is configured properly, use the Services snap-in in MMC.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>This alert is generated whenever any of the following conditions occur:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service is configured to run interactively but system policy is configured to prevent services from running in this mode.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>An error occurred while attempting to configure the service.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>There are two possible resolutions for this alert. Refer to the event that generated the alert and select the appropriate set of resolution steps.</maml:para>
              <maml:para>Event ID: 7030</maml:para>
              <maml:para>To resolve this alert, consult with a subject matter expert or the vendor to determine if the service must run interactively on the desktop. If not, follow these steps:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Services MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Double-click the appropriate Service and open that services property sheet.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Click the <maml:ui>Log On</maml:ui> tab.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Clear the <maml:ui>Allow service to interact with desktop</maml:ui> check box.
                  </maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>If the service must run interactively, you will need to change the Allow service to interact with desktop system policy. To do this, perform the following steps:</maml:para>
              <maml:para>HKLM\System\CCC\Control\Windows</maml:para>
              <maml:para>0 - Enabled</maml:para>
              <maml:para>1 - Disabled</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Registry Editor.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Navigate to the registry value NoInteractiveServices at: HKLM\System\CCC\Control\Windows</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Set the value from 0 to 1 0 - Enabled1 - Disabled</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Open the Services MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Select the appropriate Service and restart it.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>Event ID: 7037</maml:para>
              <maml:para>Resolve this alert by doing the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Services MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Double-click the appropriate service and open that services property sheet.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Click each of the tabs and verify that the configuration information is appropriate. Update any configuration fields that have incorrect or corrupted data in them.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Restart the service and check the event log to determine whether another instance of event 7037 has occurred. If not, the issue has been resolved.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    If a new instance of event 7037 occurs, use Sc.exe to examine the services advanced configuration settings and then update them as appropriate. Use the <maml:ui>qc</maml:ui> and <maml:ui>config</maml:ui> commands within Sc.exe to view and configure the service.
                  </maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceMisconfigured.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>Each of these events indicates that a services configuration is incorrect and that the service might not be able to start up appropriately.  This alert is generated when any one of the following Service Control Manager events occur:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>7015: a boot-start or system-start driver service has a dependency on other individual services to start. (Boot-start and system-start driver services cannot depend on another service, but can depend on a service group.)</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>7017: This issue occurs because the  manually started services have a circular dependency chain, for example, service A depends on service B which depends on service C which depends on service A.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>7018: This issue occurs because the auto started services have a circular dependency chain, for example, service A depends on service B which depends on service C which depends on service A.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>7019: This issue occurs because the  manually started services have a circular dependency chain, for example, service A depends on service B which depends on service C which depends on service A.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>7020: This issue occurs because the  manually started services have a circular dependency chain, for example, service A depends on service B which depends on service C which depends on service A.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>The Service Control Manager has generated an event indicating that a service failed to start due to the service having an invalid configuration, such as the service having a circular dependency with another service.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve this issue, follow the steps below:</maml:para>
              <maml:para>7015: To resolve this issue, change the dependency of the boot-start or system-start driver service indicated in the event message text.  To perform this procedure, you must have membership in Administrators, or you must have been delegated the appropriate authority.  To list the dependent services for a service and modify the dependencies:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>At a command prompt, type sc qc service_name to view the other services on which service_name is dependent.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Type sc config service_name depend= +group_name (where group_name is the name of any dependent service group) to remove dependencies on individual services.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Note: If the service has no dependent service groups, enter a null value for the depend parameter.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>7017: To resolve this issue, remove the circular dependency.  To perform this procedure, you must have membership in Administrators, or you must have been delegated the appropriate authority.  To list the dependent services or service groups for a service and remove the circular dependencies:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>At a command prompt, type sc qc service_name to view the other services and service groups on which service_name is dependent.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Type sc config service_name depend= service_name/+group_name (where service_name is the name of any noncircular dependent service and group_name is the name of any noncircular dependent service group) to remove dependencies on individual circular services or service groups.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>7018: To resolve this issue, remove the circular dependency.  To perform this procedure, you must have membership in Administrators, or you must have been delegated the appropriate authority.  To list the dependent services for a service and remove the circular dependencies:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>At a command prompt, type sc qc service_name to view the other services on which service_name is dependent.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Type sc config service_name depend= service_name/+group_name (where service_name is the name of any noncircular dependent service and group_name is the name of any noncircular dependent service group) to remove dependencies on individual circular services or service groups.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Note: If the service has no dependent services or service groups, enter a null value for the depend parameter.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>7019: To resolve this issue, remove the circular dependency.  To perform this procedure, you must have membership in Administrators, or you must have been delegated the appropriate authority.  To list the dependent services or service groups for a service and remove the circular dependencies:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>At a command prompt, type sc qc service_name to view the other services on which service_name is dependent.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Type sc config service_name depend= service_name/+group_name (where service_name is the name of any noncircular dependent service and group_name is the name of any noncircular dependent service group) to remove dependencies on individual circular services or service groups.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Note: If the service has no dependent service groups, enter a null value for the depend parameter.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>7020: To resolve this issue, remove the circular dependency.  To perform this procedure, you must have membership in Administrators, or you must have been delegated the appropriate authority.  To list the dependent services or service groups for a service and remove the circular dependencies:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>At a command prompt, type sc qc service_name to view the other services and service groups on which service_name is dependent.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Type sc config service_name depend= service_name/+group_name (where service_name is the name of any noncircular dependent service and group_name is the name of any noncircular dependent service group) to remove dependencies on individual circular services or service groups.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Note: If the service has no dependent services or service groups, enter a null value for the depend parameter.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule generates an alert when a Windows service or device driver fails to start.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>This rule will generate an alert when any of the following events occur in the System Event Log:</maml:para>
              <maml:para>The %1 service failed to start due to the following error: %n%2</maml:para>
              <maml:para>The %1 service depends on the %2 service which failed to start because of the following error: %n%3</maml:para>
              <maml:para>No backslash is in the account name.</maml:para>
              <maml:para>Logon attempt with current password failed with the following error: %n%1</maml:para>
              <maml:para>Second logon attempt with old password also failed with the following error: %n%1</maml:para>
              <maml:para>The %1 service has stopped responding on starting.</maml:para>
              <maml:para>The %1 service terminated with the following error: %n%2</maml:para>
              <maml:para>At least one service or driver failed during system startup.  Use Event Viewer to examine the event log for details.</maml:para>
              <maml:para>The following boot-start or system-start driver(s) failed to load: %1</maml:para>
              <maml:para>The %1 service was unable to log on as %2 with the currently configured password due to the following error: %n%3%n%n To ensure that the service is configured properly, use the Services snap-in in Microsoft Management Console (MMC).</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7000; The %1 service failed to start due to the following error: %n%2</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7001; The %1 service depends on the %2 service which failed to start because of the following error: %n%3</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7008; No backslash is in the account name.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7022; The %1 service has stopped responding on starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7023; The %1 service terminated with the following error: %n%2</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7025; At least one service or driver failed during system startup. Use Event Viewer to examine the event log for details.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7026; The following boot-start or system-start driver(s) failed to load: %1</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7038; The %1 service was unable to log on as %2 with the currently configured password due to the following error: %n%3%n%n To ensure that the service is configured properly, use the Services snap-in in Microsoft Management Console (MMC).</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; Event ID: 7041; The %1 service was unable to log on as %2 with the currently configured password due to the following error.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A Windows service or device driver may fail to start for any one of the following reasons:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The account name defined for Log On is not formed correctly.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The password defined for Log On is invalid.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service or driver stopped responding while starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service or driver exited unexpectedly while starting.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>This alert can generate a number of different events, each of which has unique resolution steps that you must follow. Refer to the events associated with this alert to determine the root cause, and then follow the appropriate set of resolution steps listed below.</maml:para>
              <maml:para>
                <maml:ui>Event ID: 7008 - Account name defined in for Log On is malformed.</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Services MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Double-click the appropriate service and open the services property sheet.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Click the <maml:ui>Log On</maml:ui> tab.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Type a correct account name.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>
                <maml:ui>The password defined for Log On is invalid.</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Services MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Double-click the appropriate service and open the services property sheet.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Click the <maml:ui>Log On</maml:ui> tab.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Type the correct password for the specified account name.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>
                <maml:ui>The service or driver stopped responding while starting.</maml:ui>
              </maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Services MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Double-click the appropriate service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Attempt to Start or Restart the service or driver using the menu options.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>
                <maml:ui>The service or driver exited unexpectedly while starting.</maml:ui>
              </maml:para>
              <maml:para>Services</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Services MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Double-click the appropriate service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Start or restart the service or driver using the menu options.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>Drivers</maml:para>
              <maml:para>a. Uninstall the device and rescan for hardware changes</maml:para>
              <maml:para>b. Attempt to update the driver to a more recent version that you obtain from the vendor.</maml:para>
              <maml:para>c. Disable the device.</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Device Manager MMC snap-in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Double-click the device that is associated with the driver.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Using the menu, select one of the following options: a. Uninstall the device and rescan for hardware changes b. Attempt to update the driver to a more recent version that you obtain from the vendor. c. Disable the device.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceOrDriverFailedToStart.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a NT Service or Driver has failed to startup.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection rule for Service or Driver Failed to Start events is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection rule for Service or Driver Failed to Start events" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule generates an alert when a Windows service unexpectedly terminates. In addition to the service termination event, a Windows Error Reporting event (Source: Dr Watson; ID: 4097) is often created and will be collected by Operations Manager. This additional event may prove helpful when attempting to resolve the service termination Alert.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When a service unexpectedly terminates the application, Dr. Watson detects that the application has generated a general protection fault (GPF). A GPF occurs when an application attempts to read or write to a memory location that it does not have access to. This often results in the termination of the program and the loss of unsaved data.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>When a service unexpectedly terminates, you can select one of the following options to address the issue:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Look for related support information at the software vendors Web site.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Install any service pack or product updates for the relevant application.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Install any service packs or updates for any relevant subsystems that the application depends on.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>If the service terminates unexpectedly with unusual frequency, and related support information is unavailable, you should contact the software vendor for support.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>This rule generates an alert whenever any of the following events occur in the System Event Log:</maml:para>
              <maml:para>About to revert to the last known good configuration because the %1 service failed to start.</maml:para>
              <maml:para>The %1 service terminated with the following error: %n%2</maml:para>
              <maml:para>The %1 service terminated with service-specific error %2.</maml:para>
              <maml:para>The %1 service terminated unexpectedly.  It has done this %2 time(s).  The following corrective action will be taken in %3 milliseconds: %5.</maml:para>
              <maml:para>The Service Control Manager tried to take a corrective action (%2) after the unexpected termination of the %3 service, but this action failed with the following error: %n%4</maml:para>
              <maml:para>The %1 service terminated unexpectedly.  It has done this %2 time(s).</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; 7021; About to revert to the last known good configuration because the %1 service failed to start.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; 7023; The %1 service terminated with the following error: %n%2</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; 7024; The %1 service terminated with service-specific error %2.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; 7031; The %1 service terminated unexpectedly.  It has done this %2 time(s).  The following corrective action will be taken in %3 milliseconds: %5.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; 7032; The Service Control Manager tried to take a corrective action (%2) after the unexpected termination of the %3 service, but this action failed with the following error: %n%4</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; 7033; The Service Control Manager did not initialize successfully. The security configuration server (scesrv.dll) failed to initialize with error %1. The system is restarting...</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Source: Service Control Manager; 7034; The %1 service terminated unexpectedly.  It has done this %2 time(s).</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ServiceTerminatedUnexpextedly.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a NT Service has crashed.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection rule for unexpected service terminations is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection rule for unexpected service terminations" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule generates an alert when a file share experiences a configuration issue that prevents it from being made available on the network.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>This rule will generate an alert when any of the following events occur in the System Event Log:</maml:para>
              <maml:para>The server service was unable to recreate the share %1 because the directory %2 no longer exists.  Please run "net share %1 /delete" to delete the share, or recreate the directory %2.</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Source: Server; Event ID: 2511 The server service was unable to recreate the share %1 because the directory %2 no longer exists.  Please run "net share %1 /delete" to delete the share, or recreate the directory %2.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>This alert will occur when a file share points to a folder that has been deleted.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve this alert, perform the following steps:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Open the Computer Management MMC.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    Click <maml:ui>System Tools</maml:ui>, click <maml:ui>Shared Folders</maml:ui>, and then click <maml:ui>Shares</maml:ui>.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    In the details pane, right-click the share you want to remove and click <maml:ui>Stop Sharing</maml:ui>.
                  </maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.ShareConfigurationInvalid.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a file share is incorrectly configured or when the configuration is no longer valid (for example; Folder that Share used no longer exists).</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection rule for invalid Share Configuration Detected is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection rule for invalid Share Configuration Detected" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule will generate an alert any time an update from the Windows Automatic Update service fails to successfully install.</maml:para>
              <maml:para />
              <maml:para>Sample Event:</maml:para>
              <maml:para>This rule will generate an alert when the following event occurs in the System Event Log:</maml:para>
              <maml:para>Installation Failure: Windows failed to install the following update. %1</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Source: Automatic Updates; Event ID: 20 Installation Failure: Windows failed to install the following update. %1</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>This alert most commonly occurs when:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The installation of the update package was interrupted.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The downloaded update package was corrupted.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve this alert, an administrator might choose one of the following options:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Wait for the update package to be automatically downloaded and installed at the next automatic update interval.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Re-attempt installation by going to Windows Update and manually reinstalling the update package.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdateInstallationFailed.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when the installation of a software update failed to complete successfully.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection Rule for Software Update Installation Failed is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Software Update Installation Failed" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdatesInstalled.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a software update has been successfully installed.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection Rule for Software Updates Installation Events is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Software Updates Installation Events" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SoftwareUpdatesScheduledForInstallation.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects events that indicate when a software update has been scheduled for installation.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Collection Rule for Software Updates Scheduled Installation Events is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Collection Rule for Software Updates Scheduled Installation Events" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the Rules to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SystemContextSwitchesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the System\Context Switches/sec performance counter.</maml:para>
              <maml:para>The System\Context Switches/sec performance counter exposes the combined rate at which all processors on the computer are switched from one thread to another.  Context switches occur when a running thread voluntarily relinquishes the processor, is preempted by a higher priority ready thread, or switches between user-mode and privileged (kernel) mode to use an Executive or subsystem service.  It is the sum of Thread\\Context Switches/sec for all threads running on all processors in the computer and is measured in numbers of switches.  There are context switch counters on the System and Thread objects. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.SystemProcessorQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the System\ Processor Queue Length performance counter.</maml:para>
              <maml:para>The System\Processor Queue Length performance counter exposes the number of threads in the processor queue.  Unlike the disk counters, this counter counters, this counter shows ready threads only, not threads that are running.  There is a single queue for processor time even on computers with multiple processors. Therefore, if a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TCPIPNetBiosHelperBrowserServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The TCPIP NetBIOS Helper Browser service enables support for NetBIOS over TCP/IP (NetBT) service and NetBIOS name resolution. If this service is stopped Windows will be unable reach computers and network devices by name.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service was stopped by an Administrator.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The service can be restarted using the Services snap-in which can be accessed through the Computer Management console task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Computer Management Console</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalCPUUtilization" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The CPU Utilization (Processor Information\% Processor Time\_Total  and System Queue Length) for the system processor(s) has exceeded the threshold. Once exceeded overall system performance may diminish significantly which will result in poor operating system and application performance.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>The Total CPU Utilization monitoring routine is a high configurable solution that enables Operators to set threshold values for both the System\Processor Queue and the Processor\% Processor Time\_Total performance counters. When values for both counters have exceeded the defined thresholds for several consecutive samples a state change will occur for the monitor. The number of consecutive samples that must be sampled above the threshold before changing state is also configurable.</maml:para>
              <maml:para />
              <maml:para>The default threshold values for the Total CPU Utilization monitoring routine monitoring routine include:</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Parameter</maml:ui>
                    </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Default Value</maml:ui>
                    </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>CPU Queue Length Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>15</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>CPU Percentage Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>95</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Num Samples</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>3</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para />
              <maml:para>Please note that Overrides can be used to change any of the threshold values that are defined above.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When a computer is under substantial load for a sustained period of time it can be caused by any of the following conditions:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The resource requirements for the application set installed on the computer exceeds the capabilities of the computers hardware configuration.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Demand on the computer resources has increased over time and the computer hardware configuration is no longer able to satisfy increasing demand.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>An application that is running on the computer may have entered into an unhealthy state and is now demanding irregular volumes of system resources.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Processor related performance counters you can use the following view:</maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Processor Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.ProcessorPerformance.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para>To resolve this issue an administrator can perform the following tasks:</maml:para>
              <maml:para>1.  Evaluate the % Processor Utilization counter for each of the processes running on the server. This can be done by using either Task Manager or the Performance Monitoring snap-in. Determine which process(s) are consuming the most resources and monitor them over time to determine whether they appear to be returning to normal performance ranges. If not, addition application specific diagnostics should be performed to determine the most appropriate way to resolve the issue.</maml:para>
              <maml:para>2.  If it is determined that client load has increased over time and the computer is simply no longer able to satisfy demand, perform additional performance monitoring procedures to determine if basic hardware upgrades can enable the computer to return to optimal performance ranges.</maml:para>
              <maml:para>3.  If it has been determined that the application has entered into an unhealthy state, possibly due to a product defect, it might be necessary to restart the application. If the issue persists, you might need to contact the application vendor.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalDPCTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The % DPC Time (Processor Information\% DPC Time\_Total) for the system has exceeded the threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>% DPC Time is the percentage of time that the processor spends receiving and servicing deferred procedure calls (DPCs). DPCs are interrupts that are run at a lower priority than standard interrupts. If a high % DPC Time is sustained there may be a processor bottleneck or an application or hardware related issue that can significantly diminish overall system performance.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high % DPC Time value can be caused by one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Processor bottleneck</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Software-related problem</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Hardware or device driver related problem</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To determine the root cause of a high DPC, rate follow the process outlined below.</maml:para>
              <maml:para>Observe the proportion of the processor time that is spent servicing interrupts and DPCs. To do this, monitor the following counters in real time using System Monitor:</maml:para>
              <maml:para />
              <maml:list>
                <maml:listItem>
                  <maml:para>Processor Information\% Processor Time</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Processor Information\% Interrupt Time</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Processor Information\% DPC Time</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>If a processor instance is running a sustained % Processor Time that is &gt; 85% and it is also spending &gt; 15% of that time servicing Interrupts and/or DPCs, the processor is probably the source of a performance bottleneck. This bottleneck can be addressed by upgrading or adding additional processors to the computer.</maml:para>
              <maml:para>If the processor is running a sustained % Processor Time of &lt; 85% and it is also spending &gt; 15% of that time servicing interrupts and/or DPCs, the performance issue may be the result of either an application or hardware related issue.</maml:para>
              <maml:para>Where a hardware device is the root cause, an administrator will find that the % DPC Time has probably increased substantially over a short period time. This will often occur when new hardware is installed or drivers have been upgraded. If the administrator can isolate the issue to a hardware/device driver issue, it can be addressed by working with the vendor.</maml:para>
              <maml:para>In cases where you are administering a multiprocessor system that does not distribute interrupts symmetrically, you can often improve the distribution of the processor workload by adding network adapters so that there is one adapter for every processor. Generally, you only add adapters when you need to improve the throughput of your system. Network adapters, like any additional hardware, have some intrinsic overhead. However, if one of the processors is nearly always active (that is, if Processor Information: % Processor Time = 100) and more than half of its time is spent servicing DPCs (if Processor Information: % DPC Time &gt; 50), then adding an adapter is likely to improve system performance, as long as the available network bandwidth is not already saturated.</maml:para>
              <maml:para>Where an application is the root cause, you will find that DPCs are probably being blocked by an application that has issued a call that is taking a substantial amount of time to complete. During this time DPCs are blocked and will be queued. To determine which application is the root cause, you must run advanced performance, tracing, and diagnostics to pin point the exact application that is responsible for the performance issue.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentDPCTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor\% DPC Time performance counter.</maml:para>
              <maml:para>The Processor\% DPC Time performance counter exposes the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The % Interrupt Time (Processor Information\% Interrupt Time\_Total) for the system has exceeded the threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>% Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high % Interrupt Time most often indicates that there is a problem with a hardware device.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The % Interrupt Time counter will not specifically identify the device that is causing a high % Interrupt Time. To identify the device use Kernrate Viewer (KrView.exe) or Process Trace Information events to determine which ISRs are being dispatched most frequently.</maml:para>
              <maml:para />
              <maml:para>Once the device has been identified the vendor should be contacted to determine a final resolution.</maml:para>
              <maml:para />
              <maml:para>To view recent Processor Information\% Interrupt Time history you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Processor % Interrupt Time Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.ProcessorInterruptTime_Total.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>
                For more information about the Kernrate Viewer, see the Microsoft Download Center Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27748</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27748" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about the processor object, see the Microsoft Corporation Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27758</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27758" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about analyzing processor activity, see the Microsoft Windows 2000 Resource Kits Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27678</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27678" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentInterruptTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor Information\% Interrupt Time performance counter.</maml:para>
              <maml:para>The Processor Information\% Interrupt Time performance counter exposes the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalPercentProcessorTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor\% Processor Time performance counter.</maml:para>
              <maml:para>The Processor\% Processor Time performance counter exposes the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the duration of the idle thread is active in the sample interval, and subtracting that time from interval duration.  (Each processor has an idle thread that consumes cycles when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It is calculated by monitoring the time that the service is inactive, and subtracting that value from 100%.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsActivation" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>Microsoft Corporation developed Product Activation for Microsoft Windows operating systems to help ensure that each Windows operating system license is installed in compliance with the End User License Agreement (EULA), and that it is not installed on more than the limited number of computers (usually one) allowed by the product EULA. Please note, however, that volume licensed versions of Microsoft Windows Server 8 operating systems do not require activation.</maml:para>
              <maml:para>Notes:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>To perform the activation procedure, you must be a member of the Administrators group on the local computer, or you must have been delegated the appropriate authority. If the computer is joined to a domain, members of the Domain Admins group might be able to perform this procedure.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>For further information about Windows Product Activation, see the "How to" and "Concepts information in help and support center.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Windows Product Activation is not available on 64-bit versions of Windows Server 2016 and above.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>An alert is generated by this rule when Windows has not been activated and the activation threshold is reached. The threshold for this rule is when product activation must occur when 5 days or less.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve this alert, Windows must be activated on the relevant computer. There are a number of ways that this can be done, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Activate Windows on the Internet</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Activate Windows with your modem when you have no Internet service provider</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Activate Windows by phone</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Activate Windows using Microsoft Text Telephone</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>Instructions for each of these methods are listed below.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>Activate Windows on the Internet</maml:ui>
              </maml:para>
              <maml:para>To activate Windows on the Internet, click Start, point to All Programs, and then click Activate Windows. In Windows Product Activation, select Yes, let's activate Windows over the Internet now. After this selection, you will be given the option to register at the same time.</maml:para>
              <maml:para>Notes:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>To perform this procedure, you must be a member of the Administrators group on the local computer, or you must have been delegated the appropriate authority. If the computer is joined to a domain, members of the Domain Admins group might be able to perform this procedure. As a security best practice, consider using the Run as tool to perform this procedure.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>To open a system tools item, click Start, point to Programs, point to Accessories, point to System Tools, and then click the appropriate icon. Click Activate Windows.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Alternatively, you can open the Windows Product Activation Wizard by clicking Start, then Run, and then typing oobe/msoobe /a.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>You are strongly encouraged to activate your Windows operating system before using it in a productive environment to prevent loss of time later.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If you choose not to activate Windows now, reminders will appear periodically during your grace period. After that time has expired, your login process will remain incomplete until activation.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If you have not yet activated your Windows operating system, you can do so at any time by clicking the Windows Activation icon in the Notification Area on the Status Bar on the Desktop to initiate activation.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If you have neither an Internet connection nor a modem, see "Activate Windows by phone" for instructions on how to contact a customer service representative by phone.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Activating any of the Windows operating systems is fast and does not require your name or other personal information.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>
                <maml:ui>Activate Windows with your modem when you have no Internet service provider</maml:ui>
              </maml:para>
              <maml:para>To activate Windows with your modem when you have no Internet service provider:</maml:para>
              <maml:para>
                Click <maml:ui>Start</maml:ui>, point to <maml:ui>All Programs</maml:ui>, and then click <maml:ui>Activate Windows</maml:ui> . In Windows Product Activation, select <maml:ui>Yes, let's activate Windows over the Internet now</maml:ui> . After this selection, you will be given the option to register at the same time.
              </maml:para>
              <maml:para>Notes:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>To perform this procedure, you must be a member of the Administrators group on the local computer, or you must have been delegated the appropriate authority. If the computer is joined to a domain, members of the Domain Admins group might be able to perform this procedure. As a security best practice, consider using the Run as tool to perform this procedure.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>To open a system tools item, click Start, point to Programs, point to Accessories, point to System Tools, and then click the appropriate icon. Click Activate Windows.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Even without Internet service, you can use your modem to activate, or activate and register, your copy of Windows.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>You are strongly encouraged to activate your Windows operating system before using it in a productive environment to prevent loss of time later.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>When Windows operating systems require activation, a shortcut logo appears in the Notification Area on the Status Bar on the Desktop. You can begin the activation process by clicking on this icon. Once you have activated, this icon disappears. Confirm activation by checking with your Application event log.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Alternatively, you can open the Windows Product Activation wizard by clicking Start, then Run, and typing oobe/msoobe /a.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If you choose not to activate now, reminders will appear periodically during the grace period. After that time has expired, you will be required to activate in order to continue to use your Windows operating system.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Activating any of the Windows operating systems is fast and does not require your name or other personal information.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>
                <maml:ui>Activate Windows by phone</maml:ui>
              </maml:para>
              <maml:para>
                To activate Windows by phone click <maml:ui>Start</maml:ui>, click <maml:ui>All Programs</maml:ui> and then click <maml:ui>Activate Windows</maml:ui> . In Windows Product Activation, select Yes, I want to telephone a customer service representative to activate Windows. After you select the appropriate location, you are provided with a telephone number and an installation ID that you can give to the customer service representative to complete the activation process.
              </maml:para>
              <maml:para>Notes:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>To open a system tools item, click Start, point to Programs, point to Accessories, point to System Tools, and then click the appropriate icon. Click Activate Windows.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Alternatively, you can open the Windows Product Activation Wizard by clicking Start, then Run, and typing oobe/msoobe /a.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>You are strongly encouraged to activate your Windows server operating system before using it in a productive environment to prevent loss of time later.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>If you have not yet activated your Windows operating system, you can initiate activation at any time by clicking the Windows Activation icon in the Notification Area. Once you have activated, this icon disappears. If you choose not to activate now, reminders will appear periodically during the grace period. After that time has expired, you will be required to activate in order to continue to use your Windows operating system interactively.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Activating any of the Windows operating systems is fast and does not require your name or other personal information.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>
                <maml:ui>Activate Windows using Microsoft Text Telephone</maml:ui>
              </maml:para>
              <maml:para>To activate Windows using Microsoft Text Telephone dial (800) 718-1599 on your TT/TTY modem from the United States or Canada. Once you are connected to Microsoft, you will be guided by on-screen instructions for activation. You are strongly encouraged to activate your Windows operating system before using it in a productive environment to prevent loss of time later.</maml:para>
              <maml:para>Notes:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Microsoft Text Telephone (TT/TTY) services are available for individuals who are deaf or hard-of-hearing.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>From outside the United States, dial the United States number (716) 871-6859, using your TT/TTY modem, and then follow the on-screen instructions for activation.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>TT/TTY service is available only in English.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>
                To learn more about the Microsoft licensing policies, open the EULA by clicking <maml:ui>Start</maml:ui>, <maml:ui>Run</maml:ui>, and then typing <maml:ui>eula.txt</maml:ui>.
              </maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Microsoft Web site</maml:linkText>
                  <maml:uri href="http://go.microsoft.com/fwlink/?LinkId=31794/" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WorkstationServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Workstation service creates and maintains client network connections to remote servers. If this service is stopped access to network resources such as file shares will be unavailable.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service was stopped by an Administrator.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>The service can be restarted using the Services snap-in which can be accessed through the Computer Management console task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Computer Management Console</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.ComputerManagement.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Avg. Disk Queue Length performance counter.</maml:para>
              <maml:para>The Physical Disk\Avg. Disk Queue Length performance counters exposes the average numbers of both read and write requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Avg. Disk sec/Read (PhysicalDisk\Avg. Disk sec/Read) for the physical disk has exceeded the threshold. The physical disk and possibly even overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>The Avg. Disk sec/Read counter measures the average time of data reads on the disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high Avg. Disk sec/Read performance counter value may occur due to a burst of disk read requests by either an operating system or application.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Physical Disk\Avg. Disk sec/Read performance counter you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Physical Disk Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDiskPerformance.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>To increase the available storage subsystem throughput for the physical disk, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Upgrade the controllers or disk drives.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Switch from just a bunch of disks (JBOD) to striped arrays.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Increase the number of actual spindles.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Be sure to set this threshold value appropriately for your specific storage hardware. The threshold value will vary according to the disks underlying storage subsystem. For example, the disk might be a single spindle or a large disk array.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>The Avg. Disk sec/Read counter is useful in gathering throughput data. If the average time is long enough, you can analyze a histogram of the arrays response to specific loads (queues, request sizes, and so on). If possible, you should observe workloads separately.</maml:para>
              <maml:para>You can use throughput metrics to determine:</maml:para>
              <maml:para>1.  The behavior of a workload running on a given host system.  You can track the workload requirements for disk read requests over time. Characterization of workloads is an important part of performance analysis and capacity planning.</maml:para>
              <maml:para>2.  The peak and sustainable levels of performance that are provided by a given storage subsystem. A workload can either artificially or naturally be used to push a storage subsystem (in this case, a given physical disk) to its limits. Determining these limits provides useful configuration information for system designers and administrators.</maml:para>
              <maml:para>However, without thorough knowledge of the underlying storage subsystem of the physical disk (for example, knowing whether it is a single spindle or a massive disk array), it can be difficult to provide an optimized one size fits all threshold value.</maml:para>
              <maml:para>You must also consider the Avg. Disk sec/Read counter in conjunction with other read request characteristics (for example, request size and randomness/sequentially) and the equivalent counters for read disk requests.</maml:para>
              <maml:para>If the Avg. Disk sec/Read counter is tracked over time and if it increases with the intensity of the workloads that are driving the read requests, it is reasonable to suspect that the physical disk is saturated if throughput does not increase and overall system throughput starts to degrade.</maml:para>
              <maml:para>
                For more information about storage architecture and driver support, see the Storage - Architecture and Driver Support Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=26156</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=26156" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerRead.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Avg. Disk sec/Read performance counter.</maml:para>
              <maml:para>The Physical Disk\Avg. Disk sec/Read performance counter exposes the average time, in seconds, of the average disk read.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Avg. Disk sec/Transfer (PhysicalDisk\Avg. Disk sec/Transfer) for the physical disk has exceeded the threshold. The physical disk and possibly even overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>The Avg. Disk sec/Transfer counter measures the average time of data reads and writes on the disk.</maml:para>
              <maml:para>The Avg. Disk sec/ Transfer counter is made up from both read and write disk Transfer requests. To view recent disk average rate of read and write Transfer requests you can use the following views:</maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Physical Disk\Avg. Disk Sec/Reads Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDiskAvgDiskSecReads.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Physical Disk\Avg. Disk Sec/Writes Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDiskAvgDiskSecWrites.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high Avg. Disk sec/Transfer performance counter value may occur due to a burst of disk transfer requests by either an operating system or application.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Physical Disk\Avg. Disk sec/Transfers performance counter you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Physical Disk Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDiskPerformance.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para>To increase the available storage subsystem throughput for this physical disk, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Upgrade the controllers or disk drives.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Switch from RAID-5 to RAID-0+1.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Increase the number of actual spindles.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Be sure to set this threshold value appropriately for your specific storage hardware. The threshold value will vary according to the disks underlying storage subsystem. For example, the disk might be a single spindle or a large disk array. You can use MOM overrides to define exception thresholds, which can be applied to specific computers or entire computer groups.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>The Avg. Disk sec/Transfer counter is useful in gathering throughput data. If the average time is long enough, you can analyze a histogram of the arrays response to specific loads (queues, request sizes, and so on). If possible, you should observe workloads separately.</maml:para>
              <maml:para>You can use throughput metrics to determine:</maml:para>
              <maml:para>1.  The behavior of a workload running on a given host system. You can track the workload requirements for disk transfer requests over time. Characterization of workloads is an important part of performance analysis and capacity planning.</maml:para>
              <maml:para>2.  The peak and sustainable levels of performance that are provided by a given storage subsystem. A workload can either be used to artificially or naturally push a storage subsystem (in this case, a given physical disk) to its limits. Determining these limits provides useful configuration information for system designers and administrators.</maml:para>
              <maml:para>However, without thorough knowledge of the underlying storage subsystem of the physical disk (for example, knowing whether it is a single spindle or a massive disk array), it can be difficult to provide an optimized one size fits all threshold value.</maml:para>
              <maml:para>You must also consider the Avg. Disk sec/Transfer counter in conjunction with other transfer request characteristics (for example, request size and randomness/sequentially) and the equivalent counters for write disk requests.</maml:para>
              <maml:para>If the Avg. Disk sec/Transfers counter is tracked over time and if it increases with the intensity of the workloads that are driving the transfer requests, it is reasonable to suspect that the physical disk is saturated if throughput does not increase and the user experiences degraded system throughput.</maml:para>
              <maml:para>
                For more information about storage architecture and driver support, see the Storage - Architecture and Driver Support Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=26156</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=26156" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerTransfer.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Avg. Disk sec/Transfer performance counter.</maml:para>
              <maml:para>The Physical Disk\Avg. Disk sec/Transfer performance counter exposes the average time, in seconds, of the average disk transfer.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Avg. Disk sec/Write (PhysicalDisk\Avg. Disk sec/Write) for the physical disk has exceeded the threshold. The physical disk and possibly even overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>The The Avg. Disk sec/Write counter measures the average time of data writes on the disk.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high Avg. Disk sec/Write performance counter value may occur due to a burst of disk write requests by either an operating system or application.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Physical Disk\Avg. Disk sec/Write performance counter you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Physical Disk Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.PhysicalDiskPerformance.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>To increase the available storage subsystem throughput for this physical disk, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Upgrade the controllers or disk drives.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Switch from RAID-5 to RAID-0+1.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Increase the number of actual spindles.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Be sure to set this threshold value appropriately for your specific storage hardware. The threshold value will vary according to the disks underlying storage subsystem. For example, the disk might be a single spindle or a large disk array. You can use MOM overrides to define exception thresholds, which can be applied to specific computers or entire computer groups.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>The Avg. Disk sec/Writes counter is useful in gathering throughput data. If the average time is long enough, you can analyze a histogram of the arrays response to specific loads (queues, request sizes, and so on). If possible, you should observe workloads separately.</maml:para>
              <maml:para>You can use throughput metrics to determine:</maml:para>
              <maml:para>1.  The behavior of a workload running on a given host system. You can track the workload requirements for disk write requests over time. Characterization of workloads is an important part of performance analysis and capacity planning.</maml:para>
              <maml:para>2.  The peak and sustainable levels of performance that are provided by a given storage subsystem. A workload can either be used to artificially or naturally push a storage subsystem (in this case, a given physical disk) to its limits. Determining these limits provides useful configuration information for system designers and administrators.</maml:para>
              <maml:para>However, without thorough knowledge of the underlying storage subsystem of the physical disk (for example, knowing whether it is a single spindle or a massive disk array), it can be difficult to provide an optimized one size fits all threshold value.</maml:para>
              <maml:para>You must also consider the Avg. Disk sec/Writes counter in conjunction with other write request characteristics (for example, request size and randomness/sequentially) and the equivalent counters for write disk requests.</maml:para>
              <maml:para>If the Avg. Disk sec/Writes counter is tracked over time and if it increases with the intensity of the workloads that are driving the write requests, it is reasonable to suspect that the physical disk is saturated if throughput does not increase and the user experiences degraded system throughput.</maml:para>
              <maml:para>
                For more information about storage architecture and driver support, see the Storage - Architecture and Driver Support Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=26156</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=26156" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AvgDiskSecPerWrite.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Avg. Disk sec/Write performance counter.</maml:para>
              <maml:para>The Physical Disk\Avg. Disk sec/ Write performance counter exposes the average time, in seconds, of the average disk write.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.CurrentDiskQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Current Queue Length performance counter.</maml:para>
              <maml:para>The Physical Disk\Current Queue Length performance counters exposes the current numbers of both read and write requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskBytesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Disk Bytes/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Disk Bytes/sec performance counter exposes the rate bytes are transferred to or from the disk during write or read operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskReadsPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Disk Reads/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Disk Reads/sec performance counter exposes the rate of read operations on the disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskWritesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Disk Writes/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Disk Writes/sec performance counter exposes the rate of read operations on the disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.PercentIdle.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\% Idle Time performance counter.</maml:para>
              <maml:para>The Physical Disk\% Idle Time performance counter exposes the percentage of time during the sample interval that the disk was idle.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskReadBytesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Disk Read Bytes/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Disk Read Bytes/sec performance counter exposes the rate at which bytes are transferred from the disk during read operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.DiskWriteBytesPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Disk Write Bytes/sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Disk Write Bytes/sec performance counter exposes the rate at which bytes are transferred from the disk during write operations.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AverageDiskReadQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Avg. Disk Read Queue Length performance counter.</maml:para>
              <maml:para>The Physical Disk\Avg. Disk Read Queue Length performance counter exposes the average number of read requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.AverageDiskWriteQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Avg. Disk Write Queue Length performance counter.</maml:para>
              <maml:para>The Physical Disk\Avg. Disk Write Queue Length performance counter exposes the average number of write requests that were queued for the selected disk during the sample interval.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.PhysicalDisk.SplitIOPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Physical Disk\Split IO/Sec performance counter.</maml:para>
              <maml:para>The Physical Disk\Split IO/Sec performance counter exposes the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor.CPUUtilization" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The CPU Utilization (Processor Information\% Processor Time) for the system processor has exceeded the threshold. Once exceeded overall system performance may diminish significantly which will result in poor operating system and application performance.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When a computer is under substantial load for a sustained period of time it can be caused by any of the following conditions:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The resource requirements for the application set installed on the computer exceeds the capabilities of the computers hardware configuration.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Demand on the computer resources has increased over time and the computer hardware configuration is no longer able to satisfy increasing demand.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>An application that is running on the computer may have entered into an unhealthy state and is now demanding irregular volumes of system resources.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Processor related performance counters you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Processor Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>To resolve this issue an administrator can perform the following tasks:</maml:para>
              <maml:para>1.  Evaluate the % Processor Utilization counter for each of the processes running on the server. This can be done by using either Task Manager or the Performance Monitoring snap-in. Determine which process(s) are consuming the most resources and monitor them over time to determine whether they appear to be returning to normal performance ranges. If not, addition application specific diagnostics should be performed to determine the most appropriate way to resolve the issue.</maml:para>
              <maml:para>2.  If it is determined that client load has increased over time and the computer is simply no longer able to satisfy demand, perform additional performance monitoring procedures to determine if basic hardware upgrades can enable the computer to return to optimal performance ranges.</maml:para>
              <maml:para>3.  If it has been determined that the application has entered into an unhealthy state, possibly due to a product defect, it might be necessary to restart the application. If the issue persists, you might need to contact the application vendor.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The % DPC Time (Processor Information\% DPC Time) for the processor has exceeded the threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>% DPC Time is the percentage of time that the processor spends receiving and servicing deferred procedure calls (DPCs). DPCs are interrupts that are run at a lower priority than standard interrupts. If a high % DPC Time is sustained there may be a processor bottleneck or an application or hardware related issue that can significantly diminish overall system performance.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high % DPC Time value can be caused by one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Processor bottleneck</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Software-related problem</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Hardware or device driver related problem</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent history for the Processor related performance counters you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Processor Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>To determine the root cause of a high DPC, rate follow the process outlined below.</maml:para>
              <maml:para>Observe the proportion of the processor time that is spent servicing interrupts and DPCs. To do this, monitor the following counters in real time using System Monitor:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Processor Information\% Processor Time</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Processor Information\% Interrupt Time</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Processor Information\% DPC Time</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>Compare the values of the % Interrupt Time and % DPC Time counters to Processor Information\% Processor Time for each processor instance.</maml:para>
              <maml:para />
              <maml:para>If a processor instance is running a sustained % Processor Time that is &gt; 85% and it is also spending &gt; 15% of that time servicing Interrupts and/or DPCs, the processor is probably the source of a performance bottleneck. This bottleneck can be addressed by upgrading or adding additional processors to the computer.</maml:para>
              <maml:para>If the processor is running a sustained % Processor Time of &lt; 85% and it is also spending &gt; 15% of that time servicing interrupts and/or DPCs, the performance issue may be the result of either an application or hardware related issue.</maml:para>
              <maml:para>Where a hardware device is the root cause, an administrator will find that the % DPC Time has probably increased substantially over a short period time. This will often occur when new hardware is installed or drivers have been upgraded. If the administrator can isolate the issue to a hardware/device driver issue, it can be addressed by working with the vendor.</maml:para>
              <maml:para>In cases where you are administering a multiprocessor system that does not distribute interrupts symmetrically, you can often improve the distribution of the processor workload by adding network adapters so that there is one adapter for every processor. Generally, you only add adapters when you need to improve the throughput of your system. Network adapters, like any additional hardware, have some intrinsic overhead. However, if one of the processors is nearly always active (that is, if Processor Information: % Processor Time = 100) and more than half of its time is spent servicing DPCs (if Processor Information: % DPC Time &gt; 50), then adding an adapter is likely to improve system performance, as long as the available network bandwidth is not already saturated.</maml:para>
              <maml:para>Where an application is the root cause, you will find that DPCs are probably being blocked by an application that has issued a call that is taking a substantial amount of time to complete. During this time DPCs are blocked and will be queued. To determine which application is the root cause, you must run advanced performance, tracing, and diagnostics to pin point the exact application that is responsible for the performance issue.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The % Interrupt Time (Processor Information\% Interrupt Time) for the processor has exceeded the threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>% Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high % Interrupt Time most often indicates that there is a problem with a hardware device.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To view recent Processor Information\% Interrupt Time history you can use the following view:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Processor Performance View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.Processor.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
              <maml:para />
              <maml:para>The % Interrupt Time counter will not specifically identify the device that is causing a high % Interrupt Time. To identify the device use Kernrate Viewer (KrView.exe) or Process Trace Information events to determine which ISRs are being dispatched most frequently.</maml:para>
              <maml:para>Once the device has been identified the vendor should be contacted to determine a final resolution.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>
                For more information about the Kernrate Viewer, see the Microsoft Download Center Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27748</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27748" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about the processor object, see the Microsoft Corporation Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27758</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27758" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about analyzing processor activity, see the Microsoft Windows 2000 Resource Kits Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27678</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27678" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor.PercentDPCTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor Information\% DPC Time performance counter.</maml:para>
              <maml:para>The Processor Information\% DPC Time performance counter exposes the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor.PercentInterruptTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor Information\% Interrupt Time performance counter.</maml:para>
              <maml:para>The Processor Information\% Interrupt Time performance counter exposes the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor.PercentProcessorTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor\% Processor Time performance counter.</maml:para>
              <maml:para>The Processor\% Processor Time performance counter exposes the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the duration of the idle thread is active in the sample interval, and subtracting that time from interval duration.  (Each processor has an idle thread that consumes cycles when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It is calculated by monitoring the time that the service is inactive, and subtracting that value from 100%.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.CPUUtilization" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The CPU Utilization (Processor\% Processor Time) for the system  logical processor has exceeded the threshold. Once exceeded overall system performance may diminish significantly which will result in poor operating system and application performance.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When a computer is under substantial load for a sustained period of time it can be caused by any of the following conditions:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The resource requirements for the application set installed on the computer exceeds the capabilities of the computers hardware configuration.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Demand on the computer resources has increased over time and the computer hardware configuration is no longer able to satisfy increasing demand.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>An application that is running on the computer may have entered into an unhealthy state and is now demanding irregular volumes of system resources.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve this issue an administrator can perform the following tasks:</maml:para>
              <maml:para>1.  Evaluate the % Processor Utilization counter for each of the logical processes running on the server. This can be done by using either Task Manager or the Performance Monitoring snap-in. Determine which process(s) are consuming the most resources and monitor them over time to determine whether they appear to be returning to normal performance ranges. If not, addition application specific diagnostics should be performed to determine the most appropriate way to resolve the issue.</maml:para>
              <maml:para>2.  If it is determined that client load has increased over time and the computer is simply no longer able to satisfy demand, perform additional performance monitoring procedures to determine if basic hardware upgrades can enable the computer to return to optimal performance ranges.</maml:para>
              <maml:para>3.  If it has been determined that the application has entered into an unhealthy state, possibly due to a product defect, it might be necessary to restart the application. If the issue persists, you might need to contact the application vendor.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The % DPC Time (Processor\% DPC Time) for the logical processor has exceeded the threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>% DPC Time is the percentage of time that the logical processor spends receiving and servicing deferred procedure calls (DPCs). DPCs are interrupts that are run at a lower priority than standard interrupts. If a high % DPC Time is sustained there may be a logical processor bottleneck or an application or hardware related issue that can significantly diminish overall system performance.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high % DPC Time value can be caused by one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Logical Processor bottleneck</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Software-related problem</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Hardware or device driver related problem</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To determine the root cause of a high DPC, rate follow the process outlined below.</maml:para>
              <maml:para>Observe the proportion of the processor time that is spent servicing interrupts and DPCs. To do this, monitor the following counters in real time using System Monitor:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Processor\% Processor Time</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Processor\% Interrupt Time</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Processor\% DPC Time</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>Compare the values of the % Interrupt Time and % DPC Time counters to Processor\% Processor Time for each processor instance.</maml:para>
              <maml:para />
              <maml:para>If a logical processor instance is running a sustained % Processor Time that is &gt; 85% and it is also spending &gt; 15% of that time servicing Interrupts and/or DPCs, the processor is probably the source of a performance bottleneck. This bottleneck can be addressed by upgrading or adding additional processors to the computer.</maml:para>
              <maml:para>If the logical processor is running a sustained % Processor Time of &lt; 85% and it is also spending &gt; 15% of that time servicing interrupts and/or DPCs, the performance issue may be the result of either an application or hardware related issue.</maml:para>
              <maml:para>Where a hardware device is the root cause, an administrator will find that the % DPC Time has probably increased substantially over a short period time. This will often occur when new hardware is installed or drivers have been upgraded. If the administrator can isolate the issue to a hardware/device driver issue, it can be addressed by working with the vendor.</maml:para>
              <maml:para>In cases where you are administering a multiprocessor system that does not distribute interrupts symmetrically, you can often improve the distribution of the processor workload by adding network adapters so that there is one adapter for every processor. Generally, you only add adapters when you need to improve the throughput of your system. Network adapters, like any additional hardware, have some intrinsic overhead. However, if one of the processors is nearly always active (that is, if Processor Information: % Processor Time = 100) and more than half of its time is spent servicing DPCs (if Processor Information: % DPC Time &gt; 50), then adding an adapter is likely to improve system performance, as long as the available network bandwidth is not already saturated.</maml:para>
              <maml:para>Where an application is the root cause, you will find that DPCs are probably being blocked by an application that has issued a call that is taking a substantial amount of time to complete. During this time DPCs are blocked and will be queued. To determine which application is the root cause, you must run advanced performance, tracing, and diagnostics to pin point the exact application that is responsible for the performance issue.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The % Interrupt Time (Processor Information\% Interrupt Time) for the logical processor has exceeded the threshold. Overall system performance may significantly diminish which will result in poor operating system and application performance.</maml:para>
              <maml:para>% Interrupt Time is the time the logical processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A high % Interrupt Time most often indicates that there is a problem with a hardware device.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>
                For more information about the Kernrate Viewer, see the Microsoft Download Center Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27748</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27748" /></maml:navigationLink>.
              </maml:para>
              <maml:para>
                For more information about the processor object, see the Microsoft Corporation Web site at <maml:navigationLink><maml:linkText>http://go.microsoft.com/fwlink/?LinkId=27758</maml:linkText><maml:uri href="http://go.microsoft.com/fwlink/?LinkId=27758" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentProcessorTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor\% Processor Time performance counter of Logical Processor.</maml:para>
              <maml:para>The Processor\% Processor Time performance counter exposes the percentage of elapsed time that the logical processor spends to execute a non-Idle thread. It is calculated by measuring the duration of the idle thread is active in the sample interval, and subtracting that time from interval duration.  (Each logical processor has an idle thread that consumes cycles when no other threads are ready to run). This counter is the primary indicator of logical processor activity, and displays the average percentage of busy time observed during the sample interval. It is calculated by monitoring the time that the service is inactive, and subtracting that value from 100%.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentDPCTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor\% DPC Time performance counter  of Logical Processor.</maml:para>
              <maml:para>The Processor\% DPC Time performance counter exposes the percentage of time that the logical processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalProcessor.PercentInterruptTime.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Processor\% Interrupt Time performance counter of Logical Processor.</maml:para>
              <maml:para>The Processor Information\% Interrupt Time performance counter exposes the time the logical processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.DiskPerformanceAnalysis" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Disk Performance analysis report displays a chart for the following Performance counters:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>LogicalDisk\Avg. Disk Queue Length\_Total</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>LogicalDisk\Disk Reads/sec\_Total</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>LogicalDisk\Disk Writes/sec\_Total</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>LogicalDisk\Avg. Disk sec/Transfer\_Total</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>LogicalDisk\Disk Bytes/sec\_Total</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Server 2016 and above Logical Disk</maml:para>
              <maml:para>Search for disks by the logical name (e.g. C:).</maml:para>
              <maml:para>The report displays a chart and data table for every distinct object supplied. (e.g. Parameters include C: and D: there will be two charts on the report). The report shows a historical chart without aggregation.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Server 2016 and above Logical Disk type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Business hours: Allows filtering the results to one set of Business hours for a defined number of weekdays</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>This report requires the following discovery to be enabled:</maml:para>
              <maml:para>Discover Windows Logical Disks</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor runs on a periodic basis (Every Saturday  at 3 a.m. by default) to check the fragmentation levels of all logical drives.  If fragmentation levels are found to be above threshold then by default the state of the monitor will change to "Warning" and an alert will be generated.  There is a recovery named "Logical Disk Defragmentation"  targeted to this monitor, which is disabled by default.  If the recovery is enabled then the state change will automatically kick off a task to defragment the logical drive.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>This monitor has the following overridable parameters, in addition to what is generically available for all monitors:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>
                    <maml:ui>Use OS Recommendation</maml:ui> : This parameter determines whether the fragmentation level check will use the default threshold determined by the operating system or not.  If this parameter is set to "False" then the value from "File Percent Fragmentation Threshold" will be used.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    <maml:ui>File Percent Fragmentation Threshold</maml:ui> : If the "Use OS Recommendation" is set to "False" then this value will be used as the threshold for fragmentation levels.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    <maml:ui>Start time</maml:ui> : The time of the day (HH:MM) that the fragmentation check should be run.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    <maml:ui>Days Of Week mask</maml:ui> : The day(s) that the fragmentation check should be run. The values for the days are Sunday (1), Monday (2), Tuesday (4), Wednesday (8), Thursday (16), Friday (32) and Saturday (64).  To specify multiple days, add the values for the days together.  For example, for Monday, Wednesday, and Friday, specify 42 (2+8+32).
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When new files are created or data is added to existing files, the file system attempts to allocate space as continuously as it can so that read operations can perform as fast as possible.  Over time, allocating space in contiuous sections becomes less and less likely and the result is that files are fragmented across the disk(s).  The more fragmented the files on a disk become, the longer it will take the file system to work with those files, which can slow the overall system.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>
                <maml:ui>NOTE</maml:ui> : Defragmenting a drive can be a resource intensive operation and may slow down system performance while it is being performed.  It may be preferrable to defragment drives during off hours.
              </maml:para>
              <maml:para>If the fragmentation threshold for the drive is appropriate then the issue can be resolved by defragmenting the drive via one of the following means:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>
                    <maml:ui>Remotely</maml:ui>: The <maml:navigationLink><maml:linkText>Logical Disk Defragmentation Task</maml:linkText><maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.LogicalDisk.DefragAnalysis.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" /></maml:navigationLink> can be used to remotely perform the defragmentation process.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    <maml:ui>Locally</maml:ui> : Connect to the server via terminal services or log onto it locally.  Under "My Computer" open up the properties of the logical disk that needs to be defragmented.  Switch to the "Tools" tab in the properties window and click the "Defragment now..." button.  From there follow the instructions in the "Disk Defragmentor" window to analyze or defragment the disk.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para />
                </maml:listItem>
              </maml:list>
              <maml:para>This monitor does not support the on-demand "recalculate health" feature of the Health Explorer window in the Operations Console.  When the issue is resolved and the alert is closed either manually reset the monitor's state or wait for the next scheduled interval for the monitor to automatically reset.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.OperatingSystemConfiguration" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Operating System Configuration report displays the following discovered properties:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Physical Memory</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Build Number</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Service Pack Version</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Install Date</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>CSD Version</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>OS Version</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Serial Number</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>System Drive</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Windows Directory</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating system</maml:para>
              <maml:para>Search for objects with contains Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a matrix detailing all the found properties.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Server 2016 and above Operating system type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.OperatingSystemPerformance" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Operating System Performance report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>System Processor Queue Length</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Memory Available Megabytes</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Memory Pages/second</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.OperatingSystemStorageConfiguration" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Operating System Storage Configuration report displays the following discovered properties:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Device Name</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>File System</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Device Description</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Size (Bytes)</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Server 2016 and above Logical Disk</maml:para>
              <maml:para>Search for objects with contains C:</maml:para>
              <maml:para />
              <maml:para>The report displays a matrix detailing all the found properties.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Server 2016 and above Logical Disk type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Server 2016 and above Logical Disk type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistory" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Total Processor % Processor Time</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The report aggregates monthly by days"</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryContextSwitchesPerSec" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Context switches per Second report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Context switches per sec</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.AvailableMB" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Memory - available Megabytes report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Memory - available Megabytes</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PageReadsPerSec" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Page reads per second report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Page reads per second</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PagesPerSec" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Pages per second report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Page per second</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryMemory.PageWritesPerSec" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Page writes per second report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Page write per second</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryPagingFile.PercentageUsage" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Paging file - percent usage report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Paging file - percent usage</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryPercentInterruptTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Percent interrupt time report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Percent interrupt time</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryPercentProcessorTime" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Percent Processor time report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>% Processor time</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryPhysicalDisk.AvgDiskQueueLength" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Physical disk - average disk queue length report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Physical disk - average disk queue length</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type:</maml:para>
              <maml:para>Windows Server 2016 and above Physical Disk</maml:para>
              <maml:para>Search for objects with contains and Disk x where x starts with 0 and resembles the physical disk objects.</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of type Windows Server 2016 and above Physical Disk.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Server 2016 and above Physical Disk type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryPoolNonpagedBytes" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Memory Pool Non-paged Bytes report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Memory\Pool Nonpaged Bytes</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type Windows Server 2016 and above Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above.</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of type Windows Server 2016 and above Operating System.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Server 2016 and above Operating system" type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The collection rule for this report is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Memory Pool Non-paged Bytes" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the rule to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryPoolPagedBytes" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Memory Pool Paged Bytes report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Memory\Pool Paged Bytes</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type Windows Server 2016 and above Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above.</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of type Windows Server 2016 and above Operating System.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Server 2016 and above Operating system" type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The collection rule for this report is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Rules, enter "Memory Pool Paged Bytes" in the "Look for" an click on find now.</maml:para>
              <maml:para>Override the rule to set Enabled = "True".</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Report.Windows.Server.10.0.PerformanceHistoryProcessorQueueLength" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>
                <maml:ui>How does this report work?</maml:ui>
              </maml:para>
              <maml:para>The Performance History Percent Processor queue length report displays one chart with these performance items:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Processor queue length</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>The report finds data if the objects supplied are of type</maml:para>
              <maml:para>Windows Operating System</maml:para>
              <maml:para>Search for objects with contains and Windows Server 2016 and above</maml:para>
              <maml:para />
              <maml:para>The report displays a separate chart for every selected object. The data is aggregated to days of a month.</maml:para>
              <maml:para>
                <maml:ui>How to use this report?</maml:ui>
              </maml:para>
              <maml:para>When run from the Reporting space:</maml:para>
              <maml:para>The second column in the search results shows of which type the displayed objects are. Make sure you select objects of Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>When run from the Monitoring space:</maml:para>
              <maml:para>Create a state view or performance view by choosing the Windows Operating System type.</maml:para>
              <maml:para />
              <maml:para>
                <maml:ui>What Parameters are offered?</maml:ui>
              </maml:para>
              <maml:para>Date/Time selection: Allows selecting a relative or fixed date and time range and time zone.</maml:para>
              <maml:para>Object: Allows adding objects to run this report for</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.MemoryFreeSystemPageTableEntries.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Free System Page Table Entries performance counter.</maml:para>
              <maml:para>The Memory\Free System Page Table Entries performance counter exposes the number of page table entries not currently in use by the system.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCacheBytes.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Cache Bytes performance counter.</maml:para>
              <maml:para>The Memory\Cache Bytes performance counter is the sum of the Memory\System Cache Resident Bytes, Memory\System Driver Resident Bytes, Memory\System Code Resident Bytes, and Memory\Pool Paged Resident Bytes counters.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCommittedBytes.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Committed Bytes performance counter.</maml:para>
              <maml:para>Committed Bytes is the amount of committed virtual memory, in bytes. Committed memory is the physical memory which has space reserved on the disk paging file(s).</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesOutputPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Pages Output/sec performance counter.</maml:para>
              <maml:para>Pages Output/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPagesInputPerSec.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Pages Input/sec performance counter.</maml:para>
              <maml:para>Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryCommitLimit.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Commit Limit performance counter.</maml:para>
              <maml:para>Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s). It is measured in bytes. Committed memory is the physical memory which has space reserved on the disk paging files.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemoryPoolPagedResidentBytes.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Pool Paged Resident Bytes performance counter.</maml:para>
              <maml:para>Pool Paged Resident Bytes is the current size, in bytes, of the paged pool. The paged pool is an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.MemorySystemCacheResidentBytes.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Memory\Memory System Cache Resident Bytes performance counter.</maml:para>
              <maml:para>System Cache Resident Bytes is the size, in bytes, of the pageable operating system code in the file system cache. This value includes only current physical pages and does not include any virtual memory pages not currently resident.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.CacheDataMapHitsPercent.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects performance data for the Cache\Data Map Hits % performance counter.</maml:para>
              <maml:para>Data Map Hits is the percentage of data maps in the file system cache that could be resolved without having to retrieve a page from the disk, because the page was already in physical memory.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.CurrentBandwidth.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects Network Interface\Current Bandwidth counter.</maml:para>
              <maml:para>Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.OutputQueueLength.Collection" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects Network Interface\output Queue Length counter.</maml:para>
              <maml:para>Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedReads" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The volume of bytes received per second on the network interface has exceeded the threshold percentage of the interfaces total bandwidth, over multiple samples.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either the system has recently experienced a significant increase in network activity, and this spike has resulted in exceeding the threshold, or the systems network utilization has been steadily increasing over time and has finally reached a point of going over the threshold.</maml:para>
              <maml:para>The other possibility is that the network interface is set to automatically renegotiate the current bandwidth, and the bandwidth that was automatically negotiated is lower.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To further investigate the issue determine the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Is the network interface configured for automatic negotiation?  If so, has the bandwidth changed recently?</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Have the data volumes recently jumped or has the increase been progressively growing over time?  If the collection rule for this counter is enabled, then review the historical data for this counter in views or reports.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>What source(s) are sending data to the system?  Do multiple systems account for the incoming data, or is it coming from relatively few sources?  Use the "IO Read" counter of the "Process" object in performance monitor to identify which processes are receiving large amounts of data.  Also, tools like NETSTAT.EXE and Network Monitor, can help in identifying what systems are connecting and how much data they are sending in.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation, resolutions may vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Reconfigure the network interface and/or the networking device port that it is connected, to ensure that the network bandwidth is maximized.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the volume of data that the system is receiving from external sources.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Upgrade the network interface or the underlying network that the interface is connected to, to allow for the increased traffic.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedWrites" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The volume of bytes sent per second on the network interface has exceeded the threshold percentage of the interfaces total bandwidth, over multiple samples.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either the system has recently experienced a significant increase in network activity, and this spike has resulted in exceeding the threshold, or the systems network utilization has been steadily increasing over time and has finally reached a point of going over the threshold.</maml:para>
              <maml:para>The other possibility is that the network interface is set to automatically renegotiate the current bandwidth, and the bandwidth that was automatically negotiated is lower.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To further investigate the issue determine the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Is the network interface configured for automatic negotiation?  If so, has the bandwidth changed recently?</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Have the data volumes recently jumped or has the increase been progressively growing over time?  If the collection rule for this counter is enabled, then review the historical data for this counter in views or reports.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>What source(s) on the system are sending data out?  Do multiple applications account for the outgoing data, or is it coming from relatively few sources?  Use the "IO Write" counter of the "Process" object in performance monitor to identify which processes are sending large amounts of data.  Also, tools like NETSTAT.EXE and Network Monitor, can help in identifying what types of outgoing data is being sent.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation, resolutions may vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Reconfigure the network interface and/or the networking device port that it is connected, to ensure that the network bandwidth is maximized.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the volume of data that the system is sending.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Upgrade the network interface or the underlying network that the interface is connected to, to allow for the increased traffic.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.NetworkAdapter.PercentBandwidthUsedTotal" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The total volume of received and sent bytes per second on the network interface has exceeded the threshold percentage of the interfaces total bandwidth, over multiple samples.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Either the system has recently experienced a significant increase in network activity, and this spike has resulted in exceeding the threshold, or the systems network utilization has been steadily increasing over time and has finally reached a point of going over the threshold.</maml:para>
              <maml:para>The other possibility is that the network interface is set to automatically renegotiate the current bandwidth, and the bandwidth that was automatically negotiated is lower.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To further investigate the issue determine the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Is the network interface configured for automatic negotiation?  If so, has the bandwidth changed recently?</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Have the data volumes recently jumped or has the increase been progressively growing over time?  If the collection rule for this counter or the received bytes and sent bytes collection rules are enabled, then review the historical data for this counter in views or reports.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Is the data being received or the data being sent, the larger contributor to the overall bandwidth use?  Do multiple sources or applications account for the data, or is it coming from relatively few sources?  Use the "IO Read" and "IO Write" counters of the "Process" object in performance monitor to identify which processes are sending and receiving large amounts of data.  Also, tools like NETSTAT.EXE and Network Monitor, can help in identifying what sources and applications are using bandwidth.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Based on the findings from further investigation, resolutions may vary and could include one of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Reconfigure the network interface and/or the networking device port that it is connected, to ensure that the network bandwidth is maximized.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the volume of data that the system is sending.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Scale back the volume of data that the system is receiving from external sources.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Upgrade the network interface or the underlying network that the interface is connected to, to allow for the increased traffic.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Monitoring.BPA.OperatingSystem.Monitor" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor is used to leverage the Best Practices Analyzer (BPA) features in Windows Server 2016 and above operating systems.  The monitor executes the built-in BPA PowerShell cmdlets to validate that the installed Roles are in compliance with the BPA rules.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.MBFreeSpace" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Logical Disk MB Free Space monitor enables Operators to set varying threshold values for system and non-system logical disk volumes. In addition separate threshold values can be set for Warning and Error states.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>The Logical Disk Free Space monitoring routine is a high configurable solution that enables Operators to set varying threshold values for system and non-system logical disk volumes. In addition separate threshold values can be set for Warning and Error states.</maml:para>
              <maml:para>Since logical disk volumes may vary in size from a few gigabytes to many terabytes or more the Logical Disk Free Space monitoring routine requires that an Operator indicate the Megabyte based threshold values that must be passed before the Warning and Error thresholds reached.</maml:para>
              <maml:para>The default threshold values for the Logical Disk Free Space monitoring routine include:</maml:para>
              <maml:para>System Drive Free Space Thresholds (Defaults)</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Parameter</maml:ui>
                    </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Default Value</maml:ui>
                    </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Error Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>300</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Warning Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>500</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para>Non-System Drive Free Space Thresholds (Defaults)</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Parameter</maml:ui>
                    </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Default Value</maml:ui>
                    </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Error Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>1000</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Warning Mbytes Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>2000</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para />
              <maml:para>Please note that Overrides can be used to change any of the threshold values that are defined above. In addition these thresholds can be applied to all logical disk volume instances in the management group or if needed separate threshold values can be defined for specific logical disk volume instances.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When existing files grow in size and the new files are added, the free space is taken up on a logical disk.  When the amount of free space on the logical disk falls below the threshold, the state for the logical disk will change.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To increase the amount of available disk space, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Run Disk Cleanup to gain more free space on the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Back up and remove files, or delete unnecessary files from the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Move files to another disk or to offline storage.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Purchase additional storage or switch to a larger disk.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>To view recent disk space history you can use the following view:</maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Disk Capacity View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.DiskCapacity.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.PercentageFreeSpace" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Logical Disk % Free Space monitor enables Operators to set varying threshold values for system and non-system logical disk volumes. In addition separate threshold values can be set for Warning and Error states.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>The default threshold values for the Logical Disk % Free Space monitor are:</maml:para>
              <maml:para>System Drive Free Space Thresholds (Defaults)</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Parameter</maml:ui>
                    </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Default Value</maml:ui>
                    </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Error Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>5</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>System Drive Warning Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>10</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para>Non-System Drive Free Space Thresholds (Defaults)</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Parameter</maml:ui>
                    </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>
                      <maml:ui>Default Value</maml:ui>
                    </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Error Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>5</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Non-System Drive Warning Percent Threshold</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>10</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para />
              <maml:para>Please note that Overrides can be used to change any of the threshold values that are defined above. In addition these thresholds can be applied to all logical disk volume instances in the management group or if needed separate threshold values can be defined for specific logical disk volume instances.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>When existing files grow in size and the new files are added, the free space is taken up on a logical disk.  When the amount of free space on the logical disk falls below the threshold, the state for the logical disk will change.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To increase the amount of available disk space, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Run Disk Cleanup to gain more free space on the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Back up and remove files, or delete unnecessary files from the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Move files to another disk or to offline storage.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Purchase additional storage or switch to a larger disk.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>To view recent disk space history you can use the following view:</maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Disk Capacity View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.DiskCapacity.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.NTFSFileSystemCorrupt.Alert" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>NTFS has reported that the logical disk is either corrupted or completely unavailable. Some data stored on the volume may be inaccessible.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A logical disk may become corrupted or inaccessible due to a number of reason some of which may include:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>A physical disk related to the logical disk has been removed or failed.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>A physical disk related to the logical disk has become corrupt.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The disk may have encountered an issue.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Check the status of your hardware for any failures. In most cases, the system log contains additional events from the lower level storage drivers that indicate the cause of the failure.</maml:para>
              <maml:para>After you have isolated and resolved the hardware problem:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>1. Open the disk management snap in.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>2. Rescan the disks then reactivate any disks with errors. Resynchronize or regenerate the volume as necessary if the disk was a member of a mirrored or RAID  5 volume.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    3. <maml:navigationLink><maml:linkText>Run fsutil repair state</maml:linkText><maml:uri condition="Task" href="Microsoft.Windows.Server.10.0.LogicalDisk.FsUtil.RepairState.Task&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" /></maml:navigationLink> on the volume and that will tell you the current health state of the volume.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    4. If required, For State (1) Pro-scan Needed  <maml:navigationLink><maml:linkText>Run Chkdsk /scan</maml:linkText><maml:uri condition="Task" href="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Scan.Task&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" /></maml:navigationLink> on any reactivated volume.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    5. If required, For State (2) Spot Fix Needed  <maml:navigationLink><maml:linkText>Run Chkdsk /spotfix</maml:linkText><maml:uri condition="Task" href="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.SpotFix.Task&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" /></maml:navigationLink> on any reactivated volume.
                  </maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>
                    6. If required, For State (3) Full Check Disk Needed  <maml:navigationLink><maml:linkText>Run chkdsk/f on any reactivated volume.</maml:linkText><maml:uri condition="Task" href="Microsoft.Windows.Server.10.0.LogicalDisk.Chkdsk.Full.Task&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" /></maml:navigationLink> on any reactivated volume.
                  </maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>When customers are experiencing Windows Authentication, Exchange, SharePoint + LOB outages due to the low default value for MaxConcurrentAPI, which is a ceiling for the maximum NTLM or Kerberos PAC password validations a server can take care of at a time.</maml:para>
              <maml:para>Consider the following scenario:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>You have one or more forests that have multiple domains.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>There are combinations of users and resources (such as applications or proxy servers) in different domains.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>There are lots of NTLM logon requests from remote domain users to a resource server that is running Windows Server.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para>In this scenario, the NTLM requests time out. For example, Exchange clients do not authenticate to the Exchange server when this issue occurs. Therefore, users cannot access their mailboxes, and Microsoft Outlook seems to stop responding.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>This issue occurs because the NTLM API throttling limit is reached.</maml:para>
              <maml:para>Proliferation of devices generating authentication stress is leading to a growing trend of outages in large organizations.</maml:para>
              <maml:para>Economy of Scales gained by cloud stresses the windows infrastructure that leverage our Active directory.</maml:para>
              <maml:para>BPOS and O365 have already increased this value to 10 and 150 resp. Registry fix has been widely deployed via past CSS case engagements.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:list>
                <maml:listItem>
                  <maml:para>Raise the MaxConcurrentApi registry value on the server or servers which are seeing the issue. To change the MaxConcurrentApi setting, follow these steps:</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>1. Click Start, click Run, type regedit, and then click OK.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>2. Locate and then click the following registry subkey:</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>3. HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>4. On the Edit menu, point to New, and then click DWORD Value.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>5. Type MaxConcurrentApi, and then press Enter.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>6. On the Edit menu, click Modify.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>7. Type the new MaxConcurrentApi setting in decimal, and then click OK.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>8. At a command prompt, type the following command, and then press Enter:</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>9. net stop netlogon</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>10. Type the following command, and then press Enter:</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>11. net start netlogon</maml:para>
                  <maml:list>
                    <maml:listItem>
                      <maml:para>Verify that the network between the server and its domain controllers (or trusted domain controllers if the condition was seen on a domain controller) is not seeing any latency. Network latency can cause or exacerbate the concern.</maml:para>
                    </maml:listItem>
                    <maml:listItem>
                      <maml:para>For applications and services that are using NTLM, just configure them to use Kerberos authentication instead. The methods to do that will be unique to those applications.</maml:para>
                    </maml:listItem>
                    <maml:listItem>
                      <maml:para>If Kerberos PAC validation is seen as a symptom, disable Kerberos PAC validation if the service allows this. This should be done on the server that has the Kerberos sourced system event 7s appearing.</maml:para>
                    </maml:listItem>
                  </maml:list>
                </maml:listItem>
              </maml:list>
              <maml:para>Note: Kerberos PAC validation cannot be disabled for IIS application pools or for some Exchange-related services.</maml:para>
              <maml:para>Note: In order to decide what value to set for the MaxConcurrentApi setting in your environment refer to the Knowledge Base article below.</maml:para>
              <maml:para>
                Knowledge Base Article: <maml:navigationLink><maml:linkText>2688798</maml:linkText><maml:uri href="http://support.microsoft.com/kb/2688798" /></maml:navigationLink></maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Additional</maml:title>
              <maml:para>How to do performance tuning for NTLM authentication by using the MaxConcurrentApi setting.</maml:para>
              <maml:para>More Information</maml:para>
              <maml:para>
                For more information on this concern review the TechNet article below. <maml:navigationLink><maml:linkText>Configuring MaxConcurrentAPI for NTLM Pass-Through Authentication</maml:linkText><maml:uri href="http://social.technet.microsoft.com/wiki/contents/articles/9759.configuring-maxconcurrentapi-for-ntlm-pass-through-authentication.aspx" /></maml:navigationLink>.
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.FirewallServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Windows Firewall service helps protect your computer by preventing unauthorized users from gaining access to your computer through the Internet or a network.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If this service is stopped, you will unprotected. If restarting the service doesnt resolve the issue and the Operating System is unable to boot in Normal Mode the configuration of the service may need to be updated in Safe Mode. Once in Safe Mode the service should be configured with a startup type of Automatic and the Log On configuration should be set to Local System.</maml:para>
              <maml:para>The service can be restarted using the following task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start the Firewall service</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.StartFirewallService.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.WindowsRemoteManagementServiceHealth" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>Windows Remote Management (WinRM) service implements the WS-Management protocol for remote management. WS-Management is a standard web services protocol used for remote software and hardware management. The WinRM service listens on the network for WS-Management requests and processes them. The WinRM Service needs to be configured with a listener using winrm.cmd command line tool or through Group Policy in order for it to listen over the network. The WinRM service provides access to WMI data and enables event collection. Event collection and subscription to events require that the service is running. WinRM messages use HTTP and HTTPS as transports. The WinRM service does not depend on IIS but is preconfigured to share a port with IIS on the same machine.  The WinRM service reserves the /wsman URL prefix. To prevent conflicts with IIS, administrators should ensure that any websites hosted on IIS do not use the /wsman URL prefix.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A service can stop for many reasons, including:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>The service encountered an exception that stopped the service.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was improperly configured, which prevented it from starting.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>The service was prevented from starting because the user account assigned to the service could not be authenticated.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If this service is stopped, you will not be able to remotely connect to and manage your core server. If restarting the service doesnt resolve the issue and the Operating System is unable to boot in Normal Mode the configuration of the service may need to be updated in Safe Mode. Once in Safe Mode the service should be configured with a startup type of Automatic and the Log On configuration should be set to Local System.</maml:para>
              <maml:para>The service can be restarted using the following task:</maml:para>
              <maml:para />
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start the Windows Remote Management service</maml:linkText>
                  <maml:uri condition="Task" href="$MPElement[Name='Microsoft.Windows.Server.10.0.OperatingSystem.StartWindowsRemoteManagementService.Task']$&amp;tasktarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.ModuleType" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This module type checks the logical disk free space on Windows Server 2016.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>Here is the list of overridable parameters:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Interval Seconds: How frequently (in seconds) the value should be sampled.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Timeout Seconds: Number of seconds that the script is allowed to run before it will be forced to stop.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Debug Flag: This setting enables the script to log different events at running time</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitortype" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor type checks the logical disk free space on Windows Server 2016.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>Here is the list of overridable parameters:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Interval Seconds: How frequently (in seconds) the value should be sampled. The default value is 3600</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning MBytes Threshold for System Drive: The default value is 500</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning % Threshold for System Drives: The default value is 10</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error MBytes Threshold for System Drives: The default value is 300</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error % Threshold for System Drives: The default value is 5</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning threshold in MBytes for the non system drives: The default value is 2000</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning % Threshold for Non-System Drives: The default value is 10</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error threshold in MBytes for the non system drives: The default value is 1000</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error % Threshold for Non-System Drives: The default value is 5</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Timeout Seconds: Number of seconds that the script is allowed to run before it will be forced to stop. The default value is 360.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Debug Flag: This setting enables the script to log different events at running time. The default value is false.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The amount of free disk space on the logical disk volume has fallen below threshold.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>The Logical Disk Free Space monitoring routine is a highly configurable solution that allows Operators to set various threshold values for system and non-system logical disk volumes. In addition, separate threshold values can be set for Warning and Error states.</maml:para>
              <maml:para>Since logical disk volumes may vary in size from a few gigabytes to many terabytes or more, the Logical Disk Free Space monitoring routine requires that an Operator indicates both the Megabyte and Percentage based threshold values that must be passed before the Warning and Error thresholds reached. This means that in order for the threshold to be reached, both the Megabyte and Percentage based threshold values for the System or Non-System Drive must be breached.</maml:para>
              <maml:para>The default threshold values for the Logical Disk Free Space monitoring routine are as follows:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Interval Seconds: How frequently (in seconds) the value should be sampled. The default value is 3600</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning MBytes Threshold for System Drive: The default value is 500</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning % Threshold for System Drives: The default value is 10</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error MBytes Threshold for System Drives: The default value is 300</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error % Threshold for System Drives: The default value is 5</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning threshold in MBytes for the non system drives: The default value is 2000</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Warning % Threshold for Non-System Drives: The default value is 10</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error threshold in MBytes for the non system drives: The default value is 1000</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Error % Threshold for Non-System Drives: The default value is 5</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Timeout Seconds: Number of seconds that the script is allowed to run before it will be forced to stop. The default value is 360.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Debug Flag: This setting enables the script to log different events at running time. The default value is false.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>Please note that Overrides can be used to change any of the threshold values that are defined above. In addition these thresholds can be applied to all logical disk volume instances in the management group or if needed separate threshold values can be defined for specific logical disk volume instances.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>System performance may be adversely affected and the ability to add or modify existing files on the logical disk volume may not be possible until additional free space is made available.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To increase the amount of available disk space, do one or more of the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Run Disk Cleanup to gain more free space on the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Back up and remove files, or delete unnecessary files from the disk.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Move files to another disk or to offline storage.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Purchase additional storage or switch to a larger disk.</maml:para>
                </maml:listItem>
              </maml:list>
              <maml:para />
              <maml:para>To view recent disk space history you can use the following view:</maml:para>
              <maml:para>
                <maml:navigationLink>
                  <maml:linkText>Start Disk Capacity View</maml:linkText>
                  <maml:uri condition="View" href="$MPElement[Name='WindowsServer!Microsoft.Windows.Server.DiskCapacity.Dashboard.View']$&amp;viewtarget={$TARGET$}" uri="MOM.Console.Exe" />
                </maml:navigationLink>
              </maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The monitor alerts when event 153 error occurs: Storport miniport driver times out a request.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Miniport driver may time the request individually instead of letting Storport perform the request timing.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>If the requests need to be retried regularly, investigate the health of the disk subsystem concerning any performance issues.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.TotalTimeOffset" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The Time Accuracy Out of Range monitor enables Operators to set varying threshold values for system.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>
                <maml:ui>The Time Accuracy Out of Range monitor is disabled by default. Here is how to enable:</maml:ui>
              </maml:para>
              <maml:para>In the Authoring space, choose Monitors, enter "Time Accuracy Out of Range" in the "Look for" and click on find now.</maml:para>
              <maml:para>Override the monitor to set Enabled = "True".</maml:para>
              <maml:para>The default threshold is milliSecond</maml:para>
              <maml:para>Please note that Overrides can be used to change threshold values to in form of Microseconds, Ex: threshold = 0.001 is a 1 Microsecond. In addition these thresholds can be applied to all machines in the management group or if needed separate threshold values can be defined for specific machine.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionsEstablished.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This rule collects TCPv4\Connections Established performance counter. The TCPv4\Connections Established performance counter exposes the rate of connections established via TCPv4.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionsEstablished.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv6\Connections Established performance counter.  The TCPv6\Connections Established performance counter exposes the rate of connections established via TCPv6.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionFailures.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv4\Connection Failures performance counter. The TCPv4\Connection Failures performance counter exposes the rate of failed TCPv4 connections.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A failure usually indicates a loss of data somewhere in the process. A data loss can occur at many locations. This could be an indication of another device being down, or problems with the client-side configuration of the software.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionFailures.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv6\Connection Failures performance counter. The TCPv6\Connection Failures performance counter exposes the rate of failed TCPv6 connections.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A failure usually indicates a loss of data somewhere in the process. A data loss can occur at many locations. This could be an indication of another device being down, or problems with the client-side configuration of the software.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.ConnectionsReset.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv4\Connections Reset performance counter. The TCPv4\Connection Reset performance counter exposes the rate of resetTCPv4 connections.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>This is typically a result of a timeout as opposed to an erroneous set of information. The reset results from a lack of any information over a period of time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.ConnectionsReset.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv6\Connections Reset performance counter. The TCPv6\Connection Reset performance counter exposes the rate of resetTCPv6 connections.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>This is typically a result of a timeout as opposed to an erroneous set of information. The reset results from a lack of any information over a period of time.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv4\Segments Retransmitted/sec performance counter. The TCPv4\Segments Retransmitted/sec performance counter exposes the rate of sections retransmitted via TCPv4 per second.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv6\Segments Retransmitted/sec performance counter. The TCPv6\Segments Retransmitted/sec performance counter exposes the rate of sections retransmitted via TCPv6 per second.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv4\Segments Received/sec performance counter. The TCPv4\Segments Received/sec performance counter exposes the rate of sections received via TCPv4 per second.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv6\Segments Received/sec performance counter. The TCPv6\Segments Received/sec performance counter exposes the rate of sections received via TCPv6 per second.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv4\Segments Sent/sec counter. The TCPv4\ Segments Sent/sec performance counter exposes the rate of sections sent via TCPv4 per second.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec.Collection">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rule collects TCPv6\Segments Sent/sec performance counter. The TCPv6\ Segments Sent/sec performance counter exposes the rate of sections sent via TCPv6 per second.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsRetransmittedPerSec">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor traces through the quantity of segments retransmitted via TCPv4 per second. When the quantity of retransmitted segments exceeds the threshold for the TCPv4\Segments Retransmitted/sec performance counter, the monitor is switched to warning state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Retransmissions are measured based on bytes in the data that are recognized as being transmitted before. When the quantity of retransmitted segments is not high, the network performance is not affected. However, excessive retransmissions indicate a distinct reduction in bandwidth caused by connection failures, connections reset or hardware issues.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Investigate the network factors leading to connection failures and resolve the revealed issues. High retransmission rate might also be caused by a hardware problem. Therefore, it is necessary to investigate further with system counters such as the processor counters. Use baseline values to determine when these counters are out of range and might indicate a problem.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsReceivedPerSec">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor traces through the quantity of segments received via TCPv4 per second. When the quantity of received segments exceeds the threshold for the TCPv4\Segments Received/sec performance counter, the monitor is switched to warning state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A sudden increase of the quantity of received segments indicates network overload or security breaches.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Investigate the factors leading to network overload and resolve the revealed issues. Take actions to eliminate security weak points.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv4.SegmentsSentPerSec">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor traces through the quantity of segments sent via TCPv4 per second (but excluding those containing only retransmitted bytes). When the quantity of sent segments exceeds the threshold for the TCPv4\Segments Sent/sec performance counter, the monitor is switched to warning state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A sudden increase of the quantity of sent segments may indicate a security breach.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Take actions to eliminate security weak points.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsRetransmittedPerSec">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor traces through the quantity of segments retransmitted via TCPv6 per second. When the quantity of retransmitted segments exceeds the threshold for the TCPv6\Segments Retransmitted/sec performance counter, the monitor is switched to warning state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>Retransmissions are measured based on bytes in the data that are recognized as being transmitted before. When the quantity of retransmitted segments is not high, the network performance is not affected. However, excessive retransmissions indicate a distinct reduction in bandwidth caused by connection failures or connections reset.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Investigate the network factors leading to connection failures and resolve the revealed issues. High retransmission rate might also be caused by a hardware problem. Therefore, it is necessary to investigate further with system counters such as the processor counters. Use baseline values to determine when these counters are out of range and might indicate a problem.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsReceivedPerSec">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor traces through the quantity of segments received via TCPv6 per second. When the quantity of received segments exceeds the threshold for the TCPv6\Segments Received/sec performance counter, the monitor is switched to warning state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A sudden increase of the quantity of received segments indicates network overload or security breaches.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Investigate the factors leading to network overload and resolve the revealed issues. Take actions to eliminate security weak points.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.TCPv6.SegmentsSentPerSec">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor traces through the quantity of segments sent via TCPv6 per second (but excluding those containing only retransmitted bytes). When the quantity of sent segments exceeds the threshold for the TCPv6\Segments Sent/sec performance counter, the monitor is switched to warning state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>A sudden increase of the quantity of sent segments may indicate a security breach.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>Take actions to eliminate security weak points.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.OperatingSystem.CoreServicesRollup">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>The rollup monitor for all health related to critical Windows services.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.LogicalDisk.FreeSpaceMonitorRollup">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor aggregates the free space monitors for cluster disks.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.Windows.Server.10.0.Processor.PerformanceRollup">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor aggregates the performance monitors for Processor.</maml:para>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
      </KnowledgeArticles>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>